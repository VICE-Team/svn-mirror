@database ./vice.guide

@Master ./vice.texi

@Width 72


This is the AmigaGuide® file ./vice.guide, produced by Makeinfo-1.55 from 
the input file ./vice.texi.

   

   START-INFO-DIR-ENTRY * VICE: (vice).        VICE, the Versatile
Commodore Emulator. END-INFO-DIR-ENTRY  format  ifinfo   


   \PARAM\  macro  ifinfo 

   VICE Manual  Permission is granted to make and distribute
verbatim copies of this manual provided the copyright notice and this
permission notice are preserved on all copies. 

   Permission is granted to process this file through TeX and print
the results, provided the printed document carries copying
permission notice identical to this one except for the removal of
this paragraph (this paragraph not being relevant to the printed
manual).  ignore  Permission is granted to copy and distribute
modified versions of this manual under the conditions for verbatim
copying, provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.   ifinfo 

     VICE, the Versatile Commodore Emulator 

   0pt plus 1filll Copyright (C) 1998-2012 Dag Lem Copyright (C)
1999-2012 Andreas Matthies Copyright (C) 1999-2012 Martin
Pottendorfer Copyright (C) 2005-2012 Marco van den Heuvel Copyright
(C) 2006-2012 Christian Vogelgsang Copyright (C) 2007-2012 Fabrizio
Gennari Copyright (C) 2007-2012 Daniel Kahlin Copyright (C)
2008-2012 Antti S. Lankila Copyright (C) 2009-2012 Groepaz
Copyright (C) 2009-2012 Ingo Korb Copyright (C) 2009-2012 Errol
Smith Copyright (C) 2010-2012 Olaf Seibert Copyright (C) 2011-2012
Marcus Sutton Copyright (C) 2011-2012 Ulrich Schulz Copyright (C)
2011-2012 Stefan Haubenthal Copyright (C) 2011-2012 Thomas Giesel
Copyright (C) 2011-2012 Kajtar Zsolt Copyright (C) 2012-2012 Benjamin
'BeRo' Rosseaux  Copyright (C) 2000-2011 Spiro Trikaliotis
Copyright (C) 2007-2011 Hannu Nuotio Copyright (C) 1998-2010 Andreas
Boose Copyright (C) 1998-2010 Tibor Biczo Copyright (C) 2007-2010
M. Kiesel Copyright (C) 1999-2007 Andreas Dehmel Copyright (C)
2003-2005 David Hansel Copyright (C) 2000-2004 Markus Brenner
Copyright (C) 1999-2004 Thomas Bretz Copyright (C) 1997-2001 Daniel
Sladic Copyright (C) 1996-2001 André Fachat Copyright (C)
1996-1999 Ettore Perazzoli Copyright (C) 1993-1994, 1997-1999 Teemu
Rantanen Copyright (C) 1993-1996 Jouko Valta Copyright (C)
1993-1994 Jarkko Sonninen  Permission is granted to make and
distribute verbatim copies of this manual provided the copyright
notice and this permission notice are preserved on all copies. 
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.   titlepage 


@Node Main "./vice.guide"
@Next "License"
@Toc "(dir)"

    

    This is the documentation for version 2.2 of VICE, the Versatile
Commodore Emulator.   ifinfo 

   * License::                     The GNU General Public License gives
you                                 permission to redistribute this
program                                 on certain terms; and also
explains that                                 there is no warranty.
 * Preface::                     Fundamental concepts.  * Usage::
                     Invoking the emulators. * System files::
       Files needed to emulate.  * Basics::
Simple things you can do.  * Settings and resources::      Emulator
parameters you can change.  * Machine-specific features::
Peculiar characteristics of the emulators.  * Snapshots::
       Save the emulator state in one file * Monitor::
     The VICE built-in monitor. * c1541::                       The
disk-image maintenance utility.  * File formats::
Technical description of file formats.  * Acknowledgments::
   People involved in VICE. * Copyright::                   Legal
stuff. * Contacts::                    Official home page, email
addresses...  * Concept Index:: * Resource Index::  menu 


@EndNode

@Node "License" "vice.guide/License"
@Next "Preface"
@Prev "Main"
@Toc "Top"

GNU GENERAL PUBLIC LICENSE
***************************

   

                         Version 2, June 1991

   

   Copyright (C) 1989, 1991 Free Software Foundation, Inc.  675 Mass
Ave, Boston, MA 02111-1307, USA  Everyone is permitted to copy and
distribute verbatim copies of this license document, but changing it
is not allowed.  display 

Preamble
=========

      The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.    When we speak of free software, we are
referring to freedom, not price.  Our General Public Licenses are
designed to make sure that you have the freedom to distribute copies
of free software (and charge for this service if you wish), that you
receive source code or can get it if you want it, that you can change
the software or use pieces of it in new free programs; and that you
know you can do these things.    To protect your rights, we need to
make restrictions that forbid anyone to deny you these rights or to
ask you to surrender the rights. These restrictions translate to
certain responsibilities for you if you distribute copies of the
software, or if you modify it.    For example, if you distribute
copies of such a program, whether gratis or for a fee, you must give
the recipients all the rights that you have.  You must make sure that
they, too, receive or can get the source code.  And you must show
them these terms so they know their rights.    We protect your
rights with two steps: (1) copyright the software, and (2) offer you
this license which gives you legal permission to copy, distribute
and/or modify the software.    Also, for each author's protection
and ours, we want to make certain that everyone understands that
there is no warranty for this free software.  If the software is
modified by someone else and passed on, we want its recipients to
know that what they have is not the original, so that any problems
introduced by others will not reflect on the original authors'
reputations.    Finally, any free program is threatened constantly
by software patents.  We wish to avoid the danger that redistributors
of a free program will individually obtain patent licenses, in effect
making the program proprietary.  To prevent this, we have made it
clear that any patent must be licensed for everyone's free use or not
licensed at all.    The precise terms and conditions for copying,
distribution and modification follow. 

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
================================================================

   iftex

   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

   ifinfo 
     This License applies to any program or other work which contains
     a notice placed by the copyright holder saying it may be
     distributed under the terms of this General Public License.  The
     "Program", below, refers to any such program or work, and a
     "work based on the Program" means either the Program or any
     derivative work under copyright law: that is to say, a work
     containing the Program or a portion of it, either verbatim or
     with modifications and/or translated into another language.
     (Hereinafter, translation is included without limitation in the
     term "modification".)  Each licensee is addressed as "you". 
     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The
     act of running the Program is not restricted, and the output
     from the Program is covered only if its contents constitute a
     work based on the Program (independent of having been made by
     running the Program). Whether that is true depends on what the
     Program does. 

     You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this License and to the
     absence of any warranty; and give any other recipients of the
     Program a copy of this License along with the Program.  You
     may charge a fee for the physical act of transferring a copy, and
     you may at your option offer warranty protection in exchange for a
     fee. 

     You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section
     1 above, provided that you also meet all of these conditions:
     
          You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any
          change. 

          You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License. 

          If the modified program normally reads commands
          interactively when run, you must cause it, when started
          running for such interactive use in the most ordinary way,
          to print or display an announcement including an
          appropriate copyright notice and a notice that there is no
          warranty (or else, saying that you provide a warranty) and
          that users may redistribute the program under these
          conditions, and telling the user how to view a copy of this
          License.  (Exception: if the Program itself is interactive
          but does not normally print such an announcement, your work
          based on the Program is not required to print an
          announcement.)
           These requirements apply to the modified work as a whole.
     If identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and
     separate works in themselves, then this License, and its terms,
     do not apply to those sections when you distribute them as
     separate works.  But when you distribute the same sections as
     part of a whole which is a work based on the Program, the
     distribution of the whole must be on the terms of this License,
     whose permissions for other licensees extend to the entire
     whole, and thus to each and every part regardless of who wrote
     it.  Thus, it is not the intent of this section to claim
     rights or contest your rights to work written entirely by you;
     rather, the intent is to exercise the right to control the
     distribution of derivative or collective works based on the
     Program.  In addition, mere aggregation of another work not
     based on the Program with the Program (or with a work based on
     the Program) on a volume of a storage or distribution medium
     does not bring the other work under the scope of this License.
     

     You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following: 
          Accompany it with the complete corresponding
          machine-readable source code, which must be distributed
          under the terms of Sections 1 and 2 above on a medium
          customarily used for software interchange; or, 

          Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than
          your cost of physically performing source distribution, a
          complete machine-readable copy of the corresponding source
          code, to be distributed under the terms of Sections 1 and 2
          above on a medium customarily used for software
          interchange; or, 

          Accompany it with the information you received as to the
          offer to distribute corresponding source code.  (This
          alternative is allowed only for noncommercial distribution
          and only if you received the program in object code or
          executable form with such an offer, in accord with
          Subsection b above.)
           The source code for a work means the preferred form of the
     work for making modifications to it.  For an executable work,
     complete source code means all the source code for all modules
     it contains, plus any associated interface definition files,
     plus the scripts used to control compilation and installation of
     the executable.  However, as a special exception, the source
     code distributed need not include anything that is normally
     distributed (in either source or binary form) with the major
     components (compiler, kernel, and so on) of the operating system
     on which the executable runs, unless that component itself
     accompanies the executable.  If distribution of executable or
     object code is made by offering access to copy from a designated
     place, then offering equivalent access to copy the source code
     from the same place counts as distribution of the source code,
     even though third parties are not compelled to copy the source
     along with the object code. 

     You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program
     is void, and will automatically terminate your rights under this
     License. However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.
     

     You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These
     actions are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any
     work based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it. 

     Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein. You are not responsible for enforcing compliance
     by third parties to this License. 

     If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy
     simultaneously your obligations under this License and any other
     pertinent obligations, then as a consequence you may not
     distribute the Program at all.  For example, if a patent license
     would not permit royalty-free redistribution of the Program by
     all those who receive copies directly or indirectly through you,
     then the only way you could satisfy both it and this License
     would be to refrain entirely from distribution of the Program.
      If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to
     apply in other circumstances.  It is not the purpose of this
     section to induce you to infringe any patents or other property
     right claims or to contest validity of any such claims; this
     section has the sole purpose of protecting the integrity of the
     free software distribution system, which is implemented by
     public license practices.  Many people have made generous
     contributions to the wide range of software distributed through
     that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.  This section is
     intended to make thoroughly clear what is believed to be a
     consequence of the rest of this License. 

     If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted
     only in or among countries not thus excluded.  In such case,
     this License incorporates the limitation as if written in the
     body of this License. 

     The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.
      Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the
     Program does not specify a version number of this License, you
     may choose any version ever published by the Free Software
     Foundation. 

     If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the
     sharing and reuse of software generally. 

     -  -

NO WARRANTY
============


                             NO WARRANTY

   ifinfo 

   BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 

   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.  enumerate 

END OF TERMS AND CONDITIONS
============================

   iftex

                     END OF TERMS AND CONDITIONS

   ifinfo 

How to Apply These Terms to Your New Programs
==============================================

      If you develop a new program, and you want it to be of the
greatest possible use to the public, the best way to achieve this is
to make it free software which everyone can redistribute and change
under these terms.    To do so, attach the following notices to the
program.  It is safest to attach them to the start of each source
file to most effectively convey the exclusion of warranty; and each
file should have at least the "copyright" line and a pointer to where
the full notice is found. 

   ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
Copyright (C) 19YY  NAME OF AUTHOR  This program is free software;
you can redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later
version.  This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.  You should have
received a copy of the GNU General Public License along with this
program; if not, write to the Free Software Foundation, Inc., 59
Temple Place - Suite 330, Boston, MA 02111-1307, USA.  smallexample
 Also add information on how to contact you by electronic and paper
mail.  If the program is interactive, make it output a short notice
like this when it starts in an interactive mode: 

   Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show
w'.  This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.  smallexample
 The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and
`show c'; they could even be mouse-clicks or menu items--whatever
suits your program.  You should also get your employer (if you work
as a programmer) or your school, if any, to sign a "copyright
disclaimer" for the program, if necessary.  Here is a sample; alter
the names: 

   Yoyodyne, Inc., hereby disclaims all copyright interest in the
program `Gnomovision' (which makes passes at compilers) written by
James Hacker.  SIGNATURE OF TY COON, 1 April 1989 Ty Coon,
President of Vice  group  example  This General Public License
does not permit incorporating your program into proprietary programs.
If your program is a subroutine library, you may consider it more
useful to permit linking proprietary applications with the library.
If this is what you want to do, use the GNU Library General Public
License instead of this License. 


@EndNode

@Node "Preface" "vice.guide/Preface"
@Next "Usage"
@Prev "License"
@Toc "Top"

About VICE
***********

    VICE is the one and only "Versatile Commodore Emulator".  It
provides emulation of the Commodore C64, C64DTV, C128, VIC20, PET,
PLUS4 and CBM-II computers within a single package.  The emulators
run as separate programs, but have the same user interface, share the
same settings and support the same file formats.  *Important
notice:* If you have no idea what a Commodore 8-bit computer is, or
have questions about how these machines are used, how the file
formats work or anything else that is not strictly related to VICE,
you should read the appropriate FAQs *first*, as that kind of
information is not available here.  See @{"Contacts" Link "Contacts"}. for information
about how to retrieve the FAQs.  All the emulators provide an
accurate 6502/6510 emulator, with emulation of all the opcodes (both
documented and undocumented ones) and accurate timing.  Unlike other
emulators, VICE aims to be cycle accurate; it tries to emulate chip
timings as precisely as possible and does so *efficiently*. 
Please do *not* expect the C64DTV, C128, PET, PLUS4 and CBM-II
emulators to be as good as the C64 or VIC20 one, as they are still
under construction.  *Notice:* This documentation is written for
the Unix release of VICE. 

   * C64 emulator features:: * C64DTV emulator features:: * C128
emulator features:: * VIC20 emulator features:: * PET emulator
features:: * CBM-II emulator features:: * Keyboard emulation:: *
Joystick emulation:: * Disk drive emulation:: * Supported file
formats:: * Common problems::  menu  


@EndNode

@Node "C64 emulator features" "vice.guide/C64 emulator features"
@Next "C64DTV emulator features"
@Prev "Preface"
@Toc "Preface"

C64 emulator features
======================

    As of version 2.3, two C64 emulators are provided: `x64' (fast)
and `x64sc' (accurate).  The fast C64 emulator, called `x64',
features a fairly complete emulation of the VIC-II video chip:
sprites, all registers and all video modes are fully emulated.  The
emulation has been fully cycle-accurate since version 0.13.0. 
The accurate C64 emulator, called `x64sc', features a cycle-based and
pixel-accurate VIC-II emulation. This requires a much faster machine
than the old `x64'.  A rather complete emulation of the SID sound
chip is also provided.  All the basic features are implemented as
well as most of the complex ones including synchronisation, ring
modulation and filters.  There are three emulators of the SID chip
available: first is the "standard" VICE emulator, available since
VICE 0.12; the second is Dag Lem's reSID engine and the third one is
reSID-fp. The reSID engines are a lot more accurate than the standard
engine, but they are also a lot slower, and only suitable for faster
machines.  Naturally, also both CIAs (or VIAs, in some cases) are
fully emulated and cycle accurate.  


@EndNode

@Node "C64DTV emulator features" "vice.guide/C64DTV emulator features"
@Next "C128 emulator features"
@Prev "C64 emulator features"
@Toc "Preface"

C64DTV emulator features
=========================

    The C64DTV emulator, called `x64dtv', features emulation of
C64DTV revisions 2 and 3. The emulator is under construction, but
most of the DTV specific features are already supported (with varying
accuracy).  Video cache is disabled by default as it currently
doesn't work with some of C64DTV's new video modes. The new video
modes have a simple "fake" video cache implementation that may give
incorrect results and decreased performance.  


@EndNode

@Node "C128 emulator features" "vice.guide/C128 emulator features"
@Next "VIC20 emulator features"
@Prev "C64DTV emulator features"
@Toc "Preface"

C128 emulator features
=======================

    The C128 emulator, called `x128', features a complete emulation
of the internal MMU ("Memory Management Unit"), 80 column VDC screen,
fast IEC bus emulation, 2 MHz mode, Z80 emulation plus all the
features of the C64 emulation.  


@EndNode

@Node "VIC20 emulator features" "vice.guide/VIC20 emulator features"
@Next "PET emulator features"
@Prev "C128 emulator features"
@Toc "Preface"

VIC20 emulator features
========================

    The VIC20 emulates all the internal hardware, including the VIA
chips. The VIC-I video chip is fully emulated except NTSC interlace
mode, so most graphical effects will work correctly.  Sound
support is implemented, but is still at an experimental stage.  If
you think it could be improved and know how to do so, feel free to
contact us (see @{"Contacts" Link "Contacts"}).  The VIC20 emulator now allows the use
of the VIC1112 IEEE488 interface. You have to enable the hardware (by
menu, resource, or commandline option) and then load the IEEE488 ROM
(see for example
`http://www.funet.fi/pub/cbm/schematics/cartridges/vic20/ieee-488/325329-04.bin',
but you have to double the size to 4k for now). The IEEE-488 code is
then started by `SYS45065'.  


@EndNode

@Node "PET emulator features" "vice.guide/PET emulator features"
@Next "CBM-II emulator features"
@Prev "VIC20 emulator features"
@Toc "Preface"

PET emulator features
======================

    The PET emulator emulates the 2001, 3032, 4032, 8032, 8096, 8296
and SuperPET (MicroMainFrame 9000) models, covering practically the
whole series. The hardware is pretty much the same in each and that
is why one single program is enough to emulate all of them.  For more
detailed information about PET hardware please refer to the `PETdoc'
file.  Both the 40 column and 80 column CRTC video chips are
emulated (from the 4032 onward), but a few of the features are not
implemented yet (numbers of rasterlines per char and lines per
screen).  Fortunately, they are not very important for average
applications.  Sound is available for the PET as well, but like the
VIC20's it is still under construction.  The PET 8096 is
basically a PET 8032 with a 64k extension board which allows
remapping the upper 32k with RAM.  You have to write to a special
register at `$fff0' to remap the memory.  The PET 8296 is a 8096 but
with a completely redesigned motherboard with 128k RAM in total.  Of
the additional 32k RAM you can use only some in blocks of 4k, but you
have to set jumpers on the motherboard for it.  VICE uses the command
line options `-petram9' and `-petramA' instead.  Also, the video
controller can handle a larger address range. The PET 8x96 model
emulations run the Commodore LOS-96 operating system - basically an
improved BASIC 4 version with up to 32k for BASIC text and 32k for
variables.  See `PETdoc' for more information.  The SuperPET also
is a PET 8032 with an expansion board.  It can map 4k at a time out
of 64k into the `$9***' area.  Also it has an ACIA 6551 for RS232
communication.  The 6809 CPU that is built into the SuperPET is now
emulated, since release 2.4, including the 6702 dongle chip.  The
PET computers came with three major ROM revisions, so-called BASIC 1,
2 and 4, all of which are provided.  The PET 2001 uses the version 1,
the PET 3032 uses version 2, and the others use version 4.  The 2001
ROM is horribly broken with respect to IEEE488 (they shipped it
before they tested it with the floppy drive, so only tape worked.
Therefore the emulator patches the ROM to fix the IEEE488 routines.
 As well as other low-level fixes the 2001 patch obtains the load
address for a program file from the first two bytes of the file.
This allows the loading of both PET2001-saved files (that have $0400
as their load address) and other PET files (that have $0401).  The
PET2001 saves from $0400 and not from $0401 as other PETs do. 
Moreover, the secondary addresses used are now `0' and `1' for load
and save, respectively, and not arbitrary unused secondary
addresses.  To select which model to run, specify it on the
command line with the `-model MODEL' option, where `MODEL' can be one
of a list of PET model numbers, all described in see @{"PET model" Link "PET model"}  


@EndNode

@Node "CBM-II emulator features" "vice.guide/CBM-II emulator features"
@Next "Keyboard emulation"
@Prev "PET emulator features"
@Toc "Preface"

CBM-II emulator features
=========================

    The CBM-II emulator emulates several types of CBM-II models.
Those models are known under different names in the USA and Europe.
In the States they have been sold as `B128' and `B256', in Europe as
`CBM 610', `CBM 620' (low-profile case) or `CBM 710' and `CBM 720'
(high-profile case with monitor). In addition to that now an
experimental C510 emulation is included. The C510 (also known as
P500) is the little brother of the C600/700 machines. It runs at
roughly 1 MHz and, surprise, it has a VIC-II instead of the CRTC.
Otherwise the different line of computers are very similar. 
These computers are prepared to take a coprocessor board with an 8088
or Z80 CPU.  Indeed there are models `CBM 630' and `CBM 730' that
supposedly had those processors.  However these models are not
emulated.  The basic difference is the amount of RAM these machines
have been supplied with.  The `B128' and the `CBM *10' models had
128k RAM, the others 256k. This implies some banking scheme, as the
6502 can only address 64k.  And indeed those machines use a 6509,
that can address 1 MByte of RAM.  It has 2 registers at addresses 0
and 1.  The indirect bank register at address 1 determines the bank
(0-15) where the opcodes `LDA (zp),Y' and `STA (zp),Y' take the data
from.  The exec bank register at address 0 determines the bank where
all other read and write addresses take place.  The business line
machines (C6xx/7xx) have the RAM in banks 1-2, resp. 1-4. All
available banks are used for BASIC, where program code is separated
from all variables, resp. from normal variables, strings and arrays
that are distributed over other banks. The C510 instead has RAM in
banks 0 and 1, and uses bank 1 for program and all variables. Bank 0,
though, can be accessed by the VIC-II to display graphics.  Many
models have been expanded to more than the built-in memory.  In fact
some machines have been expanded to the full 1M.  Bank 15 is used as
system bank, with only little RAM, and lots of expansion cartridge ROM
area, the I/O and the kernal/basic ROMs.  Some models have been
modified to map RAM into the expansion ROM area.  Those modifications
can be emulated as well.  The different settings are described in
see @{"CBM-II model" Link "CBM-II model"}. 


@EndNode

@Node "Keyboard emulation" "vice.guide/Keyboard emulation"
@Next "Joystick emulation"
@Prev "CBM-II emulator features"
@Toc "Preface"

The keyboard emulation
=======================

    There are two ways of emulating the keyboard in VICE.  The
default way ("symbolic mapping") is to map every key combination to
the corresponding key combination on the real machine: for example,
if you press *, which is bound to `Shift-8' on a U.S. keyboard, in
the C64 emulator, the emulated machine will have just the *unshifted*
* key pressed (as * is unshifted on the C64 keyboard).  Likewise,
pressing ' on the same U.S. keyboard without any shift key will cause
the combination `Shift-7' to be pressed in the emulated C64.  This
way, it becomes quite obvious what keys should be typed to obtain all
the symbols.  There is, however, one problem with symbolic mapping:
some keys really need to be mapped specially regardless.  The most
important examples being, in the VIC20, C64 and C128 emulators, that
CTRL is mapped to Tab and that the Commodore key is mapped to the
left Control). The RUN/STOP key is mapped to the ESC key on the PC
keyboard. The PET emulator, lacking the Commodore key but having an
ESC key, uses the left Control key as RUN/STOP and the ESC key as ESC
of course.   The second way ("positional mapping") is to map
every key on the "real" keyboard to the key which has the same
position on the keyboard of the emulated machine.  This way, no Shift
key is forced by the program (with the exception of the function keys
F2, F4, F6 and F8, which require Shift on the Commodore keyboards),
and the keyboard is more comfortable to use in those programs (such
as some games) that require the keys to be in the correct positions.
 *Warning:* unlike the real C64, VICE "presses" the Shift key
*together* with the key to shift when the Shift must be forced.  In
most cases this should work fine, but some keyboard routines are
quite picky and tend not to recognize the shift key because of this.
For instance, `F6' (which on the real C64 is obtained with `Shift +
F5') could be recognized as `F5'.  In that case, use the shift key
manually (i.e., type `Shift + F5' in the example). Yes, we know this
is a bug.  The `RESTORE' key is mapped to `Page Up' (or `Prev') by
default.  


@EndNode

@Node "Joystick emulation" "vice.guide/Joystick emulation"
@Next "Disk drive emulation"
@Prev "Keyboard emulation"
@Toc "Preface"

The joystick emulation
=======================

    Joysticks can be emulated both via the keyboard and via a real
joystick connected to the host machine (the latter only works on
GNU/Linux systems).  There are two keyboard layouts for joystick
use, known as "numpad" and "custom".  The "numpad" layout uses
the numeric keypad keys, i.e., the numbers 1...9 which emulate all
the directions including the diagonal ones; 0 emulates the fire
button.  The "custom" layout uses the keys w, e, r, s, d, f, x,
c, v for the directions and space for the fire button instead.  


@EndNode

@Node "Disk drive emulation" "vice.guide/Disk drive emulation"
@Next "Supported file formats"
@Prev "Joystick emulation"
@Toc "Preface"

The disk drive emulation
=========================

    All the emulators support up to 4 external disk drives as
devices 8, 9, 10 and 11.  Each of these devices can emulate virtual
Commodore 1541, 1541-II, 1571, 1581, 2031, 2040, 3040, 4040, 1001, 8050
and 8250 drives in one of four ways: 
     using disk images, i.e., files that contain a dump of all the
     blocks contained in a real floppy disk (if you want more
     information about what a disk image is, consult the
     `comp.emulators.cbm' FAQ);

     accessing file system directories, thus giving you the use of
     files without having to copy them to disk images; this also
     allows you to read and write files in the `P00' format (again,
     consult the `comp.emulators.cbm' FAQ for more info).

     accessing a real device connected to the host machine. As of VICE
     1.11 it is possible to connect real drives like Commodore 1541
     to the printer port of the host using the XA1541 or XM1541
     cable. Currently this only works on Linux or Windows using the
     OpenCBM library. You can get it from
     http://www.lb.shuttle.de/puffin/cbm4linux (cbm4linux, Linux
     version) or from http://cbm4win.sf.net/ (cbm4win, Windows
     version). 

     directly using the disk drive of the host. The 3.5" disk drive of
     the host can be used to read or write Commodore 1581 formatted
     disks. Currently this raw drive access feature is only available
     for Linux hosts.  When using disk images there are two
available types of drive emulation.  One of them the "virtual drive"
emulation.  It does *not* really emulate the serial line, but patches
the kernal ROM (with the so-called "kernal traps") so that serial
line operations can be emulated via C language routines.  This
emulation is very fast, but only allows use of standard DOS functions
(and not even all of them).  For real device or raw drive access it
is required to enable this type of emulation.  The IEEE488 drives
(2031, 2040, 3040, 4040, 1001, 8050 and 8250) do not use kernal
traps. Instead the IEEE488 interface lines are monitored and the data
is passed to the drive emulation. To use them on the C64, you need to
enable the IEEE488 interface emulation. Only if the IEEE488 emulation
is enabled, those drives can be selected.  The other alternative is
a "true drive" emulation.  The Commodore disk drives are provided
with their own CPU (a 6502 as the VIC20 and the PETs) and their own
RAM and ROM.  So, in order to more closely emulate its features, a
complete emulation of this hardware must be provided and that is what
the "hardware level" emulation does. When the "hardware level"
emulation is used, the kernal routines are remain unpatched and the
serial line is fully emulated. The problem with this emulation is
that it needs a lot of processing power, mainly because the emulator
has to emulate two CPUs instead of one.  The PETs do not use a
serial IEC bus to communicate with the floppy drive but instead use
the parallel IEEE488 bus.  This does *byte by byte* transfers, as
opposed to the *bit by bit* transfers of the C64 and VIC20, so making
it feasible to emulate the parallel line completely while emulating
the drive at DOS level only. The IEEE488 line interpreter maps the
drives 8-11 (as described above) to the IEEE488 disk units, and no
kernal traps are needed. The same emulation of the Commodore IEEE488
bus interface is available for the C64 and the VIC20. With IEEE488
drives you can have true 2031 emulation at unit #8, and still have
filesystem access at units #10 or #11, because monitoring the IEEE488
lines does not interfere with the true drive emulation.  The
IEEE488 disk drives 2040, 3040, 4040, 8050 and 8250 are Dual Drive
Floppy Disks.  This means that these drives handle two disks. To
accomplish the emulation, only two disks can be emulated, namely units
#8 and #10. The attached image, track display and LED display of unit
#9 and #11 are used for the second drive of the dual disk drives. On
unix the unit number display (8 or 9, 10 or 11) in the emulation
window changes to the drive number display (0 or 1).  The Commodore
2040, 3040, 4040, 1001, 8050 and 8250 disk drives are so-called
"old-style" disk drives. Their architecture includes not one, but two
processors of the 6502 type, namely a 6502 for the file handling and
communication with the PET (IP), and a 6504 (which is a 6502 with
reduced address space) for the drive handling (FDC). Both processors
communicate over a shared memory area. The IP writes commands to
read/write blocks to this area and the FDC executes them. To make the
emulation feasible, the FDC processor is not emulated cycle-exactly
as a 6504, but simply by checking the commands and executing them on
the host. This provides a fast FDC emulation, but disallows the
sending the FDC processor commands to execute code. Applications
where this is necessary are believed to be rather seldom. Only the
format command uses this feature, but this is checked for.  The
dual disk drive 2040 emulates one of the very first CBM disk drives.
This drive has DOS version 1. DOS1 uses an own disk type, that is
closely related to the 1541 disk image. Only on tracks 18-24 DOS1
disks have a sector more than 1541 disks. DOS1 disk images have the
extension .d67.  The dual disk drives 3040 and 4040 use the same
logical disk format as the VC1541 and the 2031. In fact, the 4040 was
the first disk with DOS version 2. The 3040 emulated here originally
was the same as 2040, only for the european 30xx PET series. As many
of the original DOS1 disk drives were upgraded (a simple ROM
upgrade!) to DOS2, I use the 3040 number for a DOS 2.0 disk drive,
and 4040 for a revised DOS 2 disk drive. It is, however, not yet
clear whether the disks here are write compatible to the 1541, as
rumors exist that the write gap between  sectors is different. But
read compatible they are. As VICE emulates the FDC processor in C and
not as 6504 emulation, this does not matter in VICE.  The drives
1001, 8050 and 8250 do actually have the very same DOS ROM. Only the
code in the FDC is different, which is taken care of by VICE. So for
all three of those disk drives, only `dos1001' is needed. The DOS
version used is 2.7. 


@EndNode

@Node "Supported file formats" "vice.guide/Supported file formats"
@Next "Common problems"
@Prev "Disk drive emulation"
@Toc "Preface"

Supported file formats
=======================

    VICE supports the most popular Commodore file formats: 
     

     `X64' (preferred) or `D64' disk image files; Used by the 1541,
     2031, 3040, 4040 drives. 

     `G64' GCR-encoded 1541 disk image files; 

     `D67' CBM2040 (DOS1) disk image format 

     `D71' VC1571 disk image format 

     `D81' VC1581 disk image format 

     `D80' CBM8050 disk image format 

     `D82' CBM8250/1001 disk image format 

     `D1M' FD2000/FD4000 DD disk image format 

     `D2M' FD2000/FD4000 HD disk image format 

     `D4M' FD4000 ED disk image format 

     `T64' tape image files (read-only); 

     `P00' program files;   An utility (`c1541', see @{"c1541" Link "c1541"}) is
provided to allow transfers and conversions between these formats.
 Notice that the use of the `X64' file format is depreciated now. 
You can convert an `X64' file back into a `D64' file with the UNIX
`dd' command: 

   dd bs=64 skip=1 if=IMAGE.X64 of=IMAGE.D64  example  See
@{"File formats" Link "File formats"}. for a technical description of the supported file
formats. 


@EndNode

@Node "Common problems" "vice.guide/Common problems"
@Prev "Supported file formats"
@Toc "Preface"

Common problems
================

    This section tries to describe the most common known problems
with VICE, and how to resolve them. 

   * Sound problems:: * Shared memory problems:: * Printer
problems:: * PET keyboard problems::  menu 


@EndNode

@Node "Sound problems" "vice.guide/Sound problems"
@Next "Shared memory problems"
@Prev "Common problems"
@Toc "Common problems"

Sound problems
---------------

    VICE should compile and run without major problems on many UNIX
systems, but there are some known issues related to the sound driver.
In fact, the sound code is the least portable part of the emulator
and has not yet been thoroughly tested on all the supported
platforms.  Linux, AIX and SGI systems should play sound without
any problems; if you are running Linux please use a 2.x kernel, as
VICE needs some features that were not implemented in older versions
of the Linux sound driver.  On the other hand, HP-UX and Solaris
machines are known to cause troubles.  If you think you can help
debugging the code for these systems, your help would be really
appreciated.  We are having troubles finding HP-UX and SUN consoles
to work at...  Some problems have been reported with the
proprietary version of the Open Sound System for Linux.  With a
Crystal sound card, sound output was significantly delayed and,
apparently, the allocated buffer size was completely wrong.  This is
not a VICE bug, but rather an OSS bug.  


@EndNode

@Node "Shared memory problems" "vice.guide/Shared memory problems"
@Next "Printer problems"
@Prev "Sound problems"
@Toc "Common problems"

Shared memory problems
-----------------------

    If you cannot start VICE because you get errors about shared
memory, try to run it with the `+mitshm' command-line option (see
@{"Video options" Link "Video options"}).  This will completely disable usage of the MITSHM
extensions, that are normally used to speed up the emulation window
updates.  Of course, this will also result in a big loss in speed.
 Reasons for this failure could be: 
     IPC support has been disabled at the system level; some system
     administrators disable this for security reasons.  If *you* are
     the system administrator, use a kernel that has IPC support
     compiled in and enabled.

     You are attempting to run the emulator across the network (i.e.,
     the emulator runs on one machine, and the output is displayed on
     another machine that works as an X terminal) and for some reason
     VICE does not recognize this fact.  In this case, you have found
     a bug, so please report it to us.  If you want to avoid
running the emulator with `+mitshm' every time, run it once with
`+mitshm' and then choose "Save settings" from the right-button
menu. 


@EndNode

@Node "Printer problems" "vice.guide/Printer problems"
@Next "PET keyboard problems"
@Prev "Shared memory problems"
@Toc "Common problems"

Printer problems
-----------------

    VICE supports the emulation of a printer either on the userport
or as IEC device 4. Unfortunately the Commodore IEC routines do not
send all commands to the IEC bus. For example an `OPEN 1,4' is not
seen on the IEC bus. Also a `CLOSE 1' after that is not seen. VICE
can see from printing that there was an `OPEN', but it cannot see
when the close was. Also a "finish print job" cannot be seen on the
userport device. To flush the printer buffer (write to `print.dump'
or to the printer) now a menu entry can be used. Disabling and
re-enabling the printer should work as well.  The printing
services have not been extensively tested but apart from the problem
mentioned above it should work fine now. 


@EndNode

@Node "PET keyboard problems" "vice.guide/PET keyboard problems"
@Prev "Printer problems"
@Toc "Common problems"

PET keyboard problems
----------------------

    If you find that the German keyboard mapping (plus German
charset) does not print uppercase umlauts, then you are right. The
umlauts replace the [,\ and ] characters in the charset. The keys
that make these characters do not have a different entry in the PET
editor ROM tables when shifted. Thus it is not possible to get the
uppercase umlauts in the editor. Nevertheless other programs are
reported to change the keyboard mapping table and thus allow the use
of the shifted (uppercase) umlauts.  Anyway, the VICE keyboard
mappings are far from being perfect and we are open to any
suggestions. 


@EndNode

@Node "Usage" "vice.guide/Usage"
@Next "System files"
@Prev "Preface"
@Toc "Top"

Invoking the emulators
***********************

    The names of the available emulators are: 
     

     `x64', the fast C64 emulator 

     `x64sc', the accurate C64 emulator 

     `x64dtv', the C64DTV emulator 

     `x128', the C128 emulator 

     `xvic', the VIC20 emulator 

     `xpet', the PET emulator 

     `xplus4', the PLUS4 emulator 

     `xcbm2', the CBM-II emulator   You can run each of them by
simply typing the name from a shell.  If you want to run them from
another application (e.g., a window manager or some other sort of
program launcher) you should always run them from a terminal window
such as `xterm' or `rxvt' since VICE provides a lot of debugging
information that is sent to the terminal and has built-in monitor
that also appears there.  For example, you could do 

   xterm -e x64  example  

   * Command-line initialization:: * Command-line autostart::
menu 


@EndNode

@Node "Command-line initialization" "vice.guide/Command-line initialization"
@Next "Command-line autostart"
@Prev "Usage"
@Toc "Usage"

Command-line options used during initialization
================================================

    There are several options you can specify on the command line.
Some of them are used to specify emulation settings and will be
described in detail later (see @{"Settings and resources" Link "Settings and resources"} for a complete
list).  The remaining options are used only to give usage information
or to initialize the emulator in some way: 
-help
-?
     List all the available command-line options and their meaning.

-default
     Set default resources (see @{"Settings and resources" Link "Settings and resources"}).  This will
     override all the settings specified before, but not the settings
     specified afterwards on the command line.

-config <filename>
     Specify config file

-logfile <name>
     Specify log file name

-verbose
     Enable verbose log output.

-keybuf <string>
     Put the specified string into the keyboard buffer.

-console
     Console mode (for music playback)

-chdir <directory>
     Change the working directory.

-autostart IMAGE
     Autostart `IMAGE' (see @{"Command-line autostart" Link "Command-line autostart"}).

-autoload <name>
     Attach and autoload tape/disk image <name>

-basicload
     On autostart, load to BASIC start (without ',1')

+basicload
     On autostart, load with ',1'

-autostartwithcolon
     On autostart, use the 'RUN' command with a colon, i.e., 'RUN:'

+autostartwithcolon
     On autostart, do not use the 'RUN' command with a colon; i.e.,
     'RUN'

-autostart-handle-tde
+autostart-handle-tde
     Handle/Do not handle True Drive Emulation on autostart

+autostart-warp
     Enable/Disable warp mode during autostart

-autostartprgmode
     Set autostart mode for PRG files

-autostartprgdiskimage
     Set disk image for autostart of PRG files 

-autostart-delay-random
+autostart-delay-random
     Enable/Disable random delay on autostart

-autostart-delay <value>
     Set initial autostart delay (0: use default) 

-1 NAME
     Attach `NAME' as a tape image file.

-8 NAME
-9 NAME
-10 NAME
-11 NAME
     Attach `NAME' as a disk image to device 8, 9, 10 or 11. 

-attach8ro
-attach9ro
-attach10ro
-attach11ro
     Attach disk image for drive #8-11 read only

-attach8rw
-attach9rw
-attach10rw
-attach11rw
     Attach disk image for drive #8-11 read write (if possible)  



@EndNode

@Node "Command-line autostart" "vice.guide/Command-line autostart"
@Prev "Command-line initialization"
@Toc "Usage"

Autostarting programs from the command-line
============================================

    It is possible to let the emulator "autostart" a disk or tape
image file, by simply specifying its name as the *last* argument on
the command line, for example 

   x64 lovelygame.x64.gz  example  will start the C64 emulator,
attaching `lovelygame.x64.gz' as a disk image and running the first
program on it.  You can also specify the name of the program on the
fisk image by appending a colon (`:') the name itself to the
argument; for example 

   x64 "lovelygame.x64.gz:run me"  example  will run the program
named `run me' on `lovelygame.x64.gz' instead of the first one. 
Using the command-line option `-autostart' is equivalent; so the same
result can be obtained with 

   x64 -autostart "lovelygame.x64.gz:run me"  example  If you
specify a raw CBM or P00 file, the emulator will setup the file
system based drive emulation so that it is enabled and accesses the
directory containing the file first.  This is a very convenient way to
start multi-file programs stored in file system directories and not
requiring "true" drive emulation.  See @{"Disk and tape images" Link "Disk and tape images"}. for
more information about images and autostart.  


@EndNode

@Node "System files" "vice.guide/System files"
@Next "Basics"
@Prev "Usage"
@Toc "Top"

System files
*************

    In order to work properly, the emulators need to load a few
system files: 
     

     the "system ROMs", raw binary files containing copies of the
     original ROMs of the machine you are emulating; 

     the "keyboard maps", text files describing the keyboard layout;
     

     the "palette files", text files describing the colors of the
     machine you are emulating. 

     the "romset files", text files describing the different ROMs to
     load.   The place where they will be searched for depends on
the value of the `Directory' resource, which is a colon
(`:')-separated search path list, like the UNIX `PATH' environment
variable.  The default value is 

   PREFIX/lib/vice/EMU:$HOME/.vice/EMU:BOOTPATH/EMU  example 
Where `PREFIX' is the installation prefix (usually `/usr/local'),
`EMU' is the name of the emulated machine (`C64', `C128', `PET',
`CBM-II' or `VIC20') and `BOOTPATH' is the directory where the
executable resides. The disk drive ROMs are looked for in a directory
with `EMU' set to `DRIVES'. `$HOME' is the user's home directory. 
For example, if you have the C64 emulator installed in 

   /usr/local/bin/x64  example  then the value will be 

   /usr/local/lib/vice/C64:$HOME/.vice/C64:/usr/local/bin/C64
example  And system files will be searched for under the following
directories, in the specified order: 
     `/usr/local/lib/VICE/C64'

     `$HOME/.vice/C64'

     `/usr/local/bin/C64'
         System files can still be installed in a different directory
if you specify a complete path instead of just a file name.  For
example, if you specify `./kernal' as the kernal image name, the
kernal image will be loaded from the current directory.  This can be
done by using command-line options or by modifying resource values
(see @{"Resource files" Link "Resource files"}). 

   * ROM files::                   Files containing dumps of the
original ROMs. * Keymap files::                Files describing the
keyboard layout. * Palette files::               Files defining the
machine's colors. * Romset files::                Files defining the
machine's ROM set.  menu 


@EndNode

@Node "ROM files" "vice.guide/ROM files"
@Next "Keymap files"
@Prev "System files"
@Toc "System files"

ROM files
==========

    Every emulator requires its own ROM set.  For the VIC20 and the
C64, the ROM set consists of the following files: 
     

     `kernal',  the Kernal ROM (8 KBytes) 

     `basic', the Basic ROM (8 KBytes) 

     `chargen', the character generator ROM (4 Kbytes)   The C128
needs the following files: 
     

     `kernal', the Kernal ROM (8 Kbytes) 

     `basic', the Basic + Editor ROM (32 Kbytes) 

     `chargen', the character generator ROM (4 Kbytes)   The
C128, VIC20 and C64 emulators also need the following DOS ROMs for
the hardware-level emulation of the 1541, 1571, 1581, 2000 and 4000
disk drives: 
     

     `dos1541', the 1541 drive ROM (16 Kbytes) 

     `dos1541II', the 1541-II drive ROM (16 Kbytes) 

     `dos1571', the 1571 drive ROM (32 Kbytes) 

     `dos1581', the 1581 drive ROM (32 Kbytes) 

     `dos2000', the 2000 drive ROM (32 Kbytes) 

     `dos4000', the 4000 drive ROM (32 Kbytes)   In addition to
those all emulators can handle a parallel IEEE488 interface (the C64
and C128 via `$df**' extension, the VIC20 via VIC1112 emulation) so
they also need the DOS ROM for the IEEE disk drives: 
     

     `dos2031', the 2031 drive ROM (16 Kbytes) (DOS 2.6, Commodore
     ROM images 901484-03 and 901484-05) 

     `dos2040', the 2040 drive ROM (8 Kbytes) (DOS 1, Commodore ROM
     images 901468-06, 901468-07) 

     `dos3040', the 3040 drive ROM (12 Kbytes) (DOS 2, Commodore ROM
     images 901468-11, 901468-12 and 901468-13) 

     `dos4040', the 4040 drive ROM (12 Kbytes) (DOS 2, Commodore ROM
     images 901468-14, 901468-15 and 901468-16) 

     `dos1001', the 1001/8050/8250 drive ROM (16 Kbytes) (DOS 2.7,
     Commodore ROM images 901887-01 and 901888-01)   Note that
there are other DOS images on the internet. The DOS 2.5 images might
be used with the 8050, but it cannot handle the double sided drives
of the 1001 and 8250 and it is not supported by VICE.  The PET
emulator uses an expanded setup, because there are three major
versions of the Basic and the Kernal, and many versions of the Editor
ROM. In addition there are cartridge ROM sockets.  The Kernal files
contain the memory from range $F000-$FFFF, the Basic ROMs either the
range $C000-$DFFF or $B000-$DFFF. To handle the different screen
sizes and keyboards, different so-called "editor-ROMs" for the memory
range $E000-$E800 are provided. The PET ROMs have the following
names: 
     

     `kernal1', the PET2001 Kernal ROM (4 KBytes) (Commodore ROM
     images 901447-06 and 901447-07)

     `kernal2', the PET3032 Kernal ROM (4 KBytes) (Commodore ROM
     image 901465-03)

     `kernal4', the PET4032/8032 Kernal ROM (4 KBytes) (Commodore ROM
     image 901465-22) 

     `basic1', the PET2001 Basic 1 ROM (8 KBytes) (Commodore ROM
     images 901447-09, 901447-02, 901447-03, 901447-04.bin. The -09
     ROM is the revised -01 ROM)

     `basic2', the PET3032 Basic 2 ROM (8 KBytes) (Commodore ROM
     images 901465-01 and 901465-01)

     `basic4', the PET4032/8032 Basic 4 ROM (12 KBytes) (Commodore
     ROM images 901465-23, 901465-20 and 901465-21. The -23 ROM is a
     revised -19 ROM) 

     `edit1g', the PET2001 editor for graphics keyboards (2 KBytes)
     (Commodore ROM image 901447-05)

     `edit2b', the PET3032 editor for business keyboards (2 KBytes)
     (Commodore ROM image 901474-01)

     `edit2g', the PET3032 editor for graphics keyboards (2 KBytes)
     (Commodore ROM image 901447-24)

     `edit4g40', the PET4032 editor for graphics keyboards (2 KBytes)
     (Commodore ROM image 901498-01)

     `edit4b40', the PET4032 editor for business keyboards (2 KBytes)
     (Commodore ROM image 901474-02)

     `edit4b80', the PET8032 editor for business keyboards (2 KBytes)
     (Commodore ROM image 901474-04-?) 

     `chargen', the character generator ROM (2k).  It has two sets
     with 128 chars each.  The second (inverted) half of each set is
     computed from the first half by inverting it.  This is a PET
     hardware feature. (Commodore ROM image 901447-10)

     `chargen.de', the character generator ROM (2k). This version is a
     patched German charset, with the characters [, \ and ] replaced by
     umlauts. It has been provided by U. Guettich and he reports that
     it is supported by some programs. 

     `characters.901640-01.bin', the SuperPET character generator ROM
     (4k). The first half is the same as `chargen', the second half
     contains, instead of an upper and lower case set, an ASCII
     character set and an APL character set. For these sets, the
     screen code is equal to the ASCII/APL code.

     `waterloo-[abcdf]000.901898-0[1-5].bin',
     `waterloo-e000.901897-01.bin'. The Waterloo system ROMs. 
The PETs also have sockets for extension ROMs for the addresses
$9000-$9FFF, $A000-$AFFF and $B000-$BFFF (the last one for PET2001 and
PET3032 only).  You can specify ROM image files for those extensions
command line options `-petrom9', `-petromA' and `-petromB' resp. 
An alternative would be to specify a long kernal ROM with the
`-kernal' option that includes the extension ROM areas.  Also, you
can specify replacements for the basic ROM at $B000-$DFFF with the
`-petromBasic' option and for the editor ROM at $E000-$E7FF with the
`-petromEditor' option.  The CBM-II emulator again uses another
setup.  For those models the kernal used is the same for all.
However, for different amounts of memory exist different versions of
the BASIC ROMs.  The 128k RAM version (C610, C710, B128) uses one
bank of 64k for the BASIC text and another one for all the variables.
The 256k RAM version uses one bank for text, one for variables, one
for arrays and one for strings.  Also the character generator ROMs
have a format different from the above.  The other character ROMs
have 8 bytes of pixel data per character.  Those ROMs have 16 bytes
per character instead.  The C6x0 only uses the first 8 of it, but the
C7x0 uses 14 lines per character and needs those increased ROMs.
Both ROMs hold, like the PET, two character sets with 128 characters
each.  Again the second half of the full (256 char) character set is
computed by inverting. 
     

     `kernal', the KERNAL (8k) for the business machines (6xx/7xx) 

     `kernal.500', the KERNAL (8k) for the personal machine (510)
     (901234-02) 

     `basic.128', the CBM-II 128k BASIC (16k) 

     `basic.256', CBM-II 256k BASIC (16k) 

     `basic.500', C510 BASIC (16k) (901236-02 + 901235-02) 

     `chargen.500', character generator ROM for the C5x0 (4k)
     (901225-01) 

     `chargen.600', character generator ROM for the C6x0 (4k) 

     `chargen.700', character generator ROM for the C7x0 (4k)  


@EndNode

@Node "Keymap files" "vice.guide/Keymap files"
@Next "Palette files"
@Prev "ROM files"
@Toc "System files"

Keymap files
=============

    "Keymap files" are used to define the keyboard layout, defining
which key (or combination of keys) must be mapped to each keysym. 
In other words, the keyboard emulation works like this: whenever the
user presses or releases a key while the emulation window has the
input focus, the emulator receives an X-Window event with a value
that identifies that key.  That value is called a "keysym" and is
unique to that key.  The emulator then looks up that keysym in an
internal table that tells it which key(s) to press or release on the
emulated keyboard.  This table is described by the keymap file,
which is made up of lines like the following: 

   KEYSYM ROW COLUMN SHIFTFLAG  example  Where: 
     

     `KEYSYM' is a string identifying the keysym: you can use the
     `xev' utility (shipped with the X Window system) to see what
     keysym is bound to any key; 

     `ROW' and `COLUMN' identify the key on the emulated keyboard; 

     `SHIFTFLAG' can have one of the following values: 
          

          `0': the key is never shifted; 

          `1': the key is shifted; 

          `2': the key is the left shift; 

          `4': the key is the right shift; 

          `8': the key can be (optionally) shifted by the user.  
 The `SHIFTFLAG' is useful if you want certain keys to be
"artificially" shifted by the emulator, and not by the user.  For
example, F2 is shifted on the C64 keyboard, but you might want it to
be mapped to the unshifted F2 key on the PC keyboard.  To do so, you
just have to use a line like the following: 

   F2 0 4 1  example  where `0' and `4' identify the key (row 0,
column 4 on the keyboard matrix), and `1' specifies that every time
the user presses F2 the shift key on the C64 keyboard must be
pressed.  There are also some special commands you can put into the
keyboard file; they are recognized because they start with an
exclamation mark: 
     

     `!CLEAR' clears the currently loaded keyboard map; it is
     necessary to put this at the beginning of the file if you want
     the keymap file to override all of the current internal
     settings; 

     `!LSHIFT', `!RSHIFT', followed by a row and a column value,
     specify where the left and right shift keys are located on the
     emulated keyboard; for example, C64 default keymaps will specify
     

     !LSHIFT 1 7 !RSHIFT 6 4   itemize  Any line starting
with the `#' sign, instead, is completely ignored.  This is useful
for adding comments within the keymap file.  VICE keymap files have
the `.vkm' default extension, and every emulator comes with a default
positional mapping and a default symbolic mapping.  


@EndNode

@Node "Palette files" "vice.guide/Palette files"
@Next "Romset files"
@Prev "Keymap files"
@Toc "System files"

Palette files
==============

    "Palette files" are used to specify the colors used in the
emulators.  They are made up of lines like the following: 

   RED GREEN BLUE DITHER  example  where `RED', `GREEN' and
`BLUE' are hexadecimal values ranging from 0 to FF and specifying the
amount of red, green and blue you want for each color and `DITHER' is
a 4-bit hexadecimal number specifying the pattern you want when
rendering on a B/W display.  You have to include as many lines as
the number of colors the emulated machine has, and the order of the
lines must respect the one used in the machine (so the N'th line must
contain the specifications for color N - 1 in the emulated machine).
 Lines starting with the `#' sign are completely ignored.  This is
useful for adding comments (such as color names) within the palette
file.  For example, the default PET palette file (which has only
two colors, 0 for background and 1 for foreground), looks like the
following: 

   # # VICE Palette file # # Syntax: # Red Green Blue Dither
#  # Background 00 00 00 0  # Foreground 00 FF 00 F
example 


@EndNode

@Node "Romset files" "vice.guide/Romset files"
@Prev "Palette files"
@Toc "System files"

Romset files
=============

    The Romset files are not used by default on all emulators. You
might have recognized that the names of the ROM images are saved in
resources. Loading a Romset file now just means a `shortcut' to
changing all the resources with ROM image names and reloading the
ROMs.  The PET and CBM-II emulators use this feature to change
between the different ROM versions available for those machines. E.g.
the Romset file for the PET 2001 is 

   KernalName="pet2001" EditorName= ChargenName="chargen"
RomModule9Name= RomModuleAName= RomModuleBName=  example  As
you can see, the file even uses the same syntax as the resource file,
it is just a bit stripped down. 


@EndNode

@Node "Basics" "vice.guide/Basics"
@Next "Settings and resources"
@Prev "System files"
@Toc "Top"

Basic operation
****************

    This section describes the basic things you can do once the
emulator has been fired up.  

   * Emulation window::            The window the emulator runs in. *
Menus::                       Using emulator menus. * Help::
             Getting help if you are stuck. * File Selector::
      Selecting files interactively. * Disk and tape images::
Using virtual disks and tapes. * Reset::
Resetting the virtual machines.  menu 


@EndNode

@Node "Emulation window" "vice.guide/Emulation window"
@Next "Menus"
@Prev "Basics"
@Toc "Basics"

The emulation window
=====================

    When the emulator is run, the screen of the emulated machine is
displayed in a standard X Window which we will call the "emulation
window".  This window will be updated in real time, displaying the
same contents that a real monitor or TV set would.  Below the
emulation window there is an area which is used to display
information about the state of the emulator; we will call this area
the "status bar".  On the extreme left of the status bar, there
is a "performance meter".  This displays the current relative speed
of the emulator (as a percentage) and the update frequency (in frames
per second).  All the machines emulated are PAL, so the update
frequency will be 50 frames per second if your system is fast enough
to allow emulation at the speed of the real machine.  On the
extreme right of the status bar, there is a "drive status indicator".
This is only visible if the hardware-level ("True") 1541 emulation
is turned on.  In that case, the drive status indicator will contain
a rectangle emulating the drive LED and will display the current
track position of the drive's read/write head. 


@EndNode

@Node "Menus" "vice.guide/Menus"
@Next "Help"
@Prev "Emulation window"
@Toc "Basics"

Using the menus
================

    It is possible to execute some commands and change emulation
parameters while the emulator is running: when the pointer is over
the emulation window, two menus are available by pressing either the
left or right mouse buttons.  The left mouse button will open the
"command menu" from which several emulation-related commands can be
executed; the right mouse button will open the "settings menu" from
which emulation parameters can be changed.  The basic difference
between the command and the settings menu is that, while commands
have only effect on the current session, settings can be saved and
later used with the "Save settings" and "Load settings" right-button
menu items, respectively. "Restore default settings" restores the
factory defaults. See @{"Settings and resources" Link "Settings and resources"}. for more information
about how settings work in VICE.  Sometimes commands can be
reached via "shortcuts" or "hotkeys", i.e., it is possible to execute
them by pressing a sequence of keys instead of going through the menu
with the mouse.  Where shortcuts exist, they are displayed in
parentheses at the right edge of the menu item.  In VICE, all
shortcuts must begin with the Meta or Alt key.  So, for example, to
attach a disk image to drive #8 (the corresponding menu item displays
"M-8"), you have to press the Meta (or Alt) and then 8.  Note
that no other key presses are passed on to the emulated machine while
either Meta or Alt are held down.  


@EndNode

@Node "Help" "vice.guide/Help"
@Next "File Selector"
@Prev "Menus"
@Toc "Basics"

Getting help
=============

    At any time, if you get stuck or do not remember how to perform
a certain action, you can use the "Browse manuals" command (left
button menu).  This will popup a browser and open the HTML version of
this documentation.  Notice that this requires VICE to be properly
(and fully) installed with a `make install'.  The browser can be
specified via the `HTMLBrowserCommand' string resource (see
@{"Settings and resources" Link "Settings and resources"} for information about resources).  Every `%s'
in the string will be replaced with a URL to the VICE HTML pages. 



@EndNode

@Node "File Selector" "vice.guide/File Selector"
@Next "Disk and tape images"
@Prev "Help"
@Toc "Basics"

Using the file selector
========================

    In those situations where it is necessary to specify a file name,
all of the VICE emulators will pop up a file selector window
allowing you to select or specify a file interactively.  To the
left of the file selector, there is a list of ancestor directories:
by clicking on them, you can ascend the directory tree.  To the
right, there is a list of the files in the current directory; files
can be selected by clicking on them.  If you click on a directory,
that directory becomes the current one; if you click on an ordinary
file, it becomes the active selection.  At the top, there is a
"directory box", with the complete path of the current directory, and
a "file name box", with the name of the currently selected file.  At
the bottom there are two buttons: "OK" confirms the selected file and
"Cancel" abandons the file selector without cancelling the
operation.  It is also possible to specify what files you want to
show in the file selector by writing an appropriate shell-like
pattern in the directory box; e.g., `~/*.[dx]64' will only show files
in the home directory whose name ends with either `.d64' or with
`.x64'.  


@EndNode

@Node "Disk and tape images" "vice.guide/Disk and tape images"
@Next "Reset"
@Prev "File Selector"
@Toc "Basics"

Using disk and tape images
===========================

    The emulator is able to emulate disk drives and (read-only) tape
recorders if provided with suitable "disk images" or "tape images".
An "image" is a raw dump of the contents of the media, and must be
"attached" before the emulator can use it.  "Attaching" a disk or
tape image is like "virtually" inserting a diskette or a cassette
into the disk drive or the tape recorder: once an image is attached,
the emulator is able to use it as a storage media.  There are five
commands (in the left button menu) that deal with disk and tape
images: 
     

     Attach Disk Image

     Detach Disk Image

     Attach Tape Image

     Detach Tape Image

     Smart-attach a file   The first four commands are used to
insert and remove the virtual disks and cassettes from the respective
units.  On the other hand, the last commands tries to guess the type
of the image you are attaching from its name and size, and attaches
it to the most reasonable device.  Supported formats are `D64' and
`X64' for disk images (devices 8, 9 and 10) and `T64' for tape
images.  Notice that `T64' support is *read-only*, and that the
cassette is automatically rewound when you reach its end. 
Another important feature is that raw Commodore BASIC binary files and
.P00 files can be attached as tapes.  As you can autostart a tape
image when it is attached (see @{"Autostart" Link "Autostart"}), this allows you to
autostart these particular files as well.  You can attach a disk
for which you do not have write permissions: when this happens, the
1541 emulator will emulate a write-protected disk.  This is also
useful if you want to prevent certain disk images from being written
to; in the latter case, just remove the write permission for that
file, e.g., by doing a `chmod a-w'. 

   * Previewing contents::         Looking into the image before
attaching it. * Autostart::                   Starting a program
automagically. * Compressed files::            Dealing with
compressed files. * Zipcode and Lynx::            Using Zipcoded
([1-4]!*) and Lynx files.  menu 


@EndNode

@Node "Previewing contents" "vice.guide/Previewing contents"
@Next "Autostart"
@Prev "Disk and tape images"
@Toc "Disk and tape images"

Previewing the image contents
------------------------------

    It is possible to examine the directory of a disk or tape image
before attaching it.  Just press the "Contents" button in the file
selector window and a new window will pop up with the contents of the
selected image.  Notice that this function automatically
translates the directory from PETSCII to ASCII; but, due to
differences in the two encodings, it is not always possible to
translate all the characters, so you might get funny results when
"weird" characters such as the semi-graphical ones are being used.
 


@EndNode

@Node "Autostart" "vice.guide/Autostart"
@Next "Compressed files"
@Prev "Previewing contents"
@Toc "Disk and tape images"

"Autostarting" an image
------------------------

    If you want to reset the machine and run the first program on a
certain image without typing any commands at the Commodore BASIC
prompt, you can use the "Autostart" button in the file selector
window after selecting a proper disk or tape image file.  Notice
that, if true drive emulation is turned on, it will be turned off
before running the program and then turned on again after it has been
loaded.  This way, you get the maximum possible speed while loading
the file, but you do not lose compatibility once the program itself
is running.  This method is not completely safe, because some
autostarting methods might cause the true drive emulation not to be
turned on again.  In such cases, the best thing to do is to disable
kernal traps (which will cause true drive emulation to be always kept
turned on), or to manually load the program with true drive emulation
turned on.  


@EndNode

@Node "Compressed files" "vice.guide/Compressed files"
@Next "Zipcode and Lynx"
@Prev "Autostart"
@Toc "Disk and tape images"

Using compressed files
-----------------------

    It is also possible to attach disk or tape images that have been
compressed through various algorithms; compression formats are
identified from the file extension.  The following formats are
supported (the expected file name extension is in parenthesis): 
     GNU Zip (`.gz' or `.z');

     BZip version 2 (`.bz2');

     PkZip (`.zip');

     GNU Zipped TAR archives (`.tar.gz', `.tgz');

     Zoo (`.zoo').  PkZip, `tar.gz', `lha' and `zoo' support is
*read-only* and always uses the *first* `T64' or `D64' file in the
archive.  So archives containing multiple files will always be
handled as if they contain only a single file.  Windows and MSDOS
don't contain the needful programs to handle compressed archives. Get
gzip and unzip for Windows at
ftp://ftp.freesoftware.com/pub/infozip/WIN32 and for MSDOS at
ftp://ftp.freesoftware.com/pub/infozip/MSDOS. Don't use pkunzip for
MSDOS, it doesn't work. The programs to use BZip2 archives may be
found at http://sourceware.cygnus.com/bzip2. Just put the programs
(unzip.exe, gzip.exe, bzip2.exe) into a directory of your search path
(e.g. C:\DOS or C:\WINDOWS\COMMAND; have a look at the PATH
variable). 


@EndNode

@Node "Zipcode and Lynx" "vice.guide/Zipcode and Lynx"
@Prev "Compressed files"
@Toc "Disk and tape images"

Using Zipcode and Lynx images
------------------------------

    Since version 0.15, the VICE emulators have been able to attach
disks packed with Zipcode or Lynx directly, removing the need to
manually convert them into `D64' or `X64' files with `c1541'. This
is achieved by automatically invoking `c1541', letting it decode the
file into a temporary image and attaching the resulting temporary
image read-only.  For this to work, the directory containing `c1541'
must be in your `PATH'.  This uses the `-unlynx' and `-zcreate'
options of `c1541' (see @{"c1541 commands and options" Link "c1541 commands and options"}); these commands
are not very reliable yet, and could fail with certain kinds of Lynx
and Zipcode images (for example, they cannot deal with `DEL' files
properly). So please use them with caution.  Lynx files usually
come as `.lnx' files which are unpacked into single disk images.  On
the other hand, Zipcode files do not have a particular extension
(although `.z64' is sometimes used), and represent a disk by means of
component files, named as follows: 
     `1!NAME'

     `2!NAME'

     `3!NAME'

     `4!NAME'  If you attach as a disk image (or smart-attach) any
one of these files, the emulator will simply pick up the other three
(by examining the name) and then build a disk image using all four.
 


@EndNode

@Node "Reset" "vice.guide/Reset"
@Prev "Disk and tape images"
@Toc "Basics"

Resetting the machine
======================

    You can reset the emulated machine at any time by using the
"Reset" command from the command menu.  There are two types of
reset: 
     "soft reset", which simply resets the CPU and all the other
     chips;

     "hard reset", which also clears up the contents of RAM.  A
"soft reset" is the same as a hardware reset achieved by pulling the
RESET line down; a "hard reset" is more like a power on/power off
sequence in that it makes sure the whole RAM is cleared.  It is
possible that a soft reset may not be enough to take the machine to
the OS initialization sequence: in such cases, you will have to do a
hard reset instead.  This is especially the case for the CBM-II
emulators.  Those machines examine a memory location and if they find
a certain "magic" value they only do what you know from the C64 as
`Run/Stop-Restore'. Therefore, to really reset a CBM-II use hard
reset. 


@EndNode

@Node "Settings and resources" "vice.guide/Settings and resources"
@Next "Machine-specific features"
@Prev "Basics"
@Toc "Top"

Settings and resources
***********************

    In the VICE emulators, all the settings are stored in entities
known as called "resources".  Each resource has a name and a value
which may be either an integer or a string.  Integer values are often
used as boolean values with the usual convention of using zero for
"false" and any other value for "true".  Resource values can be
changed via the right-button menu (the "settings" menu), via
command-line options or via the "resource file".  The "resource
file" is a human-readable file containing resource values: it is
called `vicerc' and is stored in the directory `.vice/' in the user's
home directory.  It is possible to dump the current values of the
resources into that file or load the values stored into that file as
the current values, at any time.  This is achieved with the "Save
settings" and "Load settings" right menu items.  A third menu item,
"Restore Default Settings", can be used to reset all the values to
the factory defaults.  A special resource, `SaveResourcesOnExit',
if set to a non zero value, causes the emulator to ask you if you
want to save the current (changed) settings before exiting, and can
be toggled with the "Save settings on exit" command from the
right-button menu.  Notice that not all the resources can be
changed from the menus; some of them can only be changed by manually
modifying the resource file or by using command-line options. 

   * Resource files::              Format of resource files. *
Resources and command-line::  Specifying settings from the
                    command-line  * Performance settings::
Settings that affect speed of execution. * Video settings::
  Settings dealing with the video output. * Keyboard settings::
    Settings relative to the keyboard emulation. * Sound settings::
           Settings that control audio playback * Drive settings::
          Settings that control disk-drive emulation. * Peripheral
settings::         Settings for emulated external devices. * RS232
settings::              Settings for the RS232 emulation. * Monitor
settings::            Settings for the built-in monitor. * Misc
settings::               Other settings.  menu 


@EndNode

@Node "Resource files" "vice.guide/Resource files"
@Next "Resources and command-line"
@Prev "Settings and resources"
@Toc "Settings and resources"

Format of resource files
=========================

    A resource file is made up of several sections; sections have
the purpose of separating the resources of a certain emulator from
the ones of the other emulators.  A section starts with the name of
an emulator in brackets (e.g., `[C64]') and ends when another
section starts or when the file ends.  Every line in a section
has the following format: 

   RESOURCE=VALUE  example  where `RESOURCE' is the name of a
resource and `VALUE' is its assigned value.  Resource names are
case-sensitive and resource values are either strings or integers.
Strings must start and end with a double quote character (`"'), while
integers must be given in decimal notation.  Here is an example
of a stripped-down `.vice/vicerc' file: 

   [VIC20] HTMLBrowserCommand="netscape %s" SaveResourcesOnExit=0
FileSystemDevice8=1 FSDevice8ConvertP00=1
FSDevice8Dir="/home/ettore/cbm/stuff/vic20p00" FSDevice8SaveP00=1
FSDevice8HideCBMFiles=1 [C64] HTMLBrowserCommand="netscape %s"
SaveResourcesOnExit=1 FileSystemDevice8=1 FSDevice8ConvertP00=1
FSDevice8Dir="/home/ettore/cbm/stuff/c64p00" FSDevice8SaveP00=1
FSDevice8HideCBMFiles=1  example  Notice that, when resource
values are saved with "Save settings", the emulator only modifies its
own section, leaving the others unchanged. 


@EndNode

@Node "Resources and command-line" "vice.guide/Resources and command-line"
@Next "Performance settings"
@Prev "Resource files"
@Toc "Settings and resources"

Using command-line options to change resources
===============================================

    Resources can also be changed via command-line options. 
Command-line options always override the defaults from `.vice/vicerc',
and their assignments last for the whole session.  So, if you specify
a certain command-line option that changes a certain resource from
its default value and then use "Save Settings", the value specified
with the command-line option will be saved back to the resource
file.  Command-line options can begin with with a minus sign (`-')
or with a plus sign (`+').  Options beginning with a minus sign may
require an additional parameter, while the ones beginning with the
plus sign never require one.  Moreover, options beginning with a
plus sign always have a counterpart with the same name, but with a
minus sign; in that case, the option beginning with a minus sign is
used to *enable* a certain feature, while the one beginning with a
plus sign is used to *disable* the same feature (this is an X11
convention).  For example, `-mitshm' enables support of MITSHM, while
`+mitshm' disables it. 

Autostart settings
===================

   

Autostart resources
--------------------

   
     

AutostartPrgDiskImage
     String specifying the filename of the disk image used when
     autostarting a prg file and "copy to D64" is enabled.

AutostartBasicLoad
     Boolean, if true load to basic start using ,8 when autostarting.

AutostartRunWithColon
     Boolean, if true put a colon after the load command when
     autostarting.

AutostartHandleTrueDriveEmulation
     Boolean, if true handle (enable/disable) True Drive Emulation on
     autostart.

AutostartWarp
     Boolean, if true temporarily enable warp mode when autostarting

AutostartPrgMode
     Integer specifying the autostart mode for prg files. (0: virtual
     filesystem, 1: inject to RAM, 2: copy to D64)

AutostartDelayRandom
     Boolean, enables a short random delay on autostart.

AutostartDelay
     Integer specifying the maximum delay in frames.  


@EndNode

@Node "Performance settings" "vice.guide/Performance settings"
@Next "Video settings"
@Prev "Resources and command-line"
@Toc "Settings and resources"

Performance settings
=====================

    It is possible to control the emulation speed by using the
"Maximum speed" menu item in the right-button menu.  The default
setting is `100', which causes the emulation to never run faster than
the real machine.  A higher value allows the emulator to run faster,
a lower one may force it to run slower.  The setting "No limit" means
to run as fast as possible, without limiting speed.  It is also
possible to control the emulator's rate of frame update using the
"Refresh rate" setting; the value ranges from "1/1" (update 1/1 of
the frames of the real machine, that is 50 frames per second) to
"1/10" (update 1 every 10 frames) and can be changed via the "Refresh
Rate" submenu.  The "Auto" setting means to dynamically adapt the
refresh rate to the current speed of the host machine, making sure the
maximum speed specified by the via "Maxium speed" is always reached if
possible.  In any case, the refresh rate will never be worse than 1/10
if this option is specified.  Note that you cannot simultaneously
specify "Auto" as the refresh rate and "No limit" as the maximum
speed..  Moreover, a special "warp speed" mode is provided and can
be toggled with the "Enable Warp Mode" menu item.  If this mode is
enabled, it will cause the emulator to disable any speed limit, turn
sound emulation off and use a 1/10 refresh rate, so that it will run
at the maximum possible speed. 

   * Performance resources:: * Performance options::  menu 


@EndNode

@Node "Performance resources" "vice.guide/Performance resources"
@Next "Performance options"
@Prev "Performance settings"
@Toc "Performance settings"

Performance resources
----------------------

   
     

Speed
     Integer specifying the maximum relative speed, as a percentage.
     `0' stands for "no limit". 

RefreshRate
     Integer specifying the refresh rate; a value of `n' specifies a
     refresh rate of 1/`n'.  A value of `0' enables automatic frame
     skipping. 

WarpMode
     Booolean specifying whether "warp mode" is turned on or not. 
 


@EndNode

@Node "Performance options" "vice.guide/Performance options"
@Prev "Performance resources"
@Toc "Performance settings"

Performance command-line options
---------------------------------

   
     

-speed VALUE
     Specifies the maximum speed as a percentage.  `0' stands for "no
     limit".  (Same as setting the `Speed' resource.) 

-refresh VALUE
     Specifies refresh rate; a value of `n' specifies a refresh rate
     of 1/`n'.  A value of `0' enables automatic frame skipping.
     (Same as setting the `RefreshRate' resource.) 

-warp
+warp
     Enables/disables warp mode (`WarpMode=1', `WarpMode=0').   


@EndNode

@Node "Video settings" "vice.guide/Video settings"
@Next "Keyboard settings"
@Prev "Performance settings"
@Toc "Settings and resources"

Video settings
===============

    The following right-button menu items control the video output.
On emulators that include two video chips (like `x128') all options
but XSync exist twice, once for each chip. XSync is shared between
the video chips. 
     

     "Video Cache" enables a video cache that can speed up the
     emulation when little graphics activity is going on; it is
     especially useful when you run the emulator on a networked X
     terminal as it can reduce the network bandwidth required.
     However, this setting can actually make the emulator slower when
     there is little graphics activity and the amount of work needed
     to maintain the cache is greater than the amount of work that
     would be wasted by not using it (if any). 

     "Double Size" toggles "double-size mode", which makes the
     emulation window twice as big.  When emulating a 80-column PET,
     only the height is doubled, so that the aspect ratio is closer
     to that of the real thing. 

     "Double Scan" toggles "double-scan mode", which causes the
     emulator to draw only odd lines when running in double-size mode
     (this saves some CPU time and also makes the emulation window
     look more like an old monitor). 

     `Use XSync()" causes the emulator to call the X11 function
     `XSync()' before updating the emulation window: this might be
     necessary on low-end systems to prevent it from consuming so many
     system resources that it becomes impossible for the user to
     interact with it.   

   * Video resources:: * Video options::  menu 


@EndNode

@Node "Video resources" "vice.guide/Video resources"
@Next "Video options"
@Prev "Video settings"
@Toc "Video settings"

Video resources
----------------

    The following resources affect the screen emulation. The prefix
of some of the resources and commandline options denote the video
chip the values apply to. 
     

UseXSync
     Boolean specifying whether `XSync()' is called after updating the
     emulation window. 

MITSHM
     Integer specifying whether VICE should try to use the shared
     memory extensions (MITSHM) when starting up.  The shared memory
     extensions make things a lot faster but might not be available
     on your system.  You will not be able to use these extensions if
     you are sitting at an X terminal while running the emulator on a
     remote machine across a network.  Valid values are: 0 = do not
     use MITSHM, 1 = do use MITSHM, -1 = try to autodetect
     availability on startup (default).  The last is a simple test if
     the emulator runs across a network and if so disables MITSHM (If
     you have problems with this test please report it). 

PrivateColormap
     Boolean specifying whether VICE should install a private colormap
     at startup.  This makes sense for 8-bit displays that could run
     out of colors if other color-hungry applications are running at
     the same time. 

DisplayDepth
     Integer specifying the depth of the host display.  The value `0'
     (the default) causes the emulator to autodetect it. 

UseFullscreen
     Boolean specifying whether fullscreen mode is currently in use.

HwScalePossible
     Boolean that indicates whether hardware scaling is possible or
     not.

openGL_sync
     Boolean, if true enable Open-GL frame sync.

openGL_no_sync
     Boolean, if true Open-GL sync is not available.

KeepAspectRatio
     Boolean specifying whether the aspect ratio of the output window
     should be preserved. (0=free scaling, 1=scale with fixed aspect
     ratio)

TrueAspectRatio
     Boolean specifying whether to use the true (non square pixels)
     aspect ratio. 

Window0Width
Window0Height
Window0Xpos
Window0Ypos
     Integers specifying the position and size of the (first) emulator
     window.

Window1Width
Window1Height
Window1Xpos
Window1Ypos
     Integers specifying the position and size of the (second) emulator
     window.   


@EndNode

@Node "Video options" "vice.guide/Video options"
@Prev "Video resources"
@Toc "Video settings"

Video command-line options
---------------------------

   
     

-xsync
+xsync
     Enable/disable usage of `XSync()' when updating the emulation
     window (`UseXSync=1', `UseXSync=0'). 

-mitshm
+mitshm
     Enable/disable usage of the MITSHM extensions (`MITSHM=1',
     `MITSHM=0'). 

-install
+install
     Enable/disable installation of a private colormap
     (`PrivateColormap=1', `PrivateColormap=0'). 

-displaydepth DEPTH
     Specify the display depth (`DisplayDepth'). 

-fullscreen
+fullscreen
     Enable/disable fullscreen mode  


@EndNode

@Node "Keyboard settings" "vice.guide/Keyboard settings"
@Next "Sound settings"
@Prev "Video settings"
@Toc "Settings and resources"

Keyboard settings
==================

    It is possible to specify whether the "positional" or "symbolic"
keyboard mapping should be used with the "Keyboard mapping type"
submenu (see @{"Keyboard emulation" Link "Keyboard emulation"} for an explanation of positional and
symbolic mappings).  The keyboard settings submenu also allows you
to: 
     Load custom-made positional and symbolic keymap files ("Set
     symbolic keymap file" and "Set positional keymap file").

     Dump the current keymap to a user-defined keymap file ("Dump to
     keymap file").  

   * Keyboard resources:: * Keyboard options::  menu 


@EndNode

@Node "Keyboard resources" "vice.guide/Keyboard resources"
@Next "Keyboard options"
@Prev "Keyboard settings"
@Toc "Keyboard settings"

Keyboard resources
-------------------

   
     

KeymapIndex
     Integer identifying which keymap is being used; `0' indicates
     symbolic mapping, `1' positional mapping.  For the PET the even
     values represent symbolic mapping, odd positional.  Then add `0'
     for UK business keyboard or `2' for graphics keyboard. 

KeymapSymFile
     String specifying the name of the keymap file for the symbolic
     mapping (see @{"Keyboard emulation" Link "Keyboard emulation"}, all but PET and CBM-II).

KeymapSymDeFile
     String specifying the name of the keymap file for the symbolic
     mapping (de) 

KeymapPosFile
     String specifying the name of the keymap file for the positional
     mapping (see @{"Keyboard emulation" Link "Keyboard emulation"}, all but PET and CBM-II). 

KeymapBusinessUKSymFile
KeymapBusinessUKPosFile
     String specifying the name of the keymap file for the symbolic
     and positional mapping for the UK business keyboard (see
     @{"Keyboard emulation" Link "Keyboard emulation"}, PET and CBM-II). 

KeymapGraphicsSymFile
KeymapGraphicsPosFile
     String specifying the name of the keymap file for the symbolic
     and positional mapping for the graphics keyboard (see
     @{"Keyboard emulation" Link "Keyboard emulation"}, PET only). 

KeymapBusinessDESymFile
KeymapBusinessDEPosFile
     String specifying the name of the keymap file for the symbolic
     and positional mapping for the German business keyboard. (see
     @{"Keyboard emulation" Link "Keyboard emulation"}, PET only).   


@EndNode

@Node "Keyboard options" "vice.guide/Keyboard options"
@Prev "Keyboard resources"
@Toc "Keyboard settings"

Keyboard command-line options
------------------------------

   
     

-keymap N
     Specifies which keymap is being used; `0' indicates symbolic
     mapping, `1' positional mapping (as for the `KeymapIndex'
     resource). 

-symkeymap NAME
     Specify `NAME' as the symbolic keymap file (`KeymapSymFile'). 

-poskeymap NAME
     Specify `NAME' as the positional keymap file (`KeymapPosFile').
     

-symdekeymap NAME
     Specify `NAME' as the symbolic keymap file (`KeymapSymDeFile').
     

-buksymkeymap NAME
-bukposkeymap NAME
     Specify `NAME' as the symbolic/positional keymap file for the UK
     business keyboard (`KeymapBusinessUKSymFile',
     `KeymapBusinessUKPosFile', PET and CBM-II). 

-grsymkeymap NAME
-grposkeymap NAME
     Specify `NAME' as the symbolic/positional keymap file for the
     graphics keyboard (`KeymapGraphicsSymFile',
     `KeymapGraphicsPosFile', PET only). 

-bdesymkeymap NAME
-bdeposkeymap NAME
     Specify `NAME' as the symbolic/positional keymap file for the
     German business keyboard (`KeymapBusinessDESymFile',
     `KeymapBusinessDEPosFile', PET only).  

Joystick settings
==================

   

Joystick resources
-------------------

   
     

JoyDevice1
JoyDevice2
JoyDevice3
JoyDevice4
     Integer specifying which joystick device the emulator should use
     for joystick emulation for ports 1 - 4, respectively (0=None,
     1=Numpad, 2=Custom keys, 3=Analog joystick 1, 4=Analog joystick
     2, 5=Digital joystick 1, 6=Digital joystick 2 on Unix) The
     available joysticks might differ depending on operating system
     and joystick support in the OS (Linux joystick module must be
     available for example). 

JoyOpposite
     Boolean, if true allow (usually impossible) bitcombinations for
     opposite directions.

ExtraJoy
     Boolean, enables extra joysticks if true.

ExtraJoyType
     Integer specifying the type of adapter used for the extra
     joysticks. (0=Classical Games/ Protovision, 1=PET, 2=Hummer,
     3=OEM, 4=Digital Excess/Hitmen, 5=Kingsoft, 6=Starbyte) 

Mouse
     Boolean, enables mouse emulation

Mousetype
     Integer that specifies the type of emulated mouse. (0=1351,
     1=NEOS, 2=Amiga, 3=paddles, 4=Atari CX-22, 5=Atari ST)

Mouseport
     Integer that specifies the joystick port the emulated mouse is
     connected to. (1=port 1, 2=port 2) 

Lightpen
     Boolean, enables lightpen emulation

LightpenType
     Integer specifying the type of lightpen. (0=Pen with button Up,
     1=Pen with button Left,  2=Datel Pen, 3=Magnum Light Phaser,
     4=Stack Light Rifle) 

KeySet1NorthWest
KeySet1North
KeySet1NorthEast
KeySet1East
KeySet1SouthEast
KeySet1South
KeySet1SouthWest
KeySet1West
KeySet1Fire
     Integers specifying the keycodes for keyset 1. 

KeySet2NorthWest
KeySet2North
KeySet2NorthEast
KeySet2East
KeySet2SouthEast
KeySet2South
KeySet2SouthWest
KeySet2West
KeySet2Fire
     Integers specifying the keycodes for keyset 2. 

KeySetEnable
     Boolean that specifies whether user defined keysets are enabled.
      

Joystick command-line options
------------------------------

   
     

-joydev1 <0-8>
-joydev2 <0-8>
     Set the device for joystick emulation of port 1 and 2,
     respectively (`JoyDevice1', `JoyDevice2').

-extrajoydev1 <0-8>
-extrajoydev2 <0-8>
     Set device for extra joystick port 1 and 2. 

-mouse
+mouse
     Enable/Disable mouse grab

-mousetype <value>
     Select the mouse type (0 = 1351, 1 = NEOS, 2 = Amiga, 3 =
     Paddles)

-mouseport <value>
     Select the joystick port the mouse is attached to 

-lightpen
+lightpen
     Enable/Disable lightpen emulation

-lightpentype <type>
     Set lightpen type  


@EndNode

@Node "Sound settings" "vice.guide/Sound settings"
@Next "Drive settings"
@Prev "Keyboard settings"
@Toc "Settings and resources"

Sound settings
===============

    The following menu items control sound output: 
     

     "Enable sound playback" turns sound emulation on and off. 

     "Sound synchronization" specifies the method for syncronizing the
     sound playback.  Possible settings are:
          "Flexible", i.e., the audio renderer flexibly adds/removes
          samples to the output to smoothly adapt the playback to
          slight changes in the speed of the emulator.

          "Adjusting" works like "flexible", but supports bigger
          differences in speed.  For example, if the emulation speed
          drops down from from 100% to 50%, audio slows down by the
          same amount too.

          "Exact", instead, makes the audio renderer output always the
          same sounds you would hear from the real thing, without
          trying to adapt the ratio; to compensate the tolerances in
          speed, some extra frames will be skipped or added. 

     "Sample rate" specifies the sampling frequency, ranging from 8000
     to 48000 Hz (not all the sound cards and/or sound drivers can
     support all the frequencies, so actually the nearest candidate
     will be chosen). 

     "Buffer size" specifies the size of the audio buffer; the bigger
     the buffer, the longer the delay with which sounds are played.
     You should pick the smallest value your machine can handle
     without problems. 

     "Sound suspend time", will cause the audio playback to pause for
     the specified number of seconds whenever some clicking happens.
     If "Keep going" is selected, no pausing is done.  

   * Sound resources:: * Sound options::  menu 


@EndNode

@Node "Sound resources" "vice.guide/Sound resources"
@Next "Sound options"
@Prev "Sound settings"
@Toc "Sound settings"

Sound resources
----------------

   
     

Sound
     Boolean specifying whether audio emulation is turned on. 

SoundSpeedAdjustment
     Integer specifying what speed adjustment method the audio renderer
     should use.  Possible values are:
          `0': "flexible"

          `1': "adjusting"

          `2': "exact" 

SoundSampleRate
     Integer specifying the sampling frequency, ranging from 8000 to
     48000 Hz (not all the sound cards and/or sound drivers can
     support all the frequencies, so actually the nearest candidate
     will be chosen). 

SoundBufferSize
     Integer specifying the size of the audio buffer, in milliseconds.
     

SoundSuspendTime
     Integer specifying the pause interval when audio underflows
     ("clicks") happen.  `0' means no pause is done. 

SoundDeviceName
     String specifying the audio driver.  Implemented drivers are:
     
          `aix', for the IBM AIX sound driver.

          `uss', for the Linux/FreeBSD Universal Sound System driver
          (`SoundDeviceArg' specifies the audio device, `/dev/dsp' by
          default);

          `sgi', for the Silicon Graphics audio device
          (`SoundDeviceArg' specifies the audio device, `/dev/audio'
          by default);

          `sun', for the Solaris audio device (unfinished;
          `SoundDeviceArg' specifies the audio device, `/dev/audio' by
          default).

          `hpux', for the HP-UX audio device (unfinished;
          `SoundDeviceArg' specifies the audio device, `/dev/audio' by
          default).

          `sdl', for the Simple DirectMedia Layer audio driver.

          `esd', for EsounD, the Enlightened Sound Daemon;
          `SoundDeviceArg' specifies the ESD server (`host:port') to
          connect, empty by default.

          `dummy', fully emulating the SID, but not actually playing
          samples.

          `dump', writing all the write accesses to the registers to a
          file (specified by `SoundDeviceArg', default value is
          `vicesnd.sid');

          `speed', like `dummy' but also calculating samples (mainly
          used to evaluate the speed of the sample generator);

          `fs', writing samples to a file (specified by
          `SoundDeviceArg'; default is `vicesnd.raw');  These
     drivers will actually be present only if the VICE configuration
     script detected the corresponding devices at the time of
     compilation. 

SoundDeviceArg
     String specifying an additional parameter for the audio driver
     (see `SoundDeviceName'). 

SoundRecordDeviceName
     String specifying the filename used for sound recording.

SoundRecordDeviceArg
     String specifying additional arguments for sound recording.

SoundFragmentSize
     Enum specifying the fragment size (0: small, 1: medium, 2: large)

SoundVolume
     Integer specifying the master volume in percent. [100] (0..100)s

SoundOutput
     Enum specifying how the type of sound output. Output is selectable
     between 'system'  (system decides to use mono or stereo output
     based on the presence of a stereo sid),  'always mono' (output
     is always mono, stereo streams are mixed into a mono stream)  or
     'always stereo' (output is always stereo, mono streams are
     multiplexed to a stereo  stream). (0=system, 1=mono, 2=stereo)
      


@EndNode

@Node "Sound options" "vice.guide/Sound options"
@Prev "Sound resources"
@Toc "Sound settings"

Sound command-line options
---------------------------

   
     

-sound
+sound
     Turns sound emulation on (`Sound=1') and off (`Sound=0'). 

-soundsync N
     Specify `N' as the sound speed adjustment method
     (`SoundSpeedAdjustment'). 

-soundrate RATE
     Specifies the sound playback sample rate (`SoundSampleRate'). 

-soundoutput <output mode>
     Sound output mode: (0: system decides mono/stereo, 1: always mono,
     2: always stereo) 

-soundbufsize SIZE
     Specifies the size of the audio buffer in milliseconds
     (`SoundBufferSize'). 

-soundfragsize <value>
     Set sound fragment size (0 = small, 1 = medium, 2 = large) 

-sounddev NAME
     Specifies the name of the audio device (`SoundDeviceName'). 

-soundarg ARG
     Specifies an additional parameter for the audio device
     (`SoundDeviceArg'). 

-soundrecdev <name>
     Specify recording sound driver

-soundrecarg <args>
     Specify initialization parameters for recording sound driver 


Tape settings
==============

    These settings are used to control the hardware-level emulation
of the Tape drive. 

Tape resources
---------------

   
     

DatasetteResetWithCPU
     Boolean specifying whether to reset (rewind) the tape when
     resetting the CPU.

DatasetteZeroGapDelay
     Integer specifying the delay in cycles for a zero in the tap.

DatasetteSpeedTuning
     Integer specifying the number of cycles added to each gap in the
     tap.  

Tape command-line options
--------------------------

   
     

-dsresetwithcpu
+dsresetwithcpu
     Enable/Disable automatic Datasette-Reset 

-dszerogapdelay <value>
     Set delay in cycles for a zero in the tap 

-dsspeedtuning <value>
     Set number of cycles added to each gap in the tap  


@EndNode

@Node "Drive settings" "vice.guide/Drive settings"
@Next "Peripheral settings"
@Prev "Sound settings"
@Toc "Settings and resources"

Drive settings
===============

    These settings are used to control the hardware-level emulation
of the Disk drives.  When hardware-level emulation is turned on, only
drives 8 and 9 are being emulated.  The following settings affect
both drives: 
     

     "Enable true drive emulation" enables the (slow) hardware-level
     emulation of the drives for maximum compatibility.  This must be
     turned on for any of the following settings to have effect. 

     "Drive sync factor" specifies the speed of the drive's CPU.  This
     can be used to help loading certain programs that have trouble
     with the default PAL setting (for example, programs designed for
     NTSC machines). The ratio is calculated as follows: 

     sync_factor = 65536 * clk_drive / clk_machine  where
`clk_drive' and `clk_machine' are clock speeds in MHz. The menu lets
you choose between the PAL and NTSC values, and also lets you specify
whatever value you want.  Be careful when changing it, though,
because a wrong value can break things and even corrupt disk images.
  itemize  The following settings, instead, are specific of each
drive: 
     

     "Drive model" specifies the model of the drive being emulated.
     *Warning:* This will reset the drive. 

     "Enable parallel cable" enables emulation of a SpeedDOS parallel
     cable; if you switch this option on and replace the original
     Commodore ROMs with SpeedDOS-compatible ones, you can speed up
     loading/saving times. 

     "Idle method" specifies which method the drive emulation should
     use to save CPU cycles in the host CPU.  There are three
     methods: 
          "Skip cycles": Each time the serial line is accessed by the
          C64, the drive executes all the cycles since the last time
          it ran.  If the number of elapsed cycles is larger than a
          certain value, the drive discards part of them.

          "Trap idle": The disk drive is still emulated upon serial
          line accesses as with the previous option, but it is also
          always emulated at the end of each screen frame.  If the
          drive gets into the DOS idle loop, only pending interrupts
          are emulated to save time.

          "No traps": Like "Trap idle", but without any traps at all.
          So basically the drive works exactly as with the real
          thing, and nothing is done to reduce the power needs of the
          drive emulation.  The first option ("Skip cycles") is
     usually best for performance, as the drive is emulated as little
     as possible; on the other hand, you may notice sudden slowdowns
     (when the drive executes several cycles at once) and the LED
     status is never updated (because it would not be possible to do
     correctly so).  Moreover, if the drive tries to get in sync with
     the computer in some weird way and the computer does not access
     the serial line for a long time, it is possible that some cycles
     are discarded and the sync is lost.  Notice that this hack will
     have no effect on performance if a program continuously reads
     from the IEC port, as the drive will have to be fully emulated
     in any case (some stupid programs do this, even when they don't
     actually need to use the drive). 

     <P>  The second option ("Trap idle") is usually a bit slower,
as at least interrupts are always emulated, but ensures the LED state
is always updated correctly and always keeps the drive and the
computer in sync. On the other hand, if a program installs a
non-standard idle loop in the drive, the drive CPU has to be emulated
even when not necessary and the global emulation speed is then *much*
slower. 

   "40-track image support" specifies how 40-track ("extended") disk
images should be supported.  There are three possible ways: 
     "Never extend" never extends disk images at all (so if a program
     tries to write tracks beyond the 35th, it is not allowed to do
     so);

     "Ask on extend" prompts the user as soon as a program tries to
     write tracks beyond the 35th, and the user can then choose
     whether he wants the disk image to be extended or not;

     "Extend on access" simply extends the disk image as soon the
     program needs it, without prompting the user.   itemize 


   * Drive resources:: * Drive options::  menu 


@EndNode

@Node "Drive resources" "vice.guide/Drive resources"
@Next "Drive options"
@Prev "Drive settings"
@Toc "Drive settings"

Drive resources
----------------

   
     

RawDriveDriver
     String specifying the name of the device to be used for raw block
     access. 

DriveTrueEmulation
     Boolean controlling whether the "true" drive emulation is turned
     on. 

DriveSoundEmulation
     Boolean controlling whether the drive noise emulation is turned
     on. 

Drive8Type
Drive9Type
Drive10Type
Drive11Type
     Integers specifying the model number for drives 8 to 11.
     Possible values are `1541', `1542' (1541-II), `1570', `1571', 
     `1573' (1571CR), `1551', `1581', `1001', `2000',  `2031',
     `2040', `3040', `4000', `4040', `8050', `8250'. 

Drive8ParallelCable
Drive9ParallelCable
Drive10ParallelCable
Drive11ParallelCable
     integer controlling what type of parallel cable is emulated for
     drives 8 to 11. (0: none, 1: speed-DOS, 2: Professional DOS, 3:
     Formel64) 

Drive8ProfDOS
Drive9ProfDOS
Drive10ProfDOS
Drive11ProfDOS
     Booleans controlling whether Professional DOS is emulated or not
     for drives 8 to 11. 

Drive8RAM2000
Drive8RAM4000
Drive8RAM6000
Drive8RAM8000
Drive8RAMA000
Drive9RAM2000
Drive9RAM4000
Drive9RAM6000
Drive9RAM8000
Drive9RAMA000
Drive10RAM2000
Drive10RAM4000
Drive10RAM6000
Drive10RAM8000
Drive10RAMA000
Drive11RAM2000
Drive11RAM4000
Drive11RAM6000
Drive11RAM8000
Drive11RAMA000
     Booleans controlling whether a RAM block is emulated at the
     respective block or not for drives 8 to 11. 

Drive8ExtendImagePolicy
Drive9ExtendImagePolicy
Drive10ExtendImagePolicy
Drive11ExtendImagePolicy
     Integer specifying the policy for 40-track support for drives 8 to
     11. Possible values are `0' (never extend), `1' (ask on
     extend), `2' (extend on access). 

Drive8IdleMethod
Drive9IdleMethod
Drive10IdleMethod
Drive11IdleMethod
     Integers specifying the idling method for the drive CPU.  Possible
     values are `0' (none), `1' (skip cycles), `2' (trap idle). See
     @{"Drive settings" Link "Drive settings"}. 

DosName1541
DosName1541ii
DosName1570
DosName1571
DosName1571cr
DosName1581
DosName2000
DosName4000
DosName2031
DosName2040
DosName3040
DosName4040
DosName1001
DosName1551
     Strings specifying the names of the ROM images for the drive
     emulation. 

DriveProfDOS1571Name
     String specifying the filename of the 1571 professional DOS ROM
     image.  

RomsetDosName1541
RomsetDosName1541ii
RomsetDosName1570
RomsetDosName1571
RomsetDosName1581
RomsetDosName2000
RomsetDosName4000
RomsetDosName2031
RomsetDosName2040
RomsetDosName3040
RomsetDosName4040
RomsetDosName1001
RomsetDosName1571cr
RomsetDosName1551
     Integers [0]  


@EndNode

@Node "Drive options" "vice.guide/Drive options"
@Prev "Drive resources"
@Toc "Drive settings"

Drive command-line options
---------------------------

   
     

-truedrive
+truedrive
     Turns true drive emulation on (`DriveTrueEmulation=1') and off
     (`DriveTrueEmulation=0'), respectively. 

-drivesound
+drivesound
     Turns drive sound emulation on (`DriveSoundEmulation=1') and off
     (`DriveSoundEmulation=0'), respectively. 

-drive8type TYPE
-drive9type TYPE
-drive10type TYPE
-drive11type TYPE
     Specifies the drive types for drives 8-11, respectively.
     Possible values for `TYPE' are `1541', `1542' (meaning
     1541-II), `1551', `1570', `1571', `1573' (meaning 1571cr),
     `1581', `2000', `4000', `2031', `2040', `3040', `4040', `1001',
     `8050' and `8250'. 

-parallel8 <type>
-parallel9 <type>
-parallel10 <type>
-parallel11 <type>
     Set parallel cable type (0: none, 1: standard, 2: Dolphin DOS) 

-drive8idle NUM
-drive9idle NUM
-drive10idle NUM
-drive11idle NUM
     Specifies `NUM' as the idling method for drives 8-11 (0: no
     traps, 1: skip cycles, 2: trap idle), respectively
     (`Drive8IdleMethod', `Drive9IdleMethod'), `Drive10IdleMethod'),
     `Drive11IdleMethod'). 

-drive8extend NUM
-drive9extend NUM
-drive10extend NUM
-drive11extend NUM
     Specifies `NUM' as the track 40 extend policy in drives 8 and 9,
     respectively (`Drive8ExtendImagePolicy',
     `Drive9ExtendImagePolicy'). 

-dos1541 <name>
-dos1541II <name>
-dos1551 <name>
-dos1570 <name>
-dos1571 <name>
-dos1571cr <name>
-dos1581 <name>
-dos2000 <name>
-dos4000 <name>
-dos2031 <name>
-dos2040 <name>
-dos3040 <name>
-dos4040 <name>
-dos1001 <name>
     Specify the ROM names for the 1541, 1541II, 1551, 1570, 1571,
     1571cr, 1581, 2000, 4000, 2031, 2040, 3040, 4040 and 1001
     emulation respectively. 

-drive8ram2000, +drive8ram2000
-drive9ram2000, +drive9ram2000
-drive10ram2000, +drive10ram2000
-drive11ram2000, +drive11ram2000
     Enable/Disable 8KB RAM expansion at $2000-$3FFF

-drive8ram4000, +drive8ram4000
-drive9ram4000, +drive9ram4000
-drive10ram4000, +drive10ram4000
-drive11ram4000, +drive11ram4000
     Enable/Disable 8KB RAM expansion at $4000-$5FFF

-drive8ram6000, +drive8ram6000
-drive9ram6000, +drive9ram6000
-drive10ram6000, +drive10ram6000
-drive11ram6000, +drive11ram6000
     Enable/Disable 8KB RAM expansion at $6000-$7FFF

-drive8ram8000, +drive8ram8000
-drive9ram8000, +drive9ram8000
-drive10ram8000, +drive10ram8000
-drive11ram8000, +drive11ram8000
     Enable/Disable 8KB RAM expansion at $8000-$9FFF

-drive8rama000, +drive8rama000
-drive9rama000, +drive9rama000
-drive10rama000, +drive10rama000
-drive11rama000, +drive11rama000
     Enable/Disable 8KB RAM expansion at $A000-$BFFF 

-drive8profdos, +drive8profdos
-drive9profdos, +drive9profdos
-drive10profdos, +drive10profdos
-drive11profdos, +drive11profdos
     Enable/Disable Professional DOS 

-profdos1571 <name>
     Specify name of Professional DOS 1571 ROM image   


@EndNode

@Node "Peripheral settings" "vice.guide/Peripheral settings"
@Next "RS232 settings"
@Prev "Drive settings"
@Toc "Settings and resources"

Peripheral settings
====================

    VICE is able to support some special peripherals: 
     "file system devices", pseudo-drives accessing the Unix file
     system;

     printers.  These features depend on some "kernal traps" that
replace the existing routines in the original Commodore operating
system with custom-made C routines. 

   * File system device settings::  Settings for file system devices.
* Printer settings::            Settings for emulating a printer. *
No kernal traps::             Disabling kernal traps completely.
menu 


@EndNode

@Node "File system device settings" "vice.guide/File system device settings"
@Next "Printer settings"
@Prev "Peripheral settings"
@Toc "Peripheral settings"

Settings for file system devices
---------------------------------

    These settings deal with the drive-like peripherals connected to
the bus of the emulated machine. The first setting relates to the
parallel IEEE488 interface. With this interface a special engine is
used to listen to the bus lines to translates them to the filesystem
code. Thus the PET will always detect a drive for example, but it can
also use drives 10 and 11 even together with true disk drive
emulation. 
     "Enable virtual devices", enables the peripheral access via the
     fast disk emulation (either kernal traps or IEEE488 interface).
     Both, filesystem and disk image access via fast drive emulation,
     are affected.  Four peripherals, numbered from 8 to 11, are
accessible; each of them provides the following settings: 
     "File system access", if enabled, allows the device to emulate a
     drive accessing a file system directory; note that when a disk
     image is attached to the same drive, the directory is no longer
     visible and the attached disk is used instead.

     "File system directory" specifies the directory to be accessed by
     the drive.

     "Convert P00 file names", if enabled, allows access to P00 files
     using their built-in name instead of the Unix one.

     "Create P00 files on save", if enabled, creates P00 files (instead
     of raw CBM files) whenever a program creates a file.  Note
that, by default, all drives except 11 create P00 files on save,
while drive 11 creates raw CBM files. Those files come without any
header, but also with the filename restrictions given by the
operating system VICE runs on. 

   * File system device resources:: * File system device options::
menu  


@EndNode

@Node "File system device resources" "vice.guide/File system device resources"
@Next "File system device options"
@Prev "File system device settings"
@Toc "File system device settings"

Resources for file system devices
..................................

    
     

IECDevice8
IECDevice9
IECDevice10
IECDevice11
     Booleans that specify whether IEC device emulation for device #8
     to #11 is enabled. 

FileSystemDevice8
FileSystemDevice9
FileSystemDevice10
FileSystemDevice11
     Enum specifying the device type for device 8-11 (0: NONE, 1:
     FILESYSTEM, 2: OPENCBM (Real), 3: BLOCK DEVICE (Raw)) 

FSDevice8ConvertP00
FSDevice9ConvertP00
FSDevice10ConvertP00
FSDevice11ConvertP00
     Booleans specifying whether on-read support for P00 files is
     enabled on drives 8, 9, 10 and 11 respectively (on by default).
     

FSDevice8SaveP00
FSDevice9SaveP00
FSDevice10SaveP00
FSDevice11SaveP00
     Booleans specifying whether the drives should create P00 files
     instead of plain CBM ones (on by default for drives 8-10, off
     for 11). 

FSDevice8HideCBMFiles
FSDevice9HideCBMFiles
FSDevice10HideCBMFiles
FSDevice11HideCBMFiles
     Booleans specifying whether non-P00 files should be invisible to
     programs running in the emulator (do not hide by default). 

FSDevice8Dir
FSDevice9Dir
FSDevice10Dir
FSDevice11Dir
     Strings specifying the directories to which drives 8, 9, 10 and
     11 have access.   


@EndNode

@Node "File system device options" "vice.guide/File system device options"
@Prev "File system device resources"
@Toc "File system device settings"

Command-line options for file system devices
.............................................

   
     

-iecdevice8
+iecdevice8
     Enable/Disable IEC device emulation for device #8

-iecdevice9
+iecdevice9
     Enable/Disable IEC device emulation for device #9

-iecdevice10
+iecdevice10
     Enable/Disable IEC device emulation for device #10

-iecdevice11
+iecdevice11
     Enable/Disable IEC device emulation for device #11 

-device8 <type>
-device9 <type>
-device10 <type>
-device11 <type>
     Set device type for device 8-11 (0: NONE, 1: FILESYSTEM, 2:
     OPENCBM (Real), 3: BLOCK DEVICE (Raw)) 

-fs8 PATH
-fs9 PATH
-fs10 PATH
-fs11 PATH
     Specify the paths for the file system access on drives 8, 9, 10
     and 11, respectively (`FSDevice8Dir', `FSDevice9Dir',
     `FSDevice10Dir' and `FSDevice11Dir'). 

-flipname <name>
     Specify name of the flip list file image   


@EndNode

@Node "Printer settings" "vice.guide/Printer settings"
@Next "No kernal traps"
@Prev "File system device settings"
@Toc "Peripheral settings"

Printer settings
-----------------

    The VICE emulators can emulate printers connected to either the
IEC buffer or the user port.  Emulation can be achieved by
redirecting the printer output to a file or by piping it through an
external process. This is defined by so-called "printer device file
names"; a printer device file name can be either a simple path, or a
command name preceeded by a pipe symbol `|'.  For example,
printer device `filename' will cause the output to be appended to the
file `filename', while printer device `|lpr' will cause the `lpr'
command to be executed and be fed the printer output.  The printer
output will not be converted but saved as printed by the emulated
machine.  Up to three printer devices may be specified through the
following resources: 
     device 1, whose default value is `print.dump';

     device 2, whose default value is `|lpr'.

     device 3, whose default value is `|petlp -F PS|lpr';  So,
basically, by default printer device 1 will dump printer output to
`print.dump'; printer device 2 will print it via `lpr' directly to
the printer and device 3 will print it via `petlp' (a
not-yet-complete utility that will produce Postscript output from the
Commodore printer code) and then to the printer via `lpr'.  

   * Printer resources:: * Printer options::  menu 


@EndNode

@Node "Printer resources" "vice.guide/Printer resources"
@Next "Printer options"
@Prev "Printer settings"
@Toc "Printer settings"

Printer resources
..................

   
     

IECDevice4
IECDevice5
     Booleans that specify whether IEC device emulation for device #4
     and #5 is enabled. 

PrinterTextDevice1
PrinterTextDevice2
PrinterTextDevice3
     Strings specifying the printer devices (see @{"Printer settings" Link "Printer settings"}). 

Printer4TextDevice
Printer5TextDevice
     Integer (ranging from 0 to 2, for device 1-3) specifying what
     printer device (see @{"Printer settings" Link "Printer settings"}) the IEC printer is using.
     

Printer4
Printer5
     Integer specifying how the IEC printer (device 4-5) is being
     emulated. (0: NONE, 1: FS, 2: REAL) 

Printer4Driver
Printer5Driver
     String (ascii, mps803, nl10) specifying the IEC printer output
     driver. 

Printer4Output
Printer5Output
     String specifying the IEC printer output device.  

PrinterUserport
     Boolean specifying if the user-port printer is being emulated. 

PrinterUserportTextDevice
     Integer (ranging from 0 to 2, for device 1-3) specifying what
     printer device the user-port printer is using. 

PrinterUserportDriver
     String specifying the user-port printer output driver. 

PrinterUserportOutput
     String specifying the user-port printer output device.  


@EndNode

@Node "Printer options" "vice.guide/Printer options"
@Prev "Printer resources"
@Toc "Printer settings"

Printer command-line options
.............................

   
     

-iecdevice4
+iecdevice4
     Enable/Disable IEC device emulation for device #4

-iecdevice5
+iecdevice5
     Enable/Disable IEC device emulation for device #5 

-device4 <type>
-device5 <type>
     Set device type for device 4-5 (0: NONE, 1: FS, 2: REAL) 

-prtxtdev1 <name>
-prtxtdev2 <name>
-prtxtdev3 <name>
     Specify name of printer text device or dump file

-pr4txtdev <0-2>
-pr5txtdev <0-2>
     Specify printer text output device for IEC printer #4-5 

-pr4output <name>
-pr5output <name>
     Specify name of output device for device #4-5 Specify name of
     output device for device #5-5

-pr4drv <name>
-pr5drv <name>
     Specify name of printer driver for device #4-5 Specify name of
     printer driver for device #5-5 

-pruser
+pruser
     Enable/disable emulation of the userport printer emulation
     (`PrUser=1', `PrUser=0'). 

-prusertxtdev <0-2>
     Specify printer text output device for userport printer

-pruseroutput <name>
     Specify name of output device for the userport printer

-pruserdrv <name>
     Specify name of printer driver for the userport printer   


@EndNode

@Node "No kernal traps" "vice.guide/No kernal traps"
@Prev "Printer settings"
@Toc "Peripheral settings"

Disabling kernal traps
-----------------------

    If you have compatibility problems, you can completely disable
Kernal traps with the "Disable kernal traps" option.  This will of
course disable all the features that depend on it, such as the fast
1541 emulation (so you will have to turn true 1541 emulation on if
you want to be able to read or write disk images) and tape support.


   * No traps resources:: * No traps options::  menu 


@EndNode

@Node "No traps resources" "vice.guide/No traps resources"
@Next "No traps options"
@Prev "No kernal traps"
@Toc "No kernal traps"

Resources to control Kernal traps
..................................

   
     

VirtualDevices
     Boolean specifying whether all the mechanisms for virtual device
     emulation should be enabled. Serial IEC devices use kernal traps,
     parallel IEEE488 devices use an own IEEE488 engine. Both are
     switched on and off with this resource.   


@EndNode

@Node "No traps options" "vice.guide/No traps options"
@Prev "No traps resources"
@Toc "No kernal traps"

Command-line options to control Kernal traps
.............................................

   
     

-virtualdev
+virtualdev
     Enable (`VirtualDevices=1') or disable (`VirtualDevices=0')
     virtual devices.   


@EndNode

@Node "RS232 settings" "vice.guide/RS232 settings"
@Next "Monitor settings"
@Prev "Peripheral settings"
@Toc "Settings and resources"

RS232 settings
===============

    The VICE emulators can emulate the RS232 device most of the
machines have.  The C64, C128 and VIC20 emulators emulate the
userport RS232 interface at 300 and 1200 baud.  The C64 and C128 can
also use the 9600 baud interface by Daniel Dallmann, using the shift
registers of the two CIA 6526 chips.  The PET can have a 6551 ACIA
RS232 interface when running as a SuperPET, and the CBM-II has such
an ACIA by default.  The C64 and C128 emulators can emulate an ACIA
6551 (also known as Datapump for example) as extension at `$de**'.
 Emulation can be achieved by either: 
     connecting a real UNIX serial device;

     dumping to a file;

     piping through a process.  It is possible to define up to four
UNIX serial devices, and then decide which interface should be
connected to which device.  This is done by so-called "rs232 device
file names"; an rs232 device file name can be either a simple path,
or a command name preceeded by a pipe symbol `|'.  If the path
specifies a special device (e.g. `/dev/ttyS0') it is recognized by
VICE and the emulator can set the baudrate.  For example, rs232
device `filename' will cause the output to be written (not appended)
to the file `filename', while printer device `|lpr' will cause the
`lpr' command to be executed and be fed the rs232 output.  The rs232
output will not be converted but saved as sent by the emulated
machine.  The same holds true for the rs232 input. If the command
writes data to the standard output it will be caught by VICE and sent
back to the emulator.  Also the data sent by the pseudo device will
be sent back to VICE.  For example you can setup a null-modem cable
between two serial ports of your PC, setup one port for login and use
the other in VICE.  Then you can login from your emulator via the
RS232 emulation and the null-modem cable to your machine again. 
You can not simply run a shell from VICE, as the shell will notice
that it does not run on its own pseudo terminal and will thus buffer
its output.  You need to write some program that opens an own pseudo
terminal and runs the shell from there (not yet finished).  Up to
four RS232 devices may be specified through the following resources:

     device 1, whose default value is `/dev/ttyS0';

     device 2, whose default value is `/dev/ttyS1';

     device 3, whose default value is `rs232.dump';

     device 4, whose default value is `|lpr'.  For the first two
devices you can change the baudrate the tty device is set to by
specifying it on the commandline or in the menu.  This baudrate is
9600 by default for the latter two, but can be changed only by
resources (The baudrate is independent from the baudrate the emulator
actually expects). 

   * RS232 resources:: * RS232 options:: * RS232 usage::  menu



@EndNode

@Node "RS232 resources" "vice.guide/RS232 resources"
@Next "RS232 options"
@Prev "RS232 settings"
@Toc "RS232 settings"

RS232 resources
----------------

   
     

RsDevice1
RsDevice2
RsDevice3
RsDevice4
     Strings specifying the RS232 devices (see @{"RS232 settings" Link "RS232 settings"}). 

RsDevice1Baud
RsDevice2Baud
RsDevice3Baud
RsDevice4Baud
     Integer specifying the RS232 baudrate devices if the device file
     points to a special device (like `/dev/ttyS0'; see
     @{"RS232 settings" Link "RS232 settings"}). 

Acia1Dev
     Integer (ranging from 0 to 3, for device 1-4) specifying what
     RS232 device (see @{"RS232 settings" Link "RS232 settings"}) the ACIA is using (all except
     VIC20). 

Acia1Irq
     Integer specifying which interrupt to use. 0 = none, 1 = IRQ, 2 =
     NMI (C64 and C128 only) 

RsUserEnable
     Boolean specifying if the user-port RS232 interface is being
     emulated (C64, C128 and VIC20). 

RsUserBaud
     Integer specifying the baudrate of the user-port RS232 interface
     (C64, C128 and VIC20). 

RsUserDev
     Integer (ranging from 0 to 3, for device 1-4) specifying what
     RS232 device the user-port interface is using (C64, C128 and
     VIC20).  


@EndNode

@Node "RS232 options" "vice.guide/RS232 options"
@Next "RS232 usage"
@Prev "RS232 resources"
@Toc "RS232 settings"

RS232 command-line options
---------------------------

   
     

-rsdev1 NAME
-rsdev2 NAME
-rsdev3 NAME
-rsdev4 NAME
     Specify `NAME' as RS232 devices 1, 2, 3 and 4, respectively
     (`RsDevice1', `RsDevice2' `RsDevice3' and `RsDevice4'). 

-rsdev1 BAUDRATE
-rsdev2 BAUDRATE
-rsdev3 BAUDRATE
-rsdev4 BAUDRATE
     Specify `BAUDRATE' as baudrate for the RS232 devices if the device
     name specifies a special device (like `/dev/ttyS0' for example,
     see @{"RS232 settings" Link "RS232 settings"}; `RsDevice1Baud', `RsDevice2Baud'
     `RsDevice3Baud' and `RsDevice4Baud'). 

-myaciadev <0-3>
     Specify RS232 device the ACIA should work on 

-rsuser
+rsuser
     Enable or disable emulation of the userport RS232 emulation
     (`RsUser'; C64, C128 and VIC20) 

-rsuserbaud <baud>
     Set the baud rate of the RS232 userport emulation. 

-rsuserdev <0-3>
     Specify device for the userport RS232 emulation (`RsUserDev';
     C64, C128 and VIC20).  


@EndNode

@Node "RS232 usage" "vice.guide/RS232 usage"
@Prev "RS232 options"
@Toc "RS232 settings"

RS232 usage example
--------------------

    Here we give you a simple example how to set up an emulated C64
using the modem connected to your PC. The following list shows each
step. 
Attach your modem to your PC at a serial port.
     Normally you should set it up to use the modem as "/dev/modem".

start VICE
     

Setup VICE to use your modem as "serial device 1"
     Go to the RS232 settings menu and change "Serial 1 device" to
     "/dev/modem" (or the device where you attached your modem to)
     Then go to the RS232 settings menu and change "Serial 1 baudrate"
     to the baudrate your modem should run at.   Watch out, e.g. on
     Linux there is an additional multiplier   to multiply with the
     baudrate (so e.g. 19200 gives 115200 or so baud)   See the
     "setserial" manpage on Linux for example.   However, most modems
     should be able to autodetect the speed to   the computer as
     well. 

Select the RS232 emulation your programs use
     If you want to use the Userport emulation, go to the RS232
     settings and   change "Userport RS232 Device" to   "Serial 1".
     If you want ACIA emulation (swiftlink or what's it called?)
     then change "ACIA $DE** device" to "Serial 1". 

Enable the emulation
     Go to the RS232 settings and select either "ACIA $DE** emulation"
      or Userport 300/1200 baud or CIA 9600 baud emulation. 

Load your program and start it.
     If it is able to detect an   RS232 cartridge like swiftlink or
     so, try to detect the ACIA emulation   if enabled.   Otherwise
     just set the baudrate to either 300, 1200 or 9600 according   to
     what you enabled in the VICE menu for the userport.  


@EndNode

@Node "Monitor settings" "vice.guide/Monitor settings"
@Next "Misc settings"
@Prev "RS232 settings"
@Toc "Settings and resources"

Monitor settings
=================

    This section lists command-line options specific to the built-in
monitor. 

   * Monitor options::  menu 


@EndNode

@Node "Monitor options" "vice.guide/Monitor options"
@Toc "Monitor settings"

   

Monitor resources
------------------

   
     

KeepMonitorOpen
     Boolean, if true the monitor window may stay open when the
     emulation is running, eg to look at trace-point output. (Not all
     ports/UIs support this, in that case this setting has no
     effect.) 

MonitorServer
     Boolean specifying whether the remote monitor server is enabled.

MonitorServerAddress
     String specifying the address the remote monitor server listens to
     (ip4://127.0.0.1:6510)  

Monitor command-line options
-----------------------------

   
-moncommands FILENAME
     Execute the commands from the file `FILENAME' in the monitor after
     starting up. This command line switch is mainly thought to load
     labels and to set breakpoints. Not all other commands are useful
     to be executed in this way, some may even lead to strange
     effects. 

-initbreak <address>
     Set an initial breakpoint for the monitor. Addresses with prefix
     "0x" are hexadecimal. 

-remotemonitor
+remotemonitor
     Enable/Disable remote monitor 

-remotemonitoraddress <name>
     The local address the remote monitor should bind to   

Machine settings
=================

   

Machine resources
------------------

   
     

MachineVideoStandard
     Integer that specifies that video standard of the emulated
     machine. (-1: PAL,  -2: NTSC, -3: NTSC (old), -4: PAL-N)  

Machine command-line options
-----------------------------

   
     

-pal
     Use PAL sync factor

-ntsc
     Use NTSC sync factor

-ntscold
     Use old NTSC sync factor

-paln
     Use PAL-N sync factor   

Memory settings
================

   

Memory resources
-----------------

   
     

RAMInitStartValue
     Integer specifying the value for the very first RAM address after
     powerup

RAMInitValueInvert
     Integer specifying the length of the memory block initialized with
     the same value

RAMInitPatternInvert
     Integer specifying the length of the memory block initialized with
     the same pattern  

Memory command-line options
----------------------------

   
     

-raminitstartvalue <value>
     Set the value for the very first RAM address after powerup

-raminitvalueinvert <num of bytes>
     Length of memory block initialized with the same value

-raminitpatterninvert <num of bytes>
     Length of memory block initialized with the same pattern   


@EndNode

@Node "Misc settings" "vice.guide/Misc settings"
@Prev "Monitor settings"
@Toc "Settings and resources"

Miscellaneous settings
=======================

    This section lists generic resources that do not fit in the
other categories. 

   * Misc resources:: * Misc options::  menu 


@EndNode

@Node "Misc resources" "vice.guide/Misc resources"
@Next "Misc options"
@Prev "Misc settings"
@Toc "Misc settings"

Miscellaneous resources
------------------------

   
Directory
     String specifying the search path for system files.  It is defined
     as a sequence of directory names, separated by colons (`:'),
     just like the `PATH' variable in the shell.  The special string
     `$$' stands for the default search path, which is initialized at
     startup to the following value: 





























     LIBDIR/EMUID:$HOME/.vice/EMUID:BOOTPATH/EMUID:LIBDIR/DRIVES:$HOME/.vice/DRIVES:BOOTPATH/DRIVES
 where: 
     `LIBDIR' is the VICE installation directory (usually
     `/usr/local/lib/vice', `/usr/lib/vice' or `/opt/vice/lib');

     `EMUID' is the emulation identification string (`C64', `C128',
     `VIC20' or `PET');

     `BOOTPATH' is the directory where the binary lies (usually
     `/usr/local/bin', `/usr/bin' or `/opt/vice/bin').

     `DRIVES' is the directory called "DRIVES", where the disk drive
     ROMs are. (The disk drive ROMs are used by all emulators, so
     there is an extra directory for them.)  Notice that the
middle entry points to a default location in the user's home
directory. Here private ROM versions (e.g. speeddos or JiffyDos) can
be stored for example.  See @{"System files" Link "System files"}. for a description of the
method used to load the emulator's system files. 
HTMLBrowserCommand String specifying the command to run the help
browser.  The help browser can be any HTML browser, and every `%s' in
the string is replaced with the name of the toplevel file of the VICE
documentation.  For example, the default value `netscape %s' runs
Netscape Navigator.   SaveResourcesOnExit Boolean specifying
whether the emulator should save changed settings before exiting.  If
this is enabled, the user will be always prompted first, in case the
settings have changed.   DoCoreDump Boolean specifying whether
the emulator should dump core when it gets a signal. 
NetworkServerName String specifying the name of the remote server.
NetworkServerBindAddress String specifying the IP of the remote
server.  NetworkServerPort Integer specifying the port used for
network play.  NetworkControl Integer specifying whether the
emulator is running as server or client (0: client, 1: server) 
LogFileName String specifying the filename of the current log file.
FliplistName String specifying the filename of the current flip
list. (Drive 8 only)   ConfirmOnExit Boolean specifying whether
to show a confirmation dialog on exit.   AttachDevice8Readonly
AttachDevice9Readonly  AttachDevice10Readonly
AttachDevice11Readonly Booleans that specify whether to attach images
on drives 8 to 11 read-only.   RomsetArchiveName String
specifying the filename of the ROM set archive (.vra) file ["default"]
RomsetArchiveActive String specifying the active configuration of
the current ROM set archive [""]  RomsetFileName String specifying
the filename of the ROM set resource file ["default"]
RomsetSourceFile Boolean specifying the type of currently used ROM
set (0: .vra Archive, 1: resource file) [1]   table 


@EndNode

@Node "Misc options" "vice.guide/Misc options"
@Prev "Misc resources"
@Toc "Misc settings"

Miscellaneous command-line options
-----------------------------------

   
-directory SEARCHPATH
     Specify the system file search path (`Directory').

-htmlbrowser COMMAND
     Specify the command to run the HTML browser for the on-line help
     (`HTMLBrowserCommand'). 

-saveres
+saveres
     Enable/disable automatic saving of settings on exit
     (`SaveResourcesOnExit=1', `SaveResourcesOnExit=0'). 

-confirmexit
     Confirm quiting VICE

+confirmexit
     Never confirm quiting VICE 

-core
     Enable generation of core dumps (`DoCoreDump=1')

+core
     Disable generation of core dumps (`DoCoreDump=0')   


@EndNode

@Node "Machine-specific features" "vice.guide/Machine-specific features"
@Next "Snapshots"
@Prev "Settings and resources"
@Toc "Top"

Machine-specific features
**************************

   

   * C64/128-specific::            Commands and settings specific to
the                                 C64/128 emulators *
C64DTV-specific::             Commands and settings specific to the
                             C64DTV emulator * VIC20-specific::
       Commands and settings specific to the
       VIC20 emulator * PET-specific::                Commands and
settings specific to the                                 PET
emulator * CBM-II-specific::             Commands and settings
specific to the                                 CBM-II emulator
menu 


@EndNode

@Node "C64-128-specific" "vice.guide/C64-128-specific"
@Next "C64DTV-specific"
@Prev "Machine-specific features"
@Toc "Machine-specific features"

C64/128-specific commands and settings
=======================================

     This section lists the settings and commands that are C64/128
specific and thus are not present in the other emulators. 

   * C64 cartridges::              Using cartridges with the C64
emulator. * VIC-II settings::             Settings that control the
video chip. * SID settings::                Settings that control the
audio chip. * C64 I/O extension settings::  Settings that enable
special extensions. * C64/128 system ROM settings::  Settings to
control the system ROMs.  menu 


@EndNode

@Node "C64 cartridges" "vice.guide/C64 cartridges"
@Next "VIC-II settings"
@Prev "C64-128-specific"
@Toc "C64-128-specific"

   

Using cartridges
-----------------

    The cartridge system is organized in "Slots" to allow more than
one cartridge connected at a time, like it can be done using an
expansion port expander on a real C64 (see below).  Generally a
cartridge can be enabled by attaching its respective cartridge image,
or using the respective menu option for cartridges that do not
require an image.  x64, x64sc and x128 allow you to attach the
following kinds of images: 
     `.crt' images, as used by the CCS64 emulator by Per Håkan
     Sundell

     raw `.bin' images, with or without load address  "Cartridge
images" are like disk images, but contain the contents of cartridge
ROM and/or RAM images instead of disk images.  To attach
cartridges, use the "Attach a cartridge image" submenu. When using
`.crt' images, this will work for every cartridge which is supported.
For raw `.bin' images you might have to use command line options. 
When you have successfully attached a cartridge image, you should
then reset the machine to make sure the cartridge initializes itself.
(Or enable the "reset on cartridge change" option).  Of course, it
is also possible to detach a currently attached cartridge image
("Detach cartridge image").  If you are using a freezer cart like
an Action Replay cartridge, you can emulate the cartridge's freeze
button with the "Cartridge freeze" command.  The imaginary
expansion port expander is organized in 4 slots, the cartridges are
associated with them like this: 

Slot 0
.......

    All carts that have a passthrough connector go here. Once a "Slot
0" cartridge is enabled all further cartridges are connected to its
respective passthrough port.  Only one cartridge of this type can
be active at a time.  "Slot 0" carts have individual "enable"
switches, enabling means enabling permanently.  The following
cartridges are emulated in this slot: 
     IEEE-488 Interface










     (`http://www.funet.fi/pub/cbm/schematics/cartridges/c64/ieee-488/eprom.bin')

     Magic Voice

     MMC64 

Slot 1
.......

    Mostly RAM based cartridges which for one reason or the other
might make sense to be enabled together with one of the "Main Slot"
cartridges go here.  Only one cartridge of this type can be active
at a time.  "Slot 1" carts have individual "enable" switches,
enabling means enabling permanently  The following cartridges are
emulated in this slot: 
     Double Quick Brown Box (DQBB)

     Expert Cartridge

     ISEPIC

     RamCart 

Main Slot
..........

    All other cartridges which are not pure i/o extensions go here.
 Only one cartridge of this type can be active at a time. 
Cartridges in the "Main Slot" must be explicitly set as default to
enable them permanently.  The following cartridges are emulated in
this slot: 
     generic 4K, 8K and 16K game- and ultimax cartridges

     Action Replay V5

     Action Replay MK2

     Action Replay MK3

     Action Replay MK4

     Atomic Power

     C64 Games System

     Capture

     Comal 80

     Dela EP64

     Dela EP7x8

     Dela EP256

     Diashow-Maker

     Dinamic

     EasyFlash

     Epyx FastLoad

     EXOS

     The Final Cartridge

     The Final Cartridge III

     Final Cartridge Plus

     Freeze Frame

     Freeze Machine

     Fun Play

     Game Killer

     IDE64 (`http://www.ide64.org/')

     KCS Power Cartridge

     MACH 5

     Magic Desk

     Magic Formel

     Mikro Assembler

     MMC Replay

     Ocean

     Prophet64

     REX 256k EPROM Cart

     REX Utility

     Retro Replay

     ROSS

     Simons' BASIC

     Snapshot 64

     Stardos

     Structured BASIC

     Super Explode V5.0

     Super Games

     Super Snapshot V4

     Super Snapshot V5

     Warp Speed

     Westermann Learning

     Zaxxon 

I/O Slot
.........

    All carts that are pure I/O extensions go here.  Any number
of "I/O Slot" Carts may be active at a time.  "I/O Slot" carts have
individual "enable" switches, enabling means enabling permanently. 
The following cartridges are emulated in this slot: 
     ACIA (Swiftlink, Turbo232)

     DigiMAX

     Ethernet (The Final Ethernet, RR-Net)

     GEO-RAM

     MIDI (Passport/Syntech, Datel/Siel/JMS/C-Lab, Maplin, Namesoft,
     Sequential)

     RAM Expansion Module (REU)

     SFX Sound Expander

     SFX Sound Sampler 

Expected behaviour
...................

    When the emulator is run without arguments, all settings from the
config file should be applied and arguments override settings from
the config file.  When saving the settings to the config file it is
expected that on the next run of the emulator all settings will be in
the same state as they were when saved.  There is an exception to
this rule: the cartridge in the "Main Slot" must be explicitly set as
default before it gets saved to the config file.  `+cart' should
disable ALL cartridges, including eventually activated REU, Swithlink
and all similar expansionport devices.  `-cartXYZ' options should
generally attach AND activate a cart of type XYZ. As a consequence,
attaching carts this way which are NOT in the "Main Slot" will also
enable the cart permanently. 

Common problems
................

    If attaching a cartridge does not work as expected, this may be
because of various reasons: 

     Not seldomly the CRT type is incorrectly set in `.crt' files
found "in the wild". Make sure this is not the case (if in doubt use
`cartconv' to verify and/or fix).   You may have unintentionally
enabled more than one cartridge at once, for example by saving the
settings with REU enabled, and then later attaching a game cartridge
from the command-line. The cartridge system will allow certain
combinations, but (as on the real thing) not all do (can) actually
work. To make sure this is not the case, either detach all cartridges
from the menus, or use `+cart' on the command-line.   The
cartridge image might be broken. Try one from a different source. If
you are sure the dump is ok (for example because you dumped it
yourself) then make sure it is in proper linear order (on some
cartridges, for example "capture", address and/or data lines at the
eprom are shuffled around so a dump made with an eprom burner can not
be used as is).   Last not least you might have encountered a bug
in the emulation. If you suspect this is the case, and you can still
reproduce the bug after checking the things above, please file a bug
report including the following information: 

   attach your vicerc and a reference to the cartridge binaries  if
you can, comment in the respective DEBUGXYZ macros prominently defined
at the top of these files: src/c64/cart/c64cart.c
src/c64/cart/c64cartmem.c src/c64/c64io.c src/c64/c64export.c and
then recompile. this will add debug output that might make it much
easier to locate certain problems.  itemize   itemize 

IEEE-488 interface
...................

    To be able to use an IEEE drive, you need to enable IEEE
emulation for the emulator. To do this, follow the following steps:
 Download the IEEE 488 ROM image from the CBM archives (formerly
known as FUNET) Attach that image with File/Attach cartridge
image/IEEE488 interface image.  Make sure you have a one-drive
system only (that is, go to Settings/Peripheral Setting, uncheck "use
IEC device" for all devices, go to Settings/Drive Settings and select
"Floppy type" as "none" for all drives other than drive 8.  After
this, all drives can be selected in x64 and x128. 

The Final Cartridge 3
......................

   The Final Cartridge 3 detects whether a mouse is connected when it
starts and disables mouse support if it doesnt detect one. So to make
mouse emulation work you must either enable it on the command line,
or reset the cartridge after enabling it from the user interface. 

C64 cartridge settings
-----------------------

   

C64 cartridge resources
........................

   
     

IOCollisionHandling
     Integer specifying the way the I/O collisions should be handled,
     (0: error message and  detach all involved carts, 1: error
     message and detach last attached involved  carts, 2: warning in
     log and 'AND' the valid return values) 

CartridgeReset
     Boolean specifying whether the machine should be resetted when a
     cartridge is changed.

CartridgeType
     Integer specifying the type of cartridge emulated in the "main"
     slot

CartridgeFile
     String specifying the filename of the image for the cartridge
     emulated in the "main" slot 

DQBB
     Boolean specifying whether the Double Quick Brown Box should be
     emulated or not.

DQBBfilename
     String specifying the filename of the DQBB RAM image.

DQBBImageWrite
     Boolean, if true write back the DQBB image file automatically,
     incase the RAM contents changed, when detaching or quitting the
     emulator. 

EasyFlashJumper
     Boolean specifying whether the Easy Flash jumper is set.

EasyFlashWriteCRT
     Boolean, if true write back the Easy FLash image file
     automatically, incase the contents changed, when detaching or
     quitting the emulator. 

ExpertCartridgeEnabled
     Boolean specifying whether the Expert Cartridge should be emulated
     or not.

Expertfilename
     String specifying the filename of the Expert Cartridge RAM image.

ExpertImageWrite
     Boolean, if true write back the Expert Cartridge image file
     automatically, incase the RAM contents changed, when detaching
     or quitting the emulator.

ExpertCartridgeMode
     Enum specifying the state of the expert cartridge switch (0=off
     1=prg 2=on)

IDE64Config
     String encoded content of IDE64 DS1302 RAM, used to store IDEDOS
     setup parameters. Not meant to be directly manipulated as
     content depends on the version of IDEDOS used.

IDE64version4
     Boolean specifying whether the emulated card version is V4.1 or
     V3.4. This is automatically detected most of the time for .crt
     cartridge images.

IDE64RTCOffset
     Integer in seconds which gives the difference between the local
     time and the time of the emulated DS1302 RTC.

IDE64Image1
IDE64Image2
IDE64Image3
IDE64Image4
     String specifying the full path to the four harddisk images. If a
     file is non-existing the drive is not emulated. Some older
     IDEDOS versions only support the first two harddisks.

IDE64Cylinders1
IDE64Cylinders2
IDE64Cylinders3
IDE64Cylinders4
     Number of cylinders for the four harddisk images. Valid range is
     1-65535.

IDE64Heads1
IDE64Heads2
IDE64Heads3
IDE64Heads4
     Number of heads for the four harddisk images. Valid range is
     1-16.

IDE64Sectors1
IDE64Sectors2
IDE64Sectors3
IDE64Sectors4
     Number of sectors for the four harddisk images. Valid range is
     1-63.

IDE64AutodetectSize1
IDE64AutodetectSize2
IDE64AutodetectSize3
IDE64AutodetectSize4
     Boolean specifying whether the disk geometry should be auto
     detected based on the disk image for the respective harddisk, or
     the cylinder/head/sector resources above should be used.

IEEE488
     Boolean specifying whether the IEEE488 interface should be
     emulated or not.

IEEE488Image
     String specifying the filename of the IEEE488 ROM image

IsepicCartridgeEnabled
     Boolean specifying whether ISEPIC should be emulated or not.

Isepicfilename
     String specifying the filename of the ISEPIC RAM image.

IsepicSwitch
     Boolean specifying the status of the ISEPIC switch (0: off, 1:
     on)

IsepicImageWrite
     Boolean, if true write back the ISEPIC image file automatically,
     incase the RAM contents changed, when detaching or quitting the
     emulator.

MagicVoiceCartridgeEnabled
     Boolean specifying whether the Magic Voice should be emulated or
     not.

MagicVoiceImage
     String specifying the filename of the Magic Voice ROM image 

MMC64
     Boolean specifying whether the MMC64 should be emulated or not.

MMC64BIOSfilename
     String specifying the filename of the MMC64 Flash ROM image.

MMC64_bios_write
     Boolean, if true write back the MMC64 Flash ROM image file
     automatically, incase the contents changed, when detaching or
     quitting the emulator.

MMC64_flashjumper
     Boolean that specifies whether the MMC64 flash jumper is set.

MMC64_revision
     Integer that specifies the MMC64 hardware revision (0=Rev. A,
     1=Rev. B)

MMC64imagefilename
     String specifying the filename of the SD-Card image used by the
     MMC64 emulation.

MMC64_RO
     Boolean, if true the SD-Card image is mounted read-only.

MMC64_sd_type
     Integer that specifies the reported type for the emulated SD-Card.
     (0=Auto, 1=MMC, 2=SD, 3=SDHC) 

MMCRCardImage
     String that specifies the filename of the SD-Card image used by
     the MMCR emulation.

MMCREEPROMImage
     String that specifies the filename of the MMCR EEPROM image.

MMCRRescueMode
     Boolean that specifies if the rescue mode (both buttons pressed
     during powerup) of the MMCR is active.

MMCRImageWrite
     Boolean, if true write back the MMCR Flash ROM image file
     automatically, incase the contents changed, when detaching or
     quitting the emulator.

MMCRCardRW
     Boolean that specifies if the SD-Card image used by the MMCR
     emulation is writeable.

MMCRSDType
     Integer that specifies the reported type for the emulated SD-Card.
     (0=Auto, 1=MMC, 2=SD, 3=SDHC)

MMCREEPROMRW
     Boolean that specifies if the MMCR EEPROM image is writeable. 

RAMCART
     Boolean specifying whether the RAMCart should be emulated or not.

RAMCARTfilename
     String specifying the filename of the RAMCart RAM image.

RAMCARTImageWrite
     Boolean, if true write back the RAMCart image file automatically,
     incase the RAM contents changed, when detaching or quitting the
     emulator.

RAMCART_RO
     Boolean, if true the RAMCart contents are read only

RAMCARTsize
     Integer specifying the size of the RAMCart in KB (64, 128) 

RRrevision
     Integer specifying the RR hardware revision (0=retro replay,
     1=nordic replay)

RRFlashJumper
     Boolean specifying whether the RR flash jumper is set or not.

RRBankJumper
     Boolean specifying whether the RR bank jumper is set or not.

RRBiosWrite
     Boolean, if true write back the RR Flash ROM image file
     automatically, incase the contents changed, when detaching or
     quitting the emulator. 

C64 cartridge command-line options
...................................

   
     

-iocollision <method>
     Select the way the I/O collisions should be handled, (0: error
     message and  detach all involved carts, 1: error message and
     detach last attached involved  carts, 2: warning in log and
     'AND' the valid return values 

+cart
     Disable all cartridges (which would eventually be enabled in the
     config file).

-cartreset
+cartreset
     Reset/Do not reset machine if a cartridge is attached or detached

-cart8 <name>
     Attach generic 8KB cartridge image

-cart16 <name>
     Attach generic 16KB cartridge image

-cartultimax <name>
     Attach generic 16kB Ultimax cartridge image

-cartcrt <name>
     Attach CRT cartridge image

-cartap <name>
     Attach raw 32KB Atomic Power cartridge image

-cartar2 <name>
     Attach raw 16kB Action Replay MK2 cartridge image

-cartar3 <name>
     Attach raw 16KB Action Replay MK3 cartridge image

-cartar4 <name>
     Attach raw 32KB Action Replay MK4 cartridge image

-cartar5 <name>
     Attach raw 32KB Action Replay cartridge image

-cartcap <name>
     Attach raw 8kB Capture cartridge image

-cartcomal <name>
     Attach raw 64kB Comal 80 cartridge image

-cartdep256 <name>
     Attach raw Dela EP256 cartridge image

-cartdep64 <name>
     Attach raw Dela EP64 cartridge image

-cartdep7x8 <name>
     Attach raw Dela EP7x8 cartridge image

-cartdin <name>
     Attach raw 128kB Dinamic cartridge image

-cartdsm <name>
     Attach raw 8kB Diashow-Maker cartridge image

-cartdqbb <name>
     Attach raw 16kB Double Quick Brown Box cartridge image

-dqbb
+dqbb
     Enable/Disable Double Quick Brown Box

-dqbbimage <name>
     Specify Double Quick Brown Box filename

-dqbbimagerw
+dqbbimagerw
     Allow/Disallow writing to DQBB image

-carteasy <name>
     Attach raw EasyFlash cartridge image

-easyflashjumper
+easyflashjumper
     Enable/Disable EasyFlash jumper

-easyflashcrtwrite
+easyflashcrtwrite
     Allow/Disallow writing to EasyFlash .crt image

-cartepyx <name>
     Attach raw 8KB Epyx FastLoad cartridge image

-cartexos <name>
     Attach raw 8kB EXOS cartridge image

-cartexpert <name>
     Attach raw 8kB Expert Cartridge image

-expert
+expert
     Enable/Disable the Expert Cartridge

-expertimagename <name>
     Set Expert Cartridge image name

-expertimagerw
+expertimagerw
     Allow/Disallow writing to Expert Cartridge image

-cartf64 <Name>
     Attach raw 32kB Formel 64 image

-cartfc1 <name>
     Attach raw 16kB Final Cartridge image

-cartfc3 <name>
     Attach raw 64kB Final Cartridge III image

-cartfcplus <name>
     Attach raw 32kB Final Cartridge Plus image

-cartff <name>
     Attach raw 8kB Freeze Frame image

-cartfm <name>
     Attach raw 32kB Freeze Machine image

-cartfp <name>
     Attach raw 128kB Fun Play/Power Play cartridge image

-cartgk <name>
     Attach raw 8KB Game Killer cartridge image

-cartgs <name>
     Attach raw 512kB Game System cartridge image

-cartide64 <name>
     Attach raw 64KB or 128KB IDE64 cartridge image

-IDE64image1 <name>
-IDE64image2 <name>
-IDE64image3 <name>
-IDE64image4 <name>
     Specify path to the image files for IDE64 harddisks

-IDE64cyl1 <value>
-IDE64cyl2 <value>
-IDE64cyl3 <value>
-IDE64cyl4 <value>
     Set number of cylinders for the IDE64 harddisk emulation
     (1-65535)

-IDE64hds1 <value>
-IDE64hds2 <value>
-IDE64hds3 <value>
-IDE64hds4 <value>
     Set number of heads for the IDE64 harddisk emulation (1-16)

-IDE64sec1 <value>
-IDE64sec2 <value>
-IDE64sec3 <value>
-IDE64sec4 <value>
     Set number of sectors for the IDE64 harddisk emulation (1-63)

-IDE64autosize1
+IDE64autosize1
-IDE64autosize2
+IDE64autosize2
-IDE64autosize3
+IDE64autosize3
-IDE64autosize4
+IDE64autosize4
     Autodetect geometry of formatted images or do not autodetect and
     use specified geometry

-IDE64version4
+IDE64version4
     Emulate version 4 hardware/Emulate pre version 4 hardware

-cartieee <name>
     Attach CBM IEEE-488 cartridge image

-ieee488
+ieee488
     Enable (`IEEE488=1') or disable (`IEEE488=0') emulation of the
     IEEE488 interface.

-ieee488image <name>
     Set IEEE488 interface image name

-isepic
+isepic
     Enable/Disable the ISEPIC cart

-cartisepic <name>
     Attach raw 2kB ISEPIC cartridge image

-isepicimagename <name>
     Set ISEPIC image name

-isepicimagerw
+isepicimagerw
     Allow/Disallow writing to ISEPIC image

-cartkcs <name>
     Attach raw 16kB KCS Power cartridge image

-cartks <name>
     Attach raw 24kB Kingsoft cartridge image

-cartmach5 <name>
     Attach raw 8kB MACH 5 cartridge image

-cartmd <name>
     Attach raw 32/64/128kB Magic Desk cartridge image

-cartmf <name>
     Attach raw Magic Formel cartridge image

-cartmikro <name>
     Attach raw 8kB Mikro Assembler cartridge image

-mmc64
+mmc64
     Enable/Disable the MMC64 expansion

-cartmmc64 <name>
     Attach raw 8kB MMC64 cartridge image

-mmc64bios <name>
     Specify name of MMC64 BIOS image

-mmc64image <name>
     Specify name of MMC64 image

-mmc64readonly
     Set the MMC64 card to read-only

-mmc64readwrite
     Set the MMC64 card to read/write

-mmc64bioswrite
     Save the MMC64 bios when changed

-cartmmcr <name>
     Attach raw 512kB MMC Replay cartridge image

-mmcrrescue
+mmcrrescue
     Enable/Disable MMC Replay rescue mode

-mmcrimagerw
+mmcrimagerw
     Allow/Disallow writing to MMC Replay image

-mmcrcardimage <filename>
     Specify MMC Replay card image filename

-mmcrcardrw
+mmcrcardrw
     Allow/Disallow writes to MMC Replay card image

-mmcreepromimage
     Specify MMC Replay EEPROM image filename

-mmcreepromrw
+mmcreepromrw
     Allow/Disallow writes to MMC Replay EEPROM image

-cartmv <name>
     Attach raw 16kB Magic Voice cartridge image

-cartocean <name>
     Attach raw Ocean cartridge image

-cartp64 <name>
     Attach raw 256KB Prophet 64 cartridge image

-cartpf <name>
     Attach raw 64kb Pagefox cartridge image

-cartramcart <name>
     Attach raw RamCart cartridge image

-ramcart
+ramcart
     Enable/Disable the RAMCART expansion

-ramcartsize <size in KB>
     Size of the RAMCART expansion

-ramcartimage <name>
     Specify name of RAMCART image

-ramcartimagerw
+ramcartimagerw
     Allow/Disallow writing to RAMCart image

-cartrep256 <name>
     Attach raw REX EP256 cartridge image

-cartross <name>
     Attach raw 16/32kB ROSS cartridge image

-cartrr <name>
     Attach raw 64KB Retro Replay cartridge image

-rrbioswrite
+rrbioswrite
     Enable/Disable saving of the RR ROM at exit

-rrbankjumper
+rrbankjumper
     Set/Unset RR Bank Jumper

-rrflashjumper
+rrflashjumper
     Set/Unset RR Flash Jumper

-cartru <name>
     Attach raw 8kB REX Utility cartridge image

-carts64 <name>
     Attach raw 4kB Snapshot 64 cartridge image

-cartsb <name>
     Attach raw Structured Basic cartridge image

-cartse5 <name>
     Attach raw 16kB Super Explode V5 cartridge image

-cartsg <name>
     Attach raw 64kB Super Games cartridge image

-cartsilver <Name>
     Attach raw Silverrock 128 cartridge image

-cartsimon <name>
     Attach raw 16kB Simons Basic cartridge image

-cartss4 <name>
     Attach raw 32KB Super Snapshot V4 cartridge image

-cartss5 <name>
     Attach raw 64KB Super Snapshot V5 cartridge image

-cartstar <name>
     Attach raw 16KB Stardos cartridge image

-cartwl <name>
     Attach raw 16KB Westermann Learning cartridge image

-cartws <name>
     Attach raw 8kB Warp Speed cartridge image

-cartzaxxon <name>
     Attach raw 16kB Zaxxon cartridge image 

CIA settings
-------------

   

CIA resources
..............

   
     

CIA1Model
CIA2Model
     Enum specifying CIA model (0 = old 6526, 1 = new 6526A)  

CIA command-line options
.........................

   
     

-ciamodel <model>
     Set both CIA models (0 = old 6526, 1 = new 6526A)

-cia1model <model>
     Set CIA 1 model (0 = old 6526, 1 = new 6526A)

-cia2model <model>
     Set CIA 2 model (0 = old 6526, 1 = new 6526A)  


@EndNode

@Node "VIC-II settings" "vice.guide/VIC-II settings"
@Next "SID settings"
@Prev "C64 cartridges"
@Toc "C64-128-specific"

VIC-II settings
----------------

    These settings control the emulation of the VIC-II (MOS6569)
video chip used in both the C64 and the C128. 
     

     "Sprite-sprite collisions" and "Sprite-background collisions", if
     enabled, cause the hardware detection of sprite-to-sprite and
     sprite-to-background collisions of the VIC-II to be emulated.
     This feature is used by many games, and disabling either of the
     two detection systems can sometimes make you invincible
     (although there is also a chance that also enemies become
     invincible then). 

     "Color set" can be used to dynamically change the palette file
     being used by choosing one of the available predefined color
     sets: 
          `default.vpl' ("default"), the default VICE palette;

          `c64s.vpl' ("C64S"), palette taken from the shareware C64S
          emulator by Miha Peternel.

          `ccs64.vpl' ("CCS64"), palette taken from the shareware
          CCS64 emulator by Per Håkan Sundell.

          `frodo.vpl' ("Frodo"), palette taken from the free Frodo
          emulator by Christian Bauer
          (http://www.uni-mainz.de/~bauec002/FRMain.html).

          `pc64.vpl' ("PC64"), palette taken from the free PC64
          emulator by Wolfgang Lorenz.

          `godot.vpl' ("GoDot"), palette as suggested by the authors of
          the C64 graphics package GoDot
          (http://users.aol.com/howtogodot/welcome.htm).  

   * VIC-II resources:: * VIC-II options::  menu 


@EndNode

@Node "VIC-II resources" "vice.guide/VIC-II resources"
@Next "VIC-II options"
@Prev "VIC-II settings"
@Toc "VIC-II settings"

VIC-II resources
.................

   
     

VICIIModel
     Integer that specifies VIC-II model
     (6569/6569r1/8565/6567/8562/6567r56a). only available in
     `x64sc'. 

VICIICheckSsColl
     Boolean specifying whether the sprite-sprite hardware collision
     detection must be emulated. 

VICIICheckSbColl
     Boolean specifying whether the sprite-background hardware
     collision detection must be emulated. 

VICIIVideoCache
     Boolean specifying whether the video cache is turned on. 

VICIIDoubleSize
     Boolean specifying whether double-size mode is turned on. 

VICIIDoubleScan
     Boolean specifying whether double-scan mode is turned on. 

VICIINewLuminances
     Boolean specifying whether to use new (9 steps) luminances 

VICIIPaletteFile
     String specifying the name of the palette file being used.  The
     `.vpl' extension is optional. 

VICIIHwScale
     Boolean specifying whether to enable or disable hardware scaling
     

VICIIFullscreenDevice
     fullscreen device 

VICIIFullscreen
     Boolean specifying whether to use fullscreen mode or not. 

VICIIFullscreenStatusbar
     Boolean specifying whether to show the status bar in fullscreen
     mode or not. 

VICIIXRANDRFullscreenMode
     integer specifying XRANDR fullscreen mode 

VICIIVidmodeFullscreenMode
     integer specifying Vidmode fullscreen mode 

VICIIExternalPalette
     Boolean specifying whether to use external palette file or not.
     

VICIIColorSaturation
     integer specifying saturation of internal calculated palette
     [1000] <0-2000> 

VICIIColorContrast
     integer specifying contrast of internal calculated palette [1000]
     <0-2000> 

VICIIColorBrightness
     integer specifying brightness of internal calculated palette
     [1000] <0-2000> 

VICIIColorGamma
     integer specifying gamma of internal calculated palette [2200]
     <0-4000> 

VICIIColorTint
     integer specifying tint of internal calculated palette [1000]
     <0-2000> 

VICIIPALScanLineShade
     integer specifying amount of scan line shading for the CRT
     emulation [667] <0-1000> 

VICIIPALBlur
     integer specifying amount of horizontal blur for the CRT
     emulation. [500] <0-1000> 

VICIIPALOddLinePhase
     integer specifying phase offset for color carrier in odd lines
     [750] <0-2000> 

VICIIPALOddLineOffset
     integer specifying phase for color carrier in odd lines [1250]
     <0-2000> 

VICIIAudioLeak
     Boolean specifying whether to enable/disable video to audio leak
     emulation. 

VICIIFilter
     integer specifying rendering filter, 0:none, 1:CRT emulation, 2:
     scale2x 

VICIIBorderMode
     integer specifying border display mode (0: normal, 1: full, 2:
     debug, 3:none)   


@EndNode

@Node "VIC-II options" "vice.guide/VIC-II options"
@Prev "VIC-II resources"
@Toc "VIC-II settings"

VIC-II command-line options
............................

   
     

-VICIIcheckss
+VICIIcheckss
     Enable (`VICIICheckSsColl=1') and disable (`VICIICheckSsColl=0')
     emulation of hardware sprite-sprite collision detection,
     respectively. 

-VICIIchecksb
+VICIIchecksb
     Enable (`VICIICheckSbColl=1') and disable (`VICIICheckSbColl=0')
     emulation of hardware sprite-background collision detection,
     respectively. 

-VICIIvcache
+VICIIvcache
     Enable/disable the video cache (`VICIIVideoCache=1',
     `VICIIVideoCache=0'). 

-VICIIdsize
+VICIIdsize
     Enable/disable the double size mode (`VICIIDoubleSize=1',
     `VICIIDoubleSize=0'). 

-VICIIdscan
+VICIIdscan
     Enable/disable the double scan mode (`VICIIDoubleScan=1',
     `VICIIDoubleScan=0'). 

-VICIIhwscale
+VICIIhwscale
     Enable/Disable hardware scaling

-VICIIfilter <Mode>
     Select rendering filter, 0:none, 1:CRT emulation, 2: scale2x

-VICIIintpal
     Use an internal calculated palette

-VICIIextpal
     Use an external palette (file) 

-VICIIpalette NAME
     Specify `NAME' as the palette file (`VICIIPaletteFile'). 

-VICIIfulldevice <device>
     Select fullscreen device

-VICIIXRANDRfullmode <mode>
     Select fullscreen mode

-VICIIVidmodefullmode <mode>
     Select fullscreen mode

-VICIIborders <mode>
     Set VIC-II border display mode (0: normal, 1: full, 2: debug,
     3:none)

-VICIImodel <model>
     Set VIC-II model (6569/6569r1/8565/6567/8562/6567r56a). This
     setting is only available in `x64sc'. 

-VICIInewluminance
+VICIInewluminance
     Enable/Disable new luminances. 

-VICIIsaturation <0-2000>
     Set saturation of internal calculated palette [1000]

-VICIIcontrast <0-2000>
     Set contrast of internal calculated palette [1000]

-VICIIbrightness <0-2000>
     Set brightness of internal calculated palette [1000]

-VICIIgamma <0-4000>
     Set gamma of internal calculated palette [2200]

-VICIItint <0-2000>
     Set tint of internal calculated palette [1000]

-VICIIoddlinesphase <0-2000>
     Set phase for color carrier in odd lines [1250]

-VICIIoddlinesoffset <0-2000>
     Set phase offset for color carrier in odd lines [750]

-VICIIcrtblur <0-1000>
     Amount of horizontal blur for the CRT emulation. [500]

-VICIIcrtscanlineshade <0-1000>
     Amount of scan line shading for the CRT emulation [667] 

-VICIIaudioleak
+VICIIaudioleak
     Enable/Disable video to audio leak emulation.   


@EndNode

@Node "SID settings" "vice.guide/SID settings"
@Next "C64 I-O extension settings"
@Prev "VIC-II settings"
@Toc "C64-128-specific"

SID settings
-------------

    These settings control the emulation of the SID (MOS6581 or
MOS8580) audio chip. 
     

     "Second SID" maps a second SID chip into the address space for
     stereo sound. This emulates e.g. the "SID Symphony Stereo
     Cartridge" from Dr. Evil Laboratories. The second SID can be
     used with software such as "Stereo SID Player" by Mark Dickenson
     or "The Enhanced Sidplayer" by Craig Chamberlain. 

     "Second SID base address" sets the start address for the second
     SID chip. Software normally uses $DE00 or $DF00, since
     $DE00-$DEFF and $DF00-$DFFF can be mapped through the cartridge
     port of the C64. The default start address is $DE00. 

     "Emulate filters" causes the built-in programmable filters of the
     SID chip to be emulated.  A lot of C64 music requires them to be
     emulated properly, but their emulation requires some additional
     processor power. 

     "ChipModel" specifies the model of the SID chip being emulated:
     there are two slightly different generations of SID chips:
     MOS6581 ones and MOS8580 ones. 

     "Use reSID emulation" specifies whether the more accurate (and
     resource hungry) reSID emulation is turned on or off. 

     "reSID sampling method" selects the method for conversion of the
     SID output signal to a sampling rate appropriate for playback by
     standard digital sound equipment. Possible settings are:
          "Fast" simply clocks the SID chip at the output sampling
          frequency, picking the nearest sample. This yields
          acceptable sound quality, but sampling noise is noticeable
          in some cases, especially with SID combined waveforms. The
          sound emulation is still cycle exact.

          "Interpolating" clocks the SID chip each cycle, and
          calculates each sample with linear interpolation. The
          sampling noise is now strongly attenuated by the SID
          external filter (as long as "Emulate filters" is selected),
          and the linear interpolation further improves the sound
          quality.

          "Resampling" clocks the SID chip each cycle, and uses the
          theoretically correct method for sample generation. This
          delivers CD quality sound, but is extremely CPU intensive,
          and is thus most useful for non-interactive sound
          generation. Unless you have a very fast machine, that is.
     

     "reSID resampling passband" specifies the percentage of the
     total bandwidth allocated to the resampling filter passband. The
     work rate of the resampling filter is inversely proportional to
     the remaining transition band percentage. This implies that e.g.
     with the transition band starting at ~ 20kHz, it is faster to
     generate 48kHz than 44.1kHz samples. For CD quality sound
     generation at 44.1kHz the passband percentage should be set to
     90 (i.e. the transition band starting at almost 20kHz).  

   * SID resources:: * SID options::  menu 


@EndNode

@Node "SID resources" "vice.guide/SID resources"
@Next "SID options"
@Prev "SID settings"
@Toc "SID settings"

SID resources
..............

   
     

SidStereo
     Integer specifying the amount of emulated extra SIDs. (0=off, 1=1
     extra sid,  2=2 extra sids. 

SidStereoAddressStart
     Integer specifying the base address of the second SID. 

SidTripleAddressStart
     Integer specifying the base address of the third SID. 

SidFilters
     Boolean specifying whether the built-in SID filters must be
     emulated. 

SidModel
     Integer specifying what model of the SID must be emulated (`0':
     6581 , `1': 8580, `2': 8580D, `3': 6581R4, `4': DTVSID, `8':
     6581R3_4885    , `9': 6581R3_0486S, `10': 6581R3_3984, `11':
     6581R4AR_3789, `12': 6581R3_4485    , `13': 6581R4_1986S, `16':
     8580R5_3691, `17': 8580R5_3691D, `18': 8580R5_1489    , `19':
     8580R5_1489D). 

SidEngine
     Integer specifying what SID engine will be used (`0': FASTSID,
     `1': RESID , `2': CATWEASELMKIII, `3': HARDSID, `4':
     PARSID_PORT1, `5': PARSID_PORT2 , `6': PARSID_PORT3, `7':
     RESID_FP). 

SidResidSampling
     Integer specifying the sampling method (`0': Fast, `1':
     Interpolation, `2': Resampling) 

SidResidPassband
     Integer specifying the resampling filter passband in percentage of
     the total bandwidth (`0 - 90'). 

SidResidGain
     Integer that specifies reSID gain in percent [97] (90..100)

SidResidFilterBias
     Integer that specifies reSID filter bias, which can be used to
     adjust DAC bias  in millivolts. [0] (-5000..5000)

SidParSIDport
     Integer specifying the lpt port used for ParSID.   


@EndNode

@Node "SID options" "vice.guide/SID options"
@Prev "SID resources"
@Toc "SID settings"

SID command-line options
.........................

   
     

-sidstereo
     Emulates a second SID chip for stereo sound (`SidStereo'). 

-sidstereoaddress `ADDRESS'
     Specifies the start address for the second SID chip
     (`SidStereoAddressStart'). 

-sidtripleaddress `ADDRESS'
     Specifies the start address for the third SID chip
     (`SidTripleAddressStart'). 

-sidenginemodel <engine and model>
     Specify `SID engine' and `MODEL' for the emulated SID chip ( 0:
     FastSID 6581, 1: FastSID 8580, 256: ReSID 6581, 257: ReSID
     8580, 258: ReSID 8580 + digiboost, 1024: ParSID in par port
     1, 1280: ParSID in par port 2, 1536: ParSID in par port 3,
     1800: ReSID-FP 6581R3 4885, 1801: ReSID-FP 6581R3 0486S, 1802:
     ReSID-FP 6581R3 3984, 1803: ReSID-FP 6581R4 AR 3789, 1804:
     ReSID-FP 6581R3 4485, 1805: ReSID-FP 6581R4 1986S, 1808:
     ReSID-FP 8580R5 3691, 1809: ReSID-FP 8580R5 3691 + digiboost,
     1810: ReSID-FP 8580R5 1489, 1811: ReSID-FP 8580R5 1489D). 

-sidfilters
+sidfilters
     Enable (`SidFilters=1') or disable (`SidFilters=0') emulation of
     the built-in SID filters. 

-residsamp `METHOD'
     Specifies the sampling method; fast (`SidResidSampling=0'),
     interpolating (`SidResidSampling=1'), resampling
     (`SidResidSampling=2'), fast resampling (`SidResidSampling=3').
     

-residpass `PERCENTAGE'
     Specifies the resampling filter passband in percentage of the
     total bandwidth (`SidResidPassband=0-90'). 

-residgain `PERCENTAGE'
     Specifies reSID gain in percent (90 - 100). 

-residfilterbias <number>
     reSID filter bias setting, which can be used to adjust DAC bias in
     millivolts.   


@EndNode

@Node "C64 I-O extension settings" "vice.guide/C64 I-O extension settings"
@Next "C64-128 system ROM settings"
@Prev "SID settings"
@Toc "C64-128-specific"

C64 I/O extension settings
---------------------------

    I/O extensions are (usually) cartridges which do not map into ROM
space, but use only the I/O space at address range $DE00 ... $DEFF
and/or $DF00 ... $DFFF.  Please use these extensions only when
needed, as they might cause compatibility problems.  The
following I/O extensions are available: 
     

     ACIA (Swiftlink, Turbo232) 

     DigiMAX 

     Ethernet (The Final Ethernet, RR-Net) 

     GEO-RAM 

     MIDI (Passport, Datel, Maplin, Namesoft, Sequential) 

     REU - The "RAM Expansion Module" extension emulates a standard
     Commodore RAM Expansion Unit; this can be used with GEOS and
     other programs that are designed to take advantage of it.  This
     currently works only in the C64 emulator. 

     SFX Sound Expander 

     SFX Sound Sampler  

   * C64 I/O extension resources:: * C64 I/O extension options::
menu 


@EndNode

@Node "C64 I-O extension resources" "vice.guide/C64 I-O extension resources"
@Next "C64 I-O extension options"
@Prev "C64 I-O extension settings"
@Toc "C64 I-O extension settings"

C64 I/O extension resources
............................

   
     

Acia1Enable
     Boolean specifying whether the ACIA (Swiftlink, Turbo232)
     cartridge should be emulated or not.

Acia1Mode
     Enum specifying the type of emulated RS232 interface (0: normal,
     1: Swithlink, 2: Turbo232)

Acia1Base
     Integer specifying the base address for the emulated ACIA chip.
     

DIGIMAX
     Boolean specifying whether the DigiMAX cartridge should be
     emulated or not.

DIGIMAXbase
     Integer specifying the DigiMAX base address. 

ETHERNET_ACTIVE
     Boolean that specifies whether the CS8900 ethernet interface
     emulation is active.

ETHERNET_INTERFACE
     String specifying the device name of the ethernet device to use
     for the emulation.

ETHERNET_DISABLED
     Boolean that specified whether ethernet emulation has been
     disabled because it is not available in the current
     configuration.

ETHERNET_AS_RR
     Boolean that specifies whether RR-Net compatible mapping is
     enabled. 

GEORAM
     Boolean specifying whether the GEO-RAM cartridge should be
     emulated or not.

GEORAMfilename
     String specifying the filename of the GEORAM image.

GEORAMImageWrite
     Boolean, if true write back the GEO-RAM image file automatically,
     incase the RAM contents changed, when detaching or quitting the
     emulator.

GEORAMsize
     Integer specifying the size of the emulated GEO-RAM in KB (64,
     128, 256, 512, 1024,  2048, 4096) 

MIDIEnable
     Boolean specifying whether the MIDI cartridge should be emulated
     or not.

MIDIMode
     Enum specifying the type of emulated MIDI interface (0:
     Sequential, 1: Passport/Syntech, 2: DATEL/Siel/JMS, 3: Namesoft,
     4: Maplin)

MIDIDriver
     Enum specifying the MIDI driver (0: OSS; 1:ALSA)

MIDIInDev
     String specifying the MIDI input device.

MIDIOutDev
     String specifying the MIDI output device. 

REU
     Boolean specifying whether the RAM Expansion Module should be
     emulated or not.

REUfilename
     String specifying the filename of the REU image.

REUImageWrite
     Boolean, if true write back the REU image file automatically,
     incase the RAM contents changed, when detaching or quitting the
     emulator.

REUsize
     Integer specifying the size of the emulated REU in KB (128, 256,
     512, 1024, 2048, 4096, 8192, 16384)

REUfirstUnusedRegister
     Integer specifying the first unused REU register (obsolete, will
     get removed) 

SFXSoundExpander
     Boolean specifying whether the SFX Sound Expander should be
     emulated or not.

SFXSoundExpanderChip
     Enum specifying which YM chip is emulated (0: 3526, 1: 3812) 

SFXSoundSampler
     Boolean specifying whether the SFX Sound Sampler should be
     emulated or not.   


@EndNode

@Node "C64 I-O extension options" "vice.guide/C64 I-O extension options"
@Prev "C64 I-O extension resources"
@Toc "C64 I-O extension settings"

C64 I/O extension command-line options
.......................................

   
     

-acia1
+acia1
     Enable/Disable the $DE** ACIA RS232 interface emulation

-digimax
+digimax
     Enable/Disable the DigiMAX cartridge

-digimaxbase <base address>
     Base address of the DigiMAX cartridge

-miditype <0-4>
     MIDI interface type (0: Sequential, 1: Passport, 2: DATEL, 3:
     Namesoft, 4: Maplin)

-midi
+midi
     Enable/Disable MIDI emulation

-midiin <name>
     Specify MIDI-In device

-midiout <name>
     Specify MIDI-Out device

-mididrv <driver>
     Specify MIDI driver (0 = OSS, 1 = ALSA)

-georam
+georam
     Enable/Disable the GEORAM expansion unit

-cartgeoram <name>
     Attach raw GEO-RAM cartridge image

-georamimage <name>
     Specify name of GEORAM image

-georamimagerw
+georamimagerw
     Allow/Disallow writing to GEORAM image

-georamsize <size in KB>
     Size of the GEORAM expansion unit

-reu
+reu
     Enable (`REU=1') or disable (`REU=0') emulation of the RAM
     Expansion Module.

-cartreu <name>
     Attach raw REU cartridge image

-reuimage <name>
     Specify name of REU image

-reuimagerw
+reuimagerw
     Allow/Disallow writing to REU image

-reusize <size in KB>
     Size of the RAM expansion unit

-sfxse
+sfxse
     Enable/Disable the SFX soundexpander cartridge

-sfxsetype <type>
     Set YM chip type (3526 / 3812)

-sfxss
+sfxss
     Enable/Disable the SFX Sound Sampler cartridge

-tfe
+tfe
     Enable/Disable the TFE ("The Final Ethernet") unit

-tfeif <name>
     Set the system ethernet interface for TFE emulation

-tferrnet
+tferrnet
     Enable/Disable RRNet mode of TFE emulation

-burstmod <value>
     Enable/Disable burst modification. If it's 1 the cable is
     connected to CIA1, if 2 then to CIA2 and 0 disables it. This is
     emulates the fast serial bus connection as described at
     http://www.cs.tut.fi/~albert/Dev/burst/, with the wire to the
     tape port cut. 


@EndNode

@Node "C64-128 system ROM settings" "vice.guide/C64-128 system ROM settings"
@Prev "C64 I-O extension settings"
@Toc "C64-128-specific"

C64/128 system ROM settings
----------------------------

    These settings can be used to control what system ROMs are loaded
in the C64/128 emulators at startup.  They cannot be changed from the
menus. 

   * C64/128 system ROM resources:: * C64/128 system ROM options::
menu 


@EndNode

@Node "C64-128 system ROM resources" "vice.guide/C64-128 system ROM resources"
@Next "C64-128 system ROM options"
@Prev "C64-128 system ROM settings"
@Toc "C64-128 system ROM settings"

C64/128 system ROM resources
.............................

   
     

KernalName
     String specifying the name of the Kernal ROM (default `kernal').
     

BasicName
     String specifying the name of the Basic ROM (default `basic').
     In the C128 emulator, the ROM image must actually include the
     editor ROM too. 

ChargenName
     String specifying the name of the character generator ROM
     (default `chargen'). 

KernalRev
     String specifying the Kernal revision.  This resource can be used
     to control what revision of the C64 kernal is being used; it
     cannot be changed at runtime.  VICE is able to automatically
     convert one ROM revision into another, by manually patching the
     loaded image.  This way, it is possible to use any of the ROM
     revisions without changing the ROM set.  Valid values are: 
    0
          Kernal revision 0;

    3
          Kernal revision 3;

    sx
    67
          Commodore SX-64 ROM;

    100
    4064
          Commodore 4064 (also known as "PET64" or "Educator 64") ROM.
     

RomsetKernalName
RomsetBasicName
RomsetChargenName
     Integers [0]  


@EndNode

@Node "C64-128 system ROM options" "vice.guide/C64-128 system ROM options"
@Prev "C64-128 system ROM resources"
@Toc "C64-128 system ROM settings"

C64/128 system ROM command-line options
........................................

   
     

-kernal NAME
     Specify `NAME' as the Kernal ROM file (`KernalName'). 

-basic NAME
     Specify `NAME' as the Basic ROM file (`BasicName'). 

-chargen NAME
     Specify `NAME' as the character generator ROM file
     (`ChargenName'). 

-kernalrev REVISION
     Specify Kernal revision (`KernalRev').  

C64 settings
-------------

   

C64 resources
..............

   
     

GlueLogic
     Integer specifying the type of emulated glue-log. (0: discrete, 1:
     custom IC) 

BurstMod
     Boolean, enable/disable the Burst-Mode modification. 

PLUS60K
     Boolean, enable/disable the PLUS60K RAM expansion

PLUS60Kfilename
     String specifying the filename of the PLUS60K RAM image.

PLUS60Kbase
     Integer that specifies the base address of the PLUS60K RAM
     expansion. 

PLUS256K
     Boolean, enable/disable the PLUS256K RAM expansion

PLUS256Kfilename
     String specifying the filename of the PLUS256K RAM image. 

C64_256K
     Boolean, enable/disable the 256K RAM expansion

C64_256Kfilename
     String specifying the filename of the 256K RAM image.

C64_256Kbase
     Integer that specifies the base address of the 256K RAM
     expansion.  

C64 command-line options
.........................

   
     

-gluelogictype <type>
     Set glue logic type (0 = discrete, 1 = 252535-01) 

-plus60k
+plus60k
     Enable/Disable the PLUS60K RAM expansion

-plus60kimage <name>
     Specify name of PLUS60K image

-plus60kbase <base address>
     Base address of the PLUS60K expansion 

-plus256k
+plus256k
     Enable/Disable the PLUS256K RAM expansion

-plus256kimage <name>
     Specify name of PLUS256K image 

-256k
+256k
     Enable/Disable the 256K RAM expansion

-256kimage <name>
     Specify name of 256K image

-256kbase <base address>
     Base address of the 256K expansion  

C128-specific commands and settings
====================================

   

VDC settings
-------------

   

VDC resources
..............

   
     

VDC64KB
     Boolean, enabled full 64k video ram.

VDCRevision
     Integer specifying the VDC hardware revision. (0: Rev 0, 1: Rev 1,
     2: Rev 2) 

VDCVideoCache
     Boolean specifying whether the video cache is turned on. 

VDCDoubleSize
     Boolean specifying whether double-size mode is turned on. 

VDCDoubleScan
     Boolean specifying whether double-scan mode is turned on. 

VDCStretchVertical
     Boolean specifying whether vertical stretching is turned on. 

VDCPaletteFile
     String specifying the name of the palette file being used.  The
     `.vpl' extension is optional. 

VDCHwScale
     Boolean specifying whether to enable or disable hardware scaling
     

VDCFullscreenDevice
     fullscreen device 

VDCFullscreen
     Boolean specifying whether to use fullscreen mode or not. 

VDCFullscreenStatusbar
     Boolean specifying whether to show the status bar in fullscreen
     mode or not. 

VDCXRANDRFullscreenMode
     integer specifying XRANDR fullscreen mode 

VDCVidmodeFullscreenMode
     integer specifying Vidmode fullscreen mode 

VDCExternalPalette
     Boolean specifying whether to use external palette file or not.
     

VDCColorSaturation
     integer specifying saturation of internal calculated palette
     [1000] <0-2000> 

VDCColorContrast
     integer specifying contrast of internal calculated palette [1000]
     <0-2000> 

VDCColorBrightness
     integer specifying brightness of internal calculated palette
     [1000] <0-2000> 

VDCColorGamma
     integer specifying gamma of internal calculated palette [2200]
     <0-4000> 

VDCColorTint
     integer specifying tint of internal calculated palette [1000]
     <0-2000> 

VDCPALScanLineShade
     integer specifying amount of scan line shading for the CRT
     emulation [667] <0-1000> 

VDCPALBlur
     integer specifying amount of horizontal blur for the CRT
     emulation. [500] <0-1000> 

VDCPALOddLinePhase
     integer specifying phase offset for color carrier in odd lines
     [750] <0-2000> 

VDCPALOddLineOffset
     integer specifying phase for color carrier in odd lines [1250]
     <0-2000> 

VDCAudioLeak
     Boolean specifying whether to enable/disable video to audio leak
     emulation. 

VDCFilter
     integer specifying rendering filter, 0:none, 1:CRT emulation, 2:
     scale2x 

VDC command-line options
.........................

   
-VDCvcache
+VDCvcache
     Enable/Disable the video cache

-VDCdsize
+VDCdsize
     Enable/Disable double size

-VDCstretchvertical
+VDCstretchvertical
     Enable/Disable vertical stretching

-VDCdscan
+VDCdscan
     Enable/Disable double scan

-VDChwscale
+VDChwscale
     Enable/Disable hardware scaling

-VDCintpal
     Use an internal calculated palette

-VDCextpal
     Use an external palette (file)

-VDCpalette <name>
     Specify name of file of external palette

-VDCfulldevice <device>
     Select fullscreen device

-VDCXRANDRfullmode <mode>
     Select fullscreen mode

-VDCVidmodefullmode <mode>
     Select fullscreen mode

-VDC16KB
     Set the VDC memory size to 16KB

-VDC64KB
     Set the VDC memory size to 64KB

-VDCRevision <number>
     Set VDC revision (0..2) 

-VDCsaturation <0-2000>
     Set saturation of internal calculated palette [1000]

-VDCcontrast <0-2000>
     Set contrast of internal calculated palette [1000]

-VDCbrightness <0-2000>
     Set brightness of internal calculated palette [1000]

-VDCgamma <0-4000>
     Set gamma of internal calculated palette [2200]

-VDCtint <0-2000>
     Set tint of internal calculated palette [1000]

-VDCoddlinesphase <0-2000>
     Set phase for color carrier in odd lines [1250]

-VDCoddlinesoffset <0-2000>
     Set phase offset for color carrier in odd lines [750]

-VDCcrtblur <0-1000>
     Amount of horizontal blur for the CRT emulation. [500]

-VDCcrtscanlineshade <0-1000>
     Amount of scan line shading for the CRT emulation [667] 

-VDCaudioleak
+VDCaudioleak
     Enable/Disable video to audio leak emulation.  

C128 system ROM settings
-------------------------

   

C128 system ROM resources
..........................

   
     

ChargenIntName
ChargenDEName
ChargenFRName
ChargenSEName
     Strings specifying the filename of the Chargen ROM images. 

KernalIntName
KernalDEName
KernalFIName
KernalFRName
KernalITName
KernalNOName
KernalSEName
     Strings specifying the filename of the Kernal ROM images. 

BasicLoName
BasicHiName
     Strings specifying the filename of the Basic ROM images. 

Kernal64Name
     String specifying the filename of the C64 kernal ROM image.

Basic64Name
     String specifying the filename of the C64 basic ROM image. 

InternalFunctionROM
     Boolean, enables the internal function ROM.

InternalFunctionName
     Strings specifying the filename of the ROM image for the internal
     function ROM. 

ExternalFunctionROM
     Boolean, enables the external function ROM.

ExternalFunctionName
     Strings specifying the filename of the ROM image for the external
     function ROM. 

RomsetChargenIntName
RomsetChargenDEName
RomsetChargenFRName
RomsetChargenSEName
RomsetKernalIntName
RomsetKernalDEName
RomsetKernalFIName
RomsetKernalFRName
RomsetKernalITName
RomsetKernalNOName
RomsetKernalSEName
RomsetBasicLoName
RomsetBasicHiName
RomsetKernal64Name
RomsetBasic64Name
     Integers [0]  

C128 system ROM command-line options
.....................................

   
     

-basic64 <name>
     Specify name of C64 mode BASIC ROM image

-kernal64 <name>
     Specify name of C64 mode Kernal ROM image 

-basiclo <name>
     Specify name of BASIC ROM image (lower part)

-basichi <name>
     Specify name of BASIC ROM image (higher part) 

-kernal <name>
     Specify name of international Kernal ROM image

-kernalde <name>
     Specify name of German Kernal ROM image

-kernalfi <name>
     Specify name of Finnish Kernal ROM image

-kernalfr <name>
     Specify name of French Kernal ROM image

-kernalit <name>
     Specify name of Italian Kernal ROM image

-kernalno <name>
     Specify name of Norwegian Kernal ROM image

-kernalse <name>
     Specify name of Swedish Kernal ROM image 

-chargen <name>
     Specify name of international character generator ROM image

-chargde <name>
     Specify name of German character generator ROM image

-chargfr <name>
     Specify name of French character generator ROM image

-chargse <name>
     Specify name of Swedish character generator ROM image 

-intfunc
+intfunc
     Enable/Disable the internal Function ROM

-intfrom <name>
     Specify name of internal Function ROM image 

-extfunc
+extfunc
     Enable/Disable the external Function ROM

-extfrom <name>
     Specify name of external Function ROM image  

C128 settings
--------------

   

C128 resources
...............

   
     

40/80ColumnKey
     Boolean, status of the 40/80 columns key

Go64Mode
     Boolean, if true enter C64 mode on reset

C128FullBanks
     Boolean, enables Banks 2 and 3.

MachineType
     Integer specifying the C128 machine type. (0: Internatinal, 1:
     Finnish, 2: French, 3: German, 4: Italian, 5: Norwegian, 6:
     Swedish) 

C128 command-line options
..........................

   
     

-40col
     Activate 40 column mode

-80col
     Activate 80 column mode 

-go64
     Always switch to C64 mode on reset

+go64
     Always switch to C128 mode on reset  


@EndNode

@Node "C64DTV-specific" "vice.guide/C64DTV-specific"
@Next "VIC20-specific"
@Prev "C64-128-specific"
@Toc "Machine-specific features"

C64DTV-specific commands and settings
======================================

    This section lists the settings and commands that are C64DTV
specific and thus are not present in the other emulators. 

   * C64DTV ROM image:: * DTV revision:: * LumaFix:: *
Userport:: * Debug:: * Monitor DTV features::  menu  


@EndNode

@Node "C64DTV ROM image" "vice.guide/C64DTV ROM image"
@Next "DTV revision"
@Prev "C64DTV-specific"
@Toc "C64DTV-specific"

C64DTV ROM image
-----------------

    The DTV has a 2MB Flash chip which contains the kernal, basic
and character set ROMs along with other data, such as games in the
case of the original C64DTV ROM.  The image file is a dump of the
flash chip. It is exactly 2MB (2097152 bytes).  If you do not have
a suitable image file, an image using the C64 kernal, basic and
charset is automatically created.  If writing to the C64DTV ROM is
enabled, the image file is rewritten with the current data when
exiting x64dtv.  Note that x64dtv tries to load the image file from
the C64DTV directory first, and if it isn't found there, x64dtv tries
to load it from the current directory. If you do not have
`dtvrom.bin' in your C64DTV directory and writing to DTV ROM is
enabled, the `dtvrom.bin' file is created to the current directory.
 NOTE: The original C64DTV ROM has somewhat distorted colors,
normally you should use a patched rom. 
     

-c64dtvromimage NAME
     Specify `NAME' as the C64DTV ROM image 

-c64dtvromrw
+c64dtvromrw
     Enable or disable writing to C64DTV ROM image   The
trueflashfs option is analogous to True drive emulation.  If disabled,
any file access to the flash filesystem (device 1) will go to the
local file system instead. 
     

-trueflashfs
+trueflashfs
     Enable or disable true hardware flash file system 

-fsflash NAME
     Specify `NAME' as directory for flash file system device   


@EndNode

@Node "DTV revision" "vice.guide/DTV revision"
@Next "LumaFix"
@Prev "C64DTV ROM image"
@Toc "C64DTV-specific"

DTV revision
-------------

    The DTV revision 2 has a bug in the Blitter. Using revision 3
is recommended. Emulation of DTV revision 2 including Blitter bug is
intended for testing DTV software. 
     

-dtvrev REVISION
     Specify DTV `REVISION' (2 or 3)   


@EndNode

@Node "LumaFix" "vice.guide/LumaFix"
@Next "Userport"
@Prev "DTV revision"
@Toc "C64DTV-specific"

LumaFix
--------

    The PAL C64DTVs have wrong resistors in the video output
circuit, which causes incorrect luminances. Several hardware
solutions ("LumaFixes") have been developed to fix this flaw. 
The fixed video output is emulated by selecting "New Luminances". The
unmodified C64DTV video output can be emulated with "Old Luminances".
 The default setting is "New Luminances".  


@EndNode

@Node "Userport" "vice.guide/Userport"
@Next "Debug"
@Prev "LumaFix"
@Toc "C64DTV-specific"

Userport
---------

    The C64DTV userport emulation currently supports three devices:
Hummer ADC, userport joystick and PS/2 mouse.  The joystick that
controls either the Hummer ADC or userport joystick can be selected
using the same parameter or menu option.  While using the Hummer
ADC, joystick UP and DOWN are mapped to the Hummer buttons A and B
respectively. LEFT and RIGHT set the ADCs output to 0 and 255.
Centering the joystick results in the ADC value of 128.  Currently
the Hummer ADC and userport joystick are mutually exclusive. This
means that enabling one disables the other. PS/2 mouse emulation can
be used simultaneously with either Hummer ADC or userport joystick. 
     

-hummeradc
+hummeradc
     Enable/Disable Hummer ADC 

-ps2mouse
+ps2mouse
     Enable or disable PS/2 mouse on userport   


@EndNode

@Node "Debug" "vice.guide/Debug"
@Next "Monitor DTV features"
@Prev "Userport"
@Toc "C64DTV-specific"

Debug
------

    Debugging information on Blitter, DMA and Flash can be enabled
with command line parameters. This can be useful for DTV software
development. 
     

-dtvblitterlog
+dtvblitterlog
     Enable or disable DTV Blitter log 

-dtvdmalog
+dtvdmalog
     Enable or disable DTV DMA log 

-dtvflashlog
+dtvflashlog
     Enable or disable DTV Flash log   


@EndNode

@Node "Monitor DTV features" "vice.guide/Monitor DTV features"
@Prev "Debug"
@Toc "C64DTV-specific"

Monitor DTV features
---------------------

    Currently the registers A, Y and X are registers R0, R1 and R2
regardless of the mapping, which can be seen and modified via the
registers ACM and XYM.  The monitor can access all 2MB of RAM and
2MB of Flash, but only 64 kB at a time. The 64kB bank can be selected
with "bank ram00".."ram1f" for RAM and "bank rom00".."rom1f" for
Flash.  The "load" command can load large files (>64kB) correctly
if the bank is set to "ramXX", where XX is the starting bank (usually
"bank00"). 

DTV resources
--------------

   
     

DtvRevision
     Integer specifying the emulated DTV revision (2: DTV2, 3: DTV3)
     

c64dtvromfilename
     String specifying the filename of the DTV Flash ROM image.

c64dtvromrw
     Boolean that specifies whether the emulated Flash ROM is
     writeable.

FSFlashDir
     String specifying the working directory for the flash file
     system.

FlashTrueFS
     Boolean, enables true hardware flash file system. 

HummerADC
     Boolean, enables Hummer ADC emulation. 

ps2mouse
     Boolean, enables PS/2 Mouse emulation. 

DtvBlitterLog
     Boolean, enables Blitter logging.

DtvDMALog
     Boolean, enables DMA logging.

DtvFlashLog
     Boolean, enables Flash ROM logging.  


@EndNode

@Node "VIC20-specific" "vice.guide/VIC20-specific"
@Next "PET-specific"
@Prev "C64DTV-specific"
@Toc "Machine-specific features"

VIC20-specific commands and settings
=====================================

    This section lists the settings and commands that are
VIC20-specific and thus are not present in the other emulators. 

   * VIC20 cartridges:: * VIC20 memory expansions:: * VIC20 system
ROM settings::  menu  


@EndNode

@Node "VIC20 cartridges" "vice.guide/VIC20 cartridges"
@Next "VIC20 memory expansions"
@Prev "VIC20-specific"
@Toc "VIC20-specific"

Using cartridge images
-----------------------

    As with the C64 (see @{"C64 cartridges" Link "C64 cartridges"}), it is possible to attach
several types of cartridge images: 
     4 or 8 Kbyte cartridges located at $2000;

     4 or 8 Kbyte cartridges located at $4000;

     4 or 8 Kbyte cartridges located at $6000;

     4 or 8 Kbyte cartridges located at $A000;

     4 Kbyte cartridges located at $B000.  This can all be done via
the "Attach cartridge image..." command in the left-button menu.  It
is also possible to let xvic "guess" the type of cartridge using
"Smart-attach cartridge image...".  Notice that several cartridges
are actually made up of two pieces (and two files), that need to be
loaded separately at different addresses. In that case, you have to
know the addresses (which are usually specified in the file name) and
use the "attach" command twice.  A special kind of cartridge file
is where the two files mentioned above are concatenated (with
removing the two byte load address of the second image) into one 16k
image. There are only few of those images, though. Normally the
second part is located at $A000. Vice can now attach such
concatenated files at the start address $2000, $4000, and $6000. The
second half of such an image is moved to $A000. If you encounter 16k
images that have the second half not at $A000 you can split the image
into two halfs (i.e. one 8194 byte and one 8192 byte, because the
first has the load address) and attach both files separately. 
One cartridge that is currently only partially supported here is the
VIC1112 IEEE488 interface. You have to load the ROM as a cartridge,
but you also have to enable the IEEE488 hardware by menu. 

VIC20 cartridge settings
-------------------------

   

VIC20 cartridge resources
..........................

   
     

CartridgeReset
     Boolean specifying whether the machine should be resetted when a
     cartridge is changed.

CartridgeType
     Integer specifying the type of cartridge emulated.

CartridgeFile
     String specifying the filename of the image for the current
     cartridge. 

IOCollisionHandling
     Integer specifying the way the I/O collisions should be handled,
     (0: error message and  detach all involved carts, 1: error
     message and detach last attached involved  carts, 2: warning in
     log and 'AND' the valid return values) 

GenericCartridgeFile2000
GenericCartridgeFile4000
GenericCartridgeFile6000
GenericCartridgeFileA000
GenericCartridgeFileB000
     String specifying the name of the respective cartridge ROM
     images. 

FinalExpansionWriteBack
     Boolean, if true write back the Flash ROM image file
     automatically, incase the contents changed, when detaching or
     quitting the emulator. 

VicFlashPluginWriteBack
     Boolean, if true write back the Flash ROM image file
     automatically, incase the contents changed, when detaching or
     quitting the emulator. 

MegaCartNvRAMfilename
     String specifying the filename of the MegaCart NvRAM image.

MegaCartNvRAMWriteBack
     Boolean, if true write back the NvRAM image file automatically,
     incase the RAM contents changed, when detaching or quitting the
     emulator. 

TFEIOSwap
     Boolean, swap/don't swap io mapping (map cart I/O to VIC20 I/O-2)

SFXSoundExpanderIOSwap
     Boolean, swap/don't swap io mapping (map cart I/O to VIC20 I/O-2)

SFXSoundSamplerIOSwap
     Boolean, swap/don't swap io mapping (map cart I/O to VIC20 I/O-2)

GEORAMIOSwap
     Boolean, swap/don't swap  io mapping (map cart I/O-1 to VIC20
     I/O-3 and cart I/O-2 to VIC20 I/O-2) 

SidCart
     Boolean, enables SID cart emulation.

SidAddress
     Integer that specifies the base address of the emulated SID chip.

SidClock
     Integer specifying the clock rate used for the emulated SID chip
     (0: C64, 1: VIC-20)  

VIC20 cartridge command-line options
.....................................

   
     

-iocollision <method>
     Select the way the I/O collisions should be handled, (0: error
     message and  detach all involved carts, 1: error message and
     detach last attached involved  carts, 2: warning in log and
     'AND' the valid return values 

-cart2 <name>
     Specify 4/8/16K extension ROM name at $2000

-cart4 <name>
     Specify 4/8/16K extension ROM name at $4000

-cart6 <name>
     Specify 4/8/16K extension ROM name at $6000

-cartA <name>
     Specify 4/8K extension ROM name at $A000

-cartB <name>
     Specify 4K extension ROM name at $B000

-cartgeneric <name>
     Specify generic extension ROM name 

-cartmega <name>
     Specify Mega-Cart extension ROM name

-mcnvramfile <name>
     Set Mega-Cart NvRAM filename

-mcnvramwriteback
+mcnvramwriteback
     Enable/Disable Mega-Cart NvRAM writeback 

-cartfe <name>
     Specify Final Expansion extension ROM name

-fewriteback
+fewriteback
     Enable/Disable Final Expansion write back to ROM file 

-cartfp <name>
     Specify Vic Flash Plugin extension ROM name

-fpwriteback
+fpwriteback
     Enable/Disable Vic Flash Plugin write back to ROM file 

-ieee488
+ieee488
     Enable/Disable VIC-1112 IEEE488 interface 

-sidcart
+sidcart
     Enable/Disable SID Cartridge 

-tfeioswap
+tfeioswap
     Swap/don't swap io mapping (map cart I/O to VIC20 I/O-2)

-tfe
+tfe
     Enable/Disable the TFE ("The Final Ethernet") unit

-tfeif <name>
     Set the system ethernet interface for TFE emulation

-tferrnet
+tferrnet
     Enable/Disable RRNet mode of TFE emulation 

-digimax
+digimax
     Enable/Disable the DigiMAX cartridge

-digimaxbase <base address>
     Base address of the DigiMAX cartridge 

-sfxseioswap
+sfxseioswap
     Swap/don't swap io mapping (map cart I/O to VIC20 I/O-2)

-sfxse
+sfxse
     Enable/Disable the SFX soundexpander cartridge

-sfxsetype <type>
     Set YM chip type (3526 / 3812) 

-sfxssioswap
+sfxssioswap
     Swap/don't swap io mapping (map cart I/O to VIC20 I/O-2)

-sfxss
+sfxss
     Enable/Disable the SFX Sound Sampler cartridge 

-georamioswap
+georamioswap
     Swap/don't swap  io mapping (map cart I/O-1 to VIC20 I/O-3 and
     cart I/O-2 to VIC20 I/O-2)

-georam
+georam
     Enable/Disable the GEORAM expansion unit

-georamimage <name>
     Specify name of GEORAM image

-georamimagerw
+georamimagerw
     Allow/Disallow writing to GEORAM image

-georamsize <size in KB>
     Size of the GEORAM expansion unit  

VIC settings
-------------

   

VIC resources
..............

   
     

VICVideoCache
     Boolean specifying whether the video cache is turned on. 

VICDoubleSize
     Boolean specifying whether double-size mode is turned on. 

VICDoubleScan
     Boolean specifying whether double-scan mode is turned on. 

VICPaletteFile
     String specifying the name of the palette file being used.  The
     `.vpl' extension is optional. 

VICHwScale
     Boolean specifying whether to enable or disable hardware scaling
     

VICFullscreenDevice
     fullscreen device 

VICFullscreen
     Boolean specifying whether to use fullscreen mode or not. 

VICFullscreenStatusbar
     Boolean specifying whether to show the status bar in fullscreen
     mode or not. 

VICXRANDRFullscreenMode
     integer specifying XRANDR fullscreen mode 

VICVidmodeFullscreenMode
     integer specifying Vidmode fullscreen mode 

VICExternalPalette
     Boolean specifying whether to use external palette file or not.
     

VICColorSaturation
     integer specifying saturation of internal calculated palette
     [1000] <0-2000> 

VICColorContrast
     integer specifying contrast of internal calculated palette [1000]
     <0-2000> 

VICColorBrightness
     integer specifying brightness of internal calculated palette
     [1000] <0-2000> 

VICColorGamma
     integer specifying gamma of internal calculated palette [2200]
     <0-4000> 

VICColorTint
     integer specifying tint of internal calculated palette [1000]
     <0-2000> 

VICPALScanLineShade
     integer specifying amount of scan line shading for the CRT
     emulation [667] <0-1000> 

VICPALBlur
     integer specifying amount of horizontal blur for the CRT
     emulation. [500] <0-1000> 

VICPALOddLinePhase
     integer specifying phase offset for color carrier in odd lines
     [750] <0-2000> 

VICPALOddLineOffset
     integer specifying phase for color carrier in odd lines [1250]
     <0-2000> 

VICAudioLeak
     Boolean specifying whether to enable/disable video to audio leak
     emulation. 

VICFilter
     integer specifying rendering filter, 0:none, 1:CRT emulation, 2:
     scale2x 

VICBorderMode
     integer specifying border display mode (0: normal, 1: full, 2:
     debug, 3:none)  

VIC command-line options
.........................

   
     

-VICvcache
+VICvcache
     Enable/disable the video cache (`VICVideoCache=1',
     `VICVideoCache=0'). 

-VICdsize
+VICdsize
     Enable/disable the double size mode (`VICDoubleSize=1',
     `VICDoubleSize=0'). 

-VICdscan
+VICdscan
     Enable/disable the double scan mode (`VICDoubleScan=1',
     `VICDoubleScan=0'). 

-VIChwscale
+VIChwscale
     Enable/Disable hardware scaling 

-VICfilter <Mode>
     Select rendering filter, 0:none, 1:CRT emulation, 2: scale2x 

-VICpalette NAME
     Specify `NAME' as the palette file (`VICPaletteFile'). 

-VICintpal
     Use an internal calculated palette

-VICextpal
     Use an external palette (file)

-VICfulldevice <device>
     Select fullscreen device

-VICXRANDRfullmode <mode>
     Select fullscreen mode

-VICVidmodefullmode <mode>
     Select fullscreen mode

-VICborders <mode>
     Set VIC border display mode (0: normal, 1: full, 2: debug,
     3:none) 

-VICsaturation <0-2000>
     Set saturation of internal calculated palette [1000]

-VICcontrast <0-2000>
     Set contrast of internal calculated palette [1000]

-VICbrightness <0-2000>
     Set brightness of internal calculated palette [1000]

-VICgamma <0-4000>
     Set gamma of internal calculated palette [2200]

-VICtint <0-2000>
     Set tint of internal calculated palette [1000]

-VICoddlinesphase <0-2000>
     Set phase for color carrier in odd lines [1250]

-VICoddlinesoffset <0-2000>
     Set phase offset for color carrier in odd lines [750]

-VICcrtblur <0-1000>
     Amount of horizontal blur for the CRT emulation. [500]

-VICcrtscanlineshade <0-1000>
     Amount of scan line shading for the CRT emulation [667] 

-VICaudioleak
+VICaudioleak
     Enable/Disable video to audio leak emulation.   


@EndNode

@Node "VIC20 memory expansions" "vice.guide/VIC20 memory expansions"
@Next "VIC20 system ROM settings"
@Prev "VIC20 cartridges"
@Toc "VIC20-specific"

Changing memory configuration
------------------------------

    It is possible to change the VIC20 memory configuration in two
ways: by enabling and/or disabling certain individual memory blocks,
or by choosing one among a few typical memory configurations.  The
former can be done by modifying resource values directly or from the
right-button menu; the latter can only be done from the menu. 
There are 5 RAM expansion blocks in the VIC20, numbered 0, 1, 2, 3 and
5: 
     block 0 (3 Kbytes at $0400-$0FFF);

     block 1 (8 Kbytes at $2000-$3FFF);

     block 2 (8 Kbytes at $4000-$5FFF);

     block 3 (8 Kbytes at $6000-$7FFF);

     block 5 (8 Kbytes at $A000-$BFFF).  These blocks are called
"expansion blocks" because they are not present a stock
("unexpanded") machine.  Each of them is associated to a boolean
`RamBlockX' resource (where `X' is the block number) that specifies
whether the block is enabled or not.  There are also some common
memory configurations you can pick from the right-button menu: 
     no RAM expansion blocks at all;

     all RAM expansion blocks enabled;

     3K expansion (only block 0 is enabled);

     8K expansion (only block 1 is enabled);

     16K expansion (only blocks 1 and 2 are enabled);

     24K expansion (only blocks 1, 2 and 3 are enabled). 

   * VIC20 memconf resources:: * VIC20 memconf options::  menu 


@EndNode

@Node "VIC20 memconf resources" "vice.guide/VIC20 memconf resources"
@Next "VIC20 memconf options"
@Prev "VIC20 memory expansions"
@Toc "VIC20 memory expansions"

VIC20 memory configuration resources
.....................................

   
     

RAMBlock0
RAMBlock1
RAMBlock2
RAMBlock3
RAMBlock5
     Booleans specifying whether RAM blocks 0, 1, 2, 3 and 5 must be
     enabled.  


@EndNode

@Node "VIC20 memconf options" "vice.guide/VIC20 memconf options"
@Prev "VIC20 memconf resources"
@Toc "VIC20 memory expansions"

VIC20 memory configuration command-line options
................................................

   
     

-memory CONFIG
     Specify memory configuration.  It must be a comma-separated list
     of options, each of which can be one the following: 
          `none' (no extension);

          `all' (all blocks);

          `3k' (3k space in block 0);

          `8k' (first 8k extension block);

          `16k' (first and second 8k extension blocks);

          `24k' (first, second and 3rd extension blocks);

          `0', `1', `2', `3', `5' (memory in respective blocks);

          `04', `20', `40', `60', `A0' (memory at respective
          address.  For example, 

     xvic -memory none  gives an unexpanded VIC20.  While 

   xvic -memory 60,a0  example  or 

   xvic -memory 3,5  example  enables memory in blocks 3 and 5,
which is the usual configuration for 16k ROM modules.   table 



@EndNode

@Node "VIC20 system ROM settings" "vice.guide/VIC20 system ROM settings"
@Prev "VIC20 memory expansions"
@Toc "VIC20-specific"

VIC20 system ROM settings
--------------------------

    These settings can be used to control what system ROMs are loaded
in the VIC20 emulator at startup.  They cannot be changed from the
menus. 

   * VIC20 system ROM resources:: * VIC20 system ROM options::
menu 


@EndNode

@Node "VIC20 system ROM resources" "vice.guide/VIC20 system ROM resources"
@Next "VIC20 system ROM options"
@Prev "VIC20 system ROM settings"
@Toc "VIC20 system ROM settings"

VIC20 system ROM resources
...........................

   
     

KernalName
     String specifying the name of the Kernal ROM (default `kernal').
     

BasicName
     String specifying the name of the Basic ROM (default `basic'). 

ChargenName
     String specifying the name of the character generator ROM
     (default `chargen').  


@EndNode

@Node "VIC20 system ROM options" "vice.guide/VIC20 system ROM options"
@Prev "VIC20 system ROM resources"
@Toc "VIC20 system ROM settings"

VIC20 system ROM command-line options
......................................

   
     

-kernal NAME
     Specify `NAME' as the Kernal ROM file (`KernalName'). 

-basic NAME
     Specify `NAME' as the Basic ROM file (`BasicName'). 

-chargen NAME
     Specify `NAME' as the character generator ROM file
     (`ChargenName'). 

-cart2 NAME
-cart4 NAME
-cart6 NAME
-cartA NAME
-cartB NAME
     Specify `NAME' as the cartridge image to attach.
     (`CartridgeFile2000',...,`CartridgeFileB000').  

VIC20 settings
---------------

   

VIC20 command-line options
...........................

   
     

-OEMjoy
+OEMjoy
     Enable/Disable the OEM userport joystick adapter  

PLUS4-specific commands and settings
=====================================

   

TED settings
-------------

   

TED resources
..............

   
TEDVideoCache
     Boolean specifying whether the video cache is turned on. 

TEDDoubleSize
     Boolean specifying whether double-size mode is turned on. 

TEDDoubleScan
     Boolean specifying whether double-scan mode is turned on. 

TEDPaletteFile
     String specifying the name of the palette file being used.  The
     `.vpl' extension is optional. 

TEDHwScale
     Boolean specifying whether to enable or disable hardware scaling
     

TEDFullscreenDevice
     fullscreen device 

TEDFullscreen
     Boolean specifying whether to use fullscreen mode or not. 

TEDFullscreenStatusbar
     Boolean specifying whether to show the status bar in fullscreen
     mode or not. 

TEDXRANDRFullscreenMode
     integer specifying XRANDR fullscreen mode 

TEDVidmodeFullscreenMode
     integer specifying Vidmode fullscreen mode 

TEDExternalPalette
     Boolean specifying whether to use external palette file or not.
     

TEDColorSaturation
     integer specifying saturation of internal calculated palette
     [1000] <0-2000> 

TEDColorContrast
     integer specifying contrast of internal calculated palette [1000]
     <0-2000> 

TEDColorBrightness
     integer specifying brightness of internal calculated palette
     [1000] <0-2000> 

TEDColorGamma
     integer specifying gamma of internal calculated palette [2200]
     <0-4000> 

TEDColorTint
     integer specifying tint of internal calculated palette [1000]
     <0-2000> 

TEDPALScanLineShade
     integer specifying amount of scan line shading for the CRT
     emulation [667] <0-1000> 

TEDPALBlur
     integer specifying amount of horizontal blur for the CRT
     emulation. [500] <0-1000> 

TEDPALOddLinePhase
     integer specifying phase offset for color carrier in odd lines
     [750] <0-2000> 

TEDPALOddLineOffset
     integer specifying phase for color carrier in odd lines [1250]
     <0-2000> 

TEDAudioLeak
     Boolean specifying whether to enable/disable video to audio leak
     emulation. 

TEDFilter
     integer specifying rendering filter, 0:none, 1:CRT emulation, 2:
     scale2x 

TEDBorderMode
     integer specifying border display mode (0: normal, 1: full, 2:
     debug, 3:none)  

TED command-line options
.........................

   
-TEDvcache
+TEDvcache
     Enable/Disable the video cache

-TEDdsize
+TEDdsize
     Enable/Disable double size

-TEDdscan
+TEDdscan
     Enable/Disable double scan

-TEDfilter <Mode>
     Select rendering filter, 0:none, 1:CRT emulation, 2: scale2x

-TEDhwscale
+TEDhwscale
     Enable/Disable hardware scaling

-TEDintpal
     Use an internal calculated palette

-TEDextpal
     Use an external palette (file)

-TEDpalette <name>
     Specify name of file of external palette

-TEDfulldevice <device>
     Select fullscreen device

-TEDXRANDRfullmode <mode>
     Select fullscreen mode

-TEDVidmodefullmode <mode>
     Select fullscreen mode

-TEDborders <mode>
     Set TED border display mode (0: normal, 1: full, 2: debug,
     3:none) 

-TEDsaturation <0-2000>
     Set saturation of internal calculated palette [1000]

-TEDcontrast <0-2000>
     Set contrast of internal calculated palette [1000]

-TEDbrightness <0-2000>
     Set brightness of internal calculated palette [1000]

-TEDgamma <0-4000>
     Set gamma of internal calculated palette [2200]

-TEDtint <0-2000>
     Set tint of internal calculated palette [1000]

-TEDoddlinesphase <0-2000>
     Set phase for color carrier in odd lines [1250]

-TEDoddlinesoffset <0-2000>
     Set phase offset for color carrier in odd lines [750]

-TEDcrtblur <0-1000>
     Amount of horizontal blur for the CRT emulation. [500]

-TEDcrtscanlineshade <0-1000>
     Amount of scan line shading for the CRT emulation [667] 

-TEDaudioleak
+TEDaudioleak
     Enable/Disable video to audio leak emulation.  

PLUS4 I/O extension settings
-----------------------------

   

PLUS4 I/O extension resources
..............................

   
     

CartridgeReset
     Boolean specifying whether the machine should be resetted when a
     cartridge is changed. 

DIGIBLASTER
     Boolean, enables Digiblaster emulation. 

SpeechEnabled
     Boolean, enables emulation of the V364 speech chip.

SpeechImage
     String specifying the filename of the speech ROM image. 

SidCart
     Boolean, enables emulation of the SID-Cart

SidAddress
     Integer that specifies the base address of the emulated SID chip.

SidClock
     Integer specifying the clock rate used for the emulated SID chip
     (0: C64, 1: Plus4)

SIDCartJoy
     Boolean, enables emulation of the SID-Cart joystick  

PLUS4 I/O extension command-line options
.........................................

   
     

-cartreset
+cartreset
     Do/don't reset machine if a cartridge is attached or detached

-cart <Name>
     Smart-attach cartridge image

+cart
     Disable default cartridge 

-digiblaster
+digiblaster
     Enable/Disable the digiblaster add-on 

-sidcart
+sidcart
     Enable/Disable SID Cartridge 

-sidcartjoy
+sidcartjoy
     Enable/Disable SID cartridge joystick 

-speech
+speech
     Enable/Disable the v364 speech add-on 

-speechrom <name>
     Attach Speech ROM image  

PLUS4 system ROM settings
--------------------------

   

PLUS4 system ROM resources
...........................

   
     

FunctionLowName
     String specifying the filenames of the Lo Function ROM.

FunctionHighName
     String specifying the filenames of the High Function ROM. 

c1loName
     String specifying the filenames of cartridge 1 Lo ROM.

c1hiName
     String specifying the filenames of cartridge 1 High ROM.

c2loName
     String specifying the filenames of cartridge 2 Lo ROM.

c2hiName
     String specifying the filenames of cartridge 2 High ROM. 

RomsetFunctionLowName
RomsetFunctionHighName
     Integers [0]  

PLUS4 system ROM command-line options
......................................

   
     

-functionlo <name>
     Specify name of Function low ROM image

-functionhi <name>
     Specify name of Function high ROM image 

-c1lo <name>
     Specify name of Cartridge 1 low ROM image

-c1hi <name>
     Specify name of Cartridge 1 high ROM image

-c2lo <name>
     Specify name of Cartridge 2 low ROM image

-c2hi <name>
     Specify name of Cartridge 2 high ROM image  

PLUS4 settings
---------------

   

PLUS4 resources
................

   
     

H256K
     Integer, enables the HANNES 256K RAM expansion (0: disabled, 1:
     256kB, 2: 1024kB, 3: 4096kB) 

CS256K
     Boolean, enables the CSORY 256K RAM expansion 

Acia1Enable
     Boolean specifying whether the ACIA should be emulated or not. 


PLUS4 command-line options
...........................

   
     

-ramsize <ramsize>
     Specify size of RAM installed in kb (16/32/64) 

-h256k
     Enable the HANNES 256K RAM expansion

-h1024k
     Enable the HANNES 1024K RAM expansion

-h4096k
     Enable the HANNES 4096K RAM expansion

-cs256k
     Enable the CSORY 256K RAM expansion 

-acia
+acia
     Enable/Disable the ACIA emulation  


@EndNode

@Node "PET-specific" "vice.guide/PET-specific"
@Next "CBM-II-specific"
@Prev "VIC20-specific"
@Toc "Machine-specific features"

PET-specific commands and settings
===================================

    This section lists the settings and commands that are
PET-specific and thus are not present in the other emulators. 

   * PET model:: * PET diagnostic pin:: * PET commandline
options:: * PET colors::  menu 


@EndNode

@Node "PET model" "vice.guide/PET model"
@Next "PET diagnostic pin"
@Prev "PET-specific"
@Toc "PET-specific"

Changing PET model settings
----------------------------

    With `xpet', it is possible to change at runtime the
characteristics of the emulated PET so that it matches (or not) the
ones of a certain PET model, and it is also possible to select from a
common set of PET models so that all the features are selected
accordingly.  The former is done by changing the following
resources (via resource file, command line options or right-menu
items): 
     

RamSize
     Size of memory in kByte. 96k denotes a 8096, 128k a 8296. 

IOSize
     Size of I/O area in Byte.  Either 2048 or 256 for 8296. 

VideoSize
     The number of columns on the screen (40 or 80).  A 0 auto-detects
     this from the ROM. 

Ram9
     The 8296 can map RAM into the address range $9*** 

RamA
     The 8296 can map RAM into the address range $A*** 

SuperPET
     This resource enables the SuperPET (MicroMainFrame 9000) I/O and
     6809 CPU, and disables the 8x96 mappings. 

Basic1
     If (by checksum) a version 1 kernal is detected, then the kernal
     ROM is patched to make the IEEE488 interface work. 

Basic1Chars
     Exchanges some character in the character ROM that have changed
     between the first PET 2001 and all newer versions. 

EoiBlank
     This resource enables the "blank screen on EOI" feature of the
     oldest PET 2001. 

DiagPin
     Set the diagnositc pin on the PET userport (see below). 

ChargenName
     Specify `NAME' as the character generator ROM file 

KernalName
     Specify `NAME' as the kernal ROM file.  This file contains the
     complete BASIC, EDITOR and KERNAL ROMs and is either 16k (BASIC 1
     and 2) or 20k (BASIC 4) in size. 

EditorName
     Specify `NAME' as the editor ROM file.  This file contains an
     overlay for the editor ROM at $E000-$E7FF if necessary. 

RomModule9Name
     Specify `NAME' as the $9*** Expansion ROM file.  This file
     contains an expansion ROM image of 4k. 

RomModuleAName
     Specify `NAME' as the $A*** Expansion ROM file.  This file
     contains an expansion ROM image of 4k. 

RomModuleBName
     Specify `NAME' as the $B*** Expansion ROM file.  This file
     contains an expansion ROM image of 4k. This file overlays the
     lowest 4k of a BASIC 4 ROM.   Choosing a common PET model is
done from the right-button menu instead, by choosing an item from the
"Model defaults" submenu.  Available models are: 
     PET 2001-8N

     PET 3008

     PET 3016

     PET 3032

     PET 3032B

     PET 4016

     PET 4032

     PET 4032B

     PET 8032

     PET 8096

     PET 8296

     SuperPET  Notice that this will *reset the emulated machine*.
 It is also possible to select the PET model at startup, with the
`-model' command-line option: for example, `xpet -model 3032' will
emulate a PET 3032 while `xpet -model 8296' will emulate a PET 8296.


CRTC Settings
--------------

   

CRTC resources
...............

   
     

Crtc
     Enables CRTC 6545 emulation (all models from 40xx and above) 

CrtcVideoCache
     Boolean specifying whether the video cache is turned on. 

CrtcDoubleSize
     Boolean specifying whether double-size mode is turned on. 

CrtcDoubleScan
     Boolean specifying whether double-scan mode is turned on. 

CrtcStretchVertical
     Boolean specifying whether vertical stretching is turned on. 

CrtcPaletteFile
     String specifying the name of the palette file being used.  The
     `.vpl' extension is optional. 

CrtcHwScale
     Boolean specifying whether to enable or disable hardware scaling
     

CrtcFullscreenDevice
     fullscreen device 

CrtcFullscreen
     Boolean specifying whether to use fullscreen mode or not. 

CrtcFullscreenStatusbar
     Boolean specifying whether to show the status bar in fullscreen
     mode or not. 

CrtcXRANDRFullscreenMode
     integer specifying XRANDR fullscreen mode 

CrtcVidmodeFullscreenMode
     integer specifying Vidmode fullscreen mode 

CrtcExternalPalette
     Boolean specifying whether to use external palette file or not.
     

CrtcColorSaturation
     integer specifying saturation of internal calculated palette
     [1000] <0-2000> 

CrtcColorContrast
     integer specifying contrast of internal calculated palette [1000]
     <0-2000> 

CrtcColorBrightness
     integer specifying brightness of internal calculated palette
     [1000] <0-2000> 

CrtcColorGamma
     integer specifying gamma of internal calculated palette [2200]
     <0-4000> 

CrtcColorTint
     integer specifying tint of internal calculated palette [1000]
     <0-2000> 

CrtcPALScanLineShade
     integer specifying amount of scan line shading for the CRT
     emulation [667] <0-1000> 

CrtcPALBlur
     integer specifying amount of horizontal blur for the CRT
     emulation. [500] <0-1000> 

CrtcPALOddLinePhase
     integer specifying phase offset for color carrier in odd lines
     [750] <0-2000> 

CrtcPALOddLineOffset
     integer specifying phase for color carrier in odd lines [1250]
     <0-2000> 

CrtcAudioLeak
     Boolean specifying whether to enable/disable video to audio leak
     emulation. 

CrtcFilter
     integer specifying rendering filter, 0:none, 1:CRT emulation, 2:
     scale2x  

CRTC command-line options
..........................

   
-Crtcvcache
+Crtcvcache
     Enable/Disable the video cache

-Crtcdsize
+Crtcdsize
     Enable/Disable double size

-CRTCstretchvertical
+CRTCstretchvertical
     Enable/Disable vertical stretching

-Crtcdscan
+Crtcdscan
     Enable/Disable double scan

-Crtcfilter <Mode>
     Select rendering filter, 0:none, 1:CRT emulation, 2: scale2x

-Crtchwscale
+Crtchwscale
     Enable/Disable hardware scaling

-Crtcintpal
     Use an internal calculated palette

-Crtcextpal
     Use an external palette (file)

-Crtcpalette NAME
     Specify `NAME' as the palette file (`CrtcPaletteFile').

-Crtcfulldevice <device>
     Select fullscreen device

-CrtcXRANDRfullmode <mode>
     Select fullscreen mode

-CrtcVidmodefullmode <mode>
     Select fullscreen mode 

-Crtcsaturation <0-2000>
     Set saturation of internal calculated palette [1000]

-Crtccontrast <0-2000>
     Set contrast of internal calculated palette [1000]

-Crtcbrightness <0-2000>
     Set brightness of internal calculated palette [1000]

-Crtcgamma <0-4000>
     Set gamma of internal calculated palette [2200]

-Crtctint <0-2000>
     Set tint of internal calculated palette [1000]

-Crtcoddlinesphase <0-2000>
     Set phase for color carrier in odd lines [1250]

-Crtcoddlinesoffset <0-2000>
     Set phase offset for color carrier in odd lines [750]

-Crtccrtblur <0-1000>
     Amount of horizontal blur for the CRT emulation. [500]

-Crtccrtscanlineshade <0-1000>
     Amount of scan line shading for the CRT emulation [667] 

-Crtcaudioleak
+Crtcaudioleak
     Enable/Disable video to audio leak emulation.  

PET I/O extension settings
---------------------------

   

PET I/O extension resources
............................

   
     

PETREU
     Boolean specifying whether PET REU emulation is enabled.

PETREUfilename
     String specifying the filename of the PET REU image.

PETREUsize
     Integer specifying the size of the emulated PET REU in KB (128,
     512, 1024, 2048) 

PETDWW
     Boolean specifying whether DWW emulation is enabled.

PETDWWfilename
     String specifying the filename of the DWW ROM image. 

UserportDAC
     Boolean specifying whether userport DAC emulation is enabled. 

SidCart
     Boolean specifying whether SID Cart emulation is enabled.

SidAddress
     Integer that specifies the base address of the emulated SID chip.

SidClock
     Integer specifying the clock rate used for the emulated SID chip
     (0: C64, 1: PET)  

PET I/O extension command-line options
.......................................

   
     

-petreu
+petreu
     Enable or disable the PET Memory Expansion Unit. 

-petreuimage <name>
     Specify name of PET Ram and Expansion Unit image

-petreuramsize <size in KB>
     Size of the PET Ram and Expansion Unit 

-userportdac, +userportdac
     Enable or disable the userport DAC. 

-petdww
+petdww
     Enable/Disable the PET DWW hi-res board

-petdwwimage <name>
     Specify name of PET DWW image 

-sidcart
+sidcart
     Enable/Disable SID Cartridge  

PET system ROM settings
------------------------

   

PET system ROM resources
.........................

   
     

H6809RomAName
H6809RomBName
H6809RomCName
H6809RomDName
H6809RomEName
H6809RomFName
     Strings specifying the filenames of the respective H6809 ROM
     images. 

RomsetEditorName
RomsetRomModule9Name
RomsetRomModuleAName
RomsetRomModuleBName
RomsetH6809RomAName
RomsetH6809RomBName
RomsetH6809RomCName
RomsetH6809RomDName
RomsetH6809RomEName
RomsetH6809RomFName
     Integers [0]  

PET system ROM command-line options
....................................

   
     

-kernal NAME
     Specify `NAME' as the Kernal/BASIC ROM file (`KernalName'). 

-editor NAME
     Specify `NAME' as the editor ROM file (`EditorName'). 

-chargen NAME
     Specify `NAME' as the character generator ROM file
     (`ChargenName'). 

-rom9 NAME, -romA NAME, -romB NAME
     Specify `NAME' as the ROM image file for the respective
     cartridge areas (`RomModule9Name', `RomModuleAName',
     `RomModuleBName'). 

-6809romA <Name>
     Specify 4K to 24K ROM file name at $A000 for 6809

-6809romB <Name>
     Specify 4K to 20K ROM file name at $B000 for 6809

-6809romC <Name>
     Specify 4K to 16K ROM file name at $C000 for 6809

-6809romD <Name>
     Specify 4K to 12K ROM file name at $D000 for 6809

-6809romE <Name>
     Specify 2K or 8K ROM file name at $E000 for 6809

-6809romF <Name>
     Specify 4K ROM file name at $F000 for 6809  


@EndNode

@Node "PET diagnostic pin" "vice.guide/PET diagnostic pin"
@Next "PET commandline options"
@Prev "PET model"
@Toc "PET-specific"

The PET diagnostic pin
-----------------------

    It is possible to enable or disable emulation of the PET
diagnostic pin via the `DiagPin' resource, or the "PET userport
diagnostic pin" item in the right-button menu.  When the
diagnostic pin is set, the Kernal does not try to initialize the
BASIC, but directly jumps into the builtin machine monitor. 

PET settings
-------------

   

PET resources
..............

   
     

CPUswitch
     Integer specifying the status of the SuperPET CPU switch (0: 6502,
     1: 6809, 2: PROG)  


@EndNode

@Node "PET commandline options" "vice.guide/PET commandline options"
@Next "PET colors"
@Prev "PET diagnostic pin"
@Toc "PET-specific"

PET command line options
.........................

    These are the commandline options specific for the CBM-II
models. 
     

-model MODEL
     Specify the PET model you want to emulate. 

-petram9, +petram9
     Switch on RAM mapping on addresses $9000-$9fff (`Ram9'). 

-petramA, +petramA
     Switch on RAM mapping on addresses $a000-$afff (`RamA'). 

-superpet, +superpet
     Enable/Disable SuperPET I/O and CPU emulation (`SuperPET'). 

-cpu6502
     Set SuperPET CPU switch to '6502'

-cpu6809
     Set SuperPET CPU switch to '6809'

-cpuprog
     Set SuperPET CPU switch to 'Prog' 

-basic1, +basic1
     Enable/Disable patching the IEEE488 section of the PET2001 ROM
     when detected (`Basic1'). 

-basic1char, +basic1char
     Enable/Disable PET 2001 character generator (`Basic1Chars'). 

-eoiblank, +eoiblank
     Enable/Disable EOI blanking the screen (`EoiBlank'). 

-diagpin
+diagpin
     Enable (`DiagPin=1') or disable (`DiagPin=0') the diagnostic pin
     at the PET userport.  


@EndNode

@Node "PET colors" "vice.guide/PET colors"
@Prev "PET commandline options"
@Toc "PET-specific"

Changing screen colors
-----------------------

    It is also possible to choose what color set is used for the
emulation window.  This is done by specifying a palette file name
(see @{"Palette files" Link "Palette files"}) in the `PaletteName' resource.  The menu
provides the following values: 
     `green.vpl' (default, "green)"), the good old green-on-black
     feeling;

     `amber.vpl' ("amber"), an amber phosphor lookalike;

     `white.vpl' ("white"), simple white-on-black palette.  


@EndNode

@Node "CBM-II-specific" "vice.guide/CBM-II-specific"
@Prev "PET-specific"
@Toc "Machine-specific features"

CBM-II-specific commands and settings
======================================

    This section lists the settings and commands that are
CBM-II-specific and thus are not present in the other emulators. 

   * CBM-II model:: * CBM-II commandline options:: * CBM-II
colors::  menu 


@EndNode

@Node "CBM-II model" "vice.guide/CBM-II model"
@Next "CBM-II commandline options"
@Prev "CBM-II-specific"
@Toc "CBM-II-specific"

Changing CBM-II model
----------------------

    With `xcbm2', it is possible to change at runtime the
characteristics of the emulated CBM so that it matches (or not) the
ones of a certain CBM model, and it is also possible to select from a
common set of CBM models so that all the features are selected
accordingly.  The former is done by changing the following
resources (via resource file, command line options or right-menu
items): 
     

RamSize
     Size of memory in kByte.  Possible values are 128, 256, 512 and
     1024 

Ram08
Ram1
Ram2
Ram4
Ram6
RamC
     Expanded CBM-II models could map RAM to the expansion ROM areas
     at $0800-$0fff, $1000-$1fff, $2000-$3FFF, $4000-$5FFF,
     $6000-$7FFF and $c000-$cfff respectively. 

Cart1Name
Cart2Name
Cart4Name
Cart6Name
     Specify `NAME' as the $1000-$1FFF, $2000-$3FFF, $4000-$5FFF or
     $6000-$6FFF Expansion ROM file.  This file contains an 8k ROM
     dump. 

ModelLine
     The CBM-II business models have two hardcoded lines at one of the
     I/O ports. From those lines the kernal determines how it should
     init the CRTC video chip for either 50Hz (Europe) or 60Hz (North
     America), and either for 8 (C6x0) or 14 (C7x0) scanlines per
     character. 0 = CBM 7x0 (50Hz), 1 = 60Hz C6x0, 2 = 50Hz C6x0).
       Choosing a common CBM-II model is done from the right-button
menu instead, by choosing an item from the "Model defaults" submenu.
Available models are: 
     C510 (128k RAM)

     C610 (128k RAM)

     C620 (256k RAM)

     C620+ (1024k RAM, expanded)

     C710 (128k RAM)

     C720 (256k RAM)

     C720+ (1024k RAM, expanded)  Notice that this will *reset the
emulated machine*.  Warning: At this time switching between 510 and
other machines during runtime is not supported and will not work. 
It is also possible to select the CBM model at startup, with the
`-model' command-line option: for example, `xcbm2 -model 610' will
emulate a CBM 610 while `xcbm2 -model 620' will emulate a CBM 620.
Notably this is the only way to start a C510 emulation, with `-model
510'. 

CBM-II system ROM settings
---------------------------

   

CBM-II system ROM resources
............................

   
RomsetCart1Name
RomsetCart2Name
RomsetCart4Name
RomsetCart6Name
     Integers [0] 

CBM-II system ROM command line options
.......................................

   
-kernal NAME
     Specify `NAME' as the Kernal ROM file (`KernalName'). 

-basic NAME
     Specify `NAME' as the Basic ROM file (`BasicName'). 

-chargen NAME
     Specify `NAME' as the character generator ROM file
     (`ChargenName'). 

-cart1 <name>
     Specify `NAME' as the ROM image file for the cartridge area
     $1000-$1FFF (`Cart1Name').

-cart2 <name>
     Specify `NAME' as the ROM image file for the cartridge area
     $2000-$3fff (`Cart2Name').

-cart4 <name>
     Specify `NAME' as the ROM image file for the cartridge area
     $4000-$5fff (`Cart4Name').

-cart6 <name>
     Specify `NAME' as the ROM image file for the cartridge area
     $6000-$7fff (`Cart6Name'). 


@EndNode

@Node "CBM-II commandline options" "vice.guide/CBM-II commandline options"
@Next "CBM-II colors"
@Prev "CBM-II model"
@Toc "CBM-II-specific"

CBM-II command line options
----------------------------

    These are the commandline options specific for the CBM-II
models. 
     

-ramsize <ramsize>
     Specify size of RAM (64/128/256/512/1024 kByte) 

-ram08
+ram08
     Enable/Disable RAM mapping in bank 15 on addresses  $0800-$0FFF
     resp (`Ram08').

-ram1
+ram1
     Enable/Disable RAM mapping in bank 15 on addresses  $1000-$1FFF
     resp (`Ram1').

-ram2
+ram2
     Enable/Disable RAM mapping in bank 15 on addresses  $2000-$3FFF
     resp (`Ram2').

-ram4
+ram4
     Enable/Disable RAM mapping in bank 15 on addresses  $4000-$5FFF
     resp (`Ram4').

-ram6
+ram6
     Enable/Disable RAM mapping in bank 15 on addresses  $6000-$7FFF
     resp (`Ram6').

-ramC
+ramC
     Enable/Disable RAM mapping in bank 15 on addresses  $C000-$CFFF
     resp (`RamC'). 

-model <modelnumber>
     Specify CBM-II model to emulate  


@EndNode

@Node "CBM-II colors" "vice.guide/CBM-II colors"
@Prev "CBM-II commandline options"
@Toc "CBM-II-specific"

Changing screen colors
-----------------------

    It is also possible to choose what color set is used for the
emulation window.  This is done by specifying a palette file name
(see @{"Palette files" Link "Palette files"}) in the `PaletteName' resource.  The menu
provides the following values: 
     `green.vpl' (default, "green"), the good old green-on-black
     feeling;

     `amber.vpl' ("amber"), an amber phosphor lookalike;

     `white.vpl' ("white"), simple white-on-black palette.  

VSID-specific commands and settings
====================================

   

VSID settings
--------------

   

VSID resources
...............

   
     

PSIDKeepEnv
     Boolean that specifies whether to override PSID settings for Video
     standard and  SID model. 

PSIDTune
     Integer that specifies the currently played sub tune.  

VSID command-line options
..........................

   
     

-keepenv
     Override PSID settings for Video standard and SID model

-tune <number>
     Specify PSID tune <number>   


@EndNode

@Node "Snapshots" "vice.guide/Snapshots"
@Next "Monitor"
@Prev "Machine-specific features"
@Toc "Top"

Snapshots
**********

    Every VICE emulator has a built-in snapshot feature, that saves
the complete emulator state into one file for later use. You can
therefore save the emulator state - including the state of the game
you are playing for example - in a single file. 

   * Snapshot usage:: * Snapshot format::  menu 


@EndNode

@Node "Snapshot usage" "vice.guide/Snapshot usage"
@Next "Snapshot format"
@Prev "Snapshots"
@Toc "Snapshots"

Snapshot usage
===============

    A snapshot is one file containining the complete emulator state.
A snapshot file can be generated by selecting the "Save snapshot"
command at any time.  This will pop up a requester from which you can
specify whether the snapshot should also contain the disk and ROM
status.  A snapshot file can be used to restore the emulator state
by selecting the `load snapshot' menu entry at any time.
Unfortunately attached ROM images/cartridges are only supported in the
VIC20, the PET and the CBM-II emulators at this time.  The memory
configuration of the emulator is saved in the snapshot file as well.
This configuration is restored when the snapshot is loaded.  A
quick snapshot can now be made by pressing the `M-F11' key and
reloaded by pressing the `M-F10' key. 


@EndNode

@Node "Snapshot format" "vice.guide/Snapshot format"
@Prev "Snapshot usage"
@Toc "Snapshots"

Snapshot format
================

    A snapshot file consists of several modules of mostly different
types. Each module has a name and saves the state of an entity like a
CIA, the CPU, or the memory. 

   * Emulator modules:: * Module formats::  menu 


@EndNode

@Node "Emulator modules" "vice.guide/Emulator modules"
@Next "Module formats"
@Prev "Snapshot format"
@Toc "Snapshot format"

Emulator modules
-----------------

    This section lists the modules that are contained in each of the
emulators snapshot files. 

   * x64 modules:: * x128 modules:: * xvic modules:: * xpet
modules:: * xcbm2 modules:: * Drive modules::  menu 


@EndNode

@Node "x64 modules" "vice.guide/x64 modules"
@Next "x128 modules"
@Prev "Emulator modules"
@Toc "Emulator modules"

x64 modules
............

    The modules in the x64 emulator are:    .1 .4 .5  Name
Type  Description  MAINCPU  6502  The Main CPU - although it is
a 6510, only the 6502 core is saved here  C64MEM  Memory  Holds
the RAM contents of the C64.  Also the CPU I/O register contents are
saved here.  C64ROM  ROM images  Dump of the system ROMs
VIC-II  656*  The VIC-II of the C64/128  CIA1  6526  The CIA
for the interrupts and the keyboard  CIA2  6526  The CIA for the
userport, IEC-bus and RS232.  SID  6581  The SID sound chip of
the C64/C128  REU*

   The RAM Extension Unit state (optional)  ACIA1  6551  An ACIA
(RS232 interface) at $DE00 (optional)  TPI  6525  A TPI at $DF00
for a parallel IEEE488 interface (optional)  *  Drive modules
The emulated drive(s) have their own modules see @{"Drive modules" Link "Drive modules"}
multitable  Some of the modules are optional and are only saved if
the specific feature is enabled at save-time.  If the module is found
when restoring the state the optional features are enabled, and
disabled otherwise. 


@EndNode

@Node "x128 modules" "vice.guide/x128 modules"
@Next "xvic modules"
@Prev "x64 modules"
@Toc "Emulator modules"

x128 modules
.............

    The modules in the x128 emulator are:    .1 .4 .5  Name
Type  Description  MAINCPU  6502  The Main CPU - although it is
a 6510, only the 6502 core is saved here  C128MEM  Memory  Holds
the RAM contents of the C64.  Also the CPU I/O register contents are
saved here.  C128ROM  ROM images  Dump of the system ROMs
VIC-II  656*  The VIC-II of the C64/128  CIA1  6526  The CIA
for the interrupts and the keyboard  CIA2  6526  The CIA for the
userport, IEC-bus and RS232.  SID  6581  The SID sound chip of
the C64/C128  ACIA1  6551  An ACIA at $DE00 (optional)  TPI
6525  A TPI at $DF00 for a parallel IEEE488 interface (optional)
*  Drive modules  The emulated drive(s) have their own modules see
@{"Drive modules" Link "Drive modules"}  multitable  Some of the modules are optional and
are only saved if the specific feature is enabled at save-time.  If
the module is found when restoring the state the optional features
are enabled, and disabled otherwise.  Not yet supported are the 80
column video chip, cartridges and RAM expansion unit. 


@EndNode

@Node "xvic modules" "vice.guide/xvic modules"
@Next "xpet modules"
@Prev "x128 modules"
@Toc "Emulator modules"

xvic modules
.............

    The modules in the xvic emulator are:    .1 .4 .5  Name
Type  Description  MAINCPU  6502  The Main CPU  VIC20MEM
Memory  Holds the RAM contents of the VIC20.  VIC20ROM  ROM
images  Holds the ROM images of the VIC20, including possibly
attached cartridges  VIC-I  656*  The VIC-I of the VIC20  VIA1
6522  The VIA for the interrupts and the keyboard  VIA2  6522
The VIA for the userport, IEC-bus and RS232.  *  Drive modules
The emulated drive(s) have their own modules see @{"Drive modules" Link "Drive modules"}
multitable 


@EndNode

@Node "xpet modules" "vice.guide/xpet modules"
@Next "xcbm2 modules"
@Prev "xvic modules"
@Toc "Emulator modules"

xpet modules
.............

    The modules in the xpet emulator are:    .1 .4 .5  Name
Type  Description  MAINCPU  6502  The Main CPU  PETMEM
Memory  Holds the RAM contents of the PET.  PETROM  ROM images
Holds the ROM images of the PET, including possibly attached
cartridges  CRTC  6545  The CRTC of the PET. This is also
included if it is a dump of a PET without CRTC, because the video state
is saved here anyway.  PIA1  6520  The PIA for the interrupts,
tape and the keyboard  PIA2  6520  The PIA for the IEEE488-bus
VIA  6522  The VIA for IEEE488, userport, sound  ACIA1  6551
The ACIA for the SuperPET.  This module is optional.  DWWPIA  6520
The PIA for the DWW hires board.   CPU6809  6809  The extra CPU
in the SuperPET.  This module is optional.  *  Drive modules  The
emulated drive(s) have their own modules see @{"Drive modules" Link "Drive modules"}
multitable 


@EndNode

@Node "xcbm2 modules" "vice.guide/xcbm2 modules"
@Next "Drive modules"
@Prev "xpet modules"
@Toc "Emulator modules"

xcbm2 modules
..............

    The modules in the xcbm2 emulator are:    .1 .4 .5  Name
Type  Description  MAINCPU  6502  The Main CPU - although it is
a 6509, only the 6502 core is saved here  CBM2MEM  Memory  Holds
the RAM contents of the CBM-II models.  Also holds the exec-bank and
indirection bank registers  C500DATA

   Holds additional state information necessary for the C500 (e.g.
cycles till the next IRQ)  CBM2ROM  Memory  optional.  Holds the
ROM images.  CRTC  6545  The video chip for the C6*0 and C7*0
models (only those models).  VIC-II  656?  The video chip for the
C5*0 models (only the C5*0 models).  CIA1  6526  The CIA for IEEE
488 and userport.  TPI1  6525  TPI 1 for IEEE488  TPI2  6525
TPI 2 for interrupts and keyboard.  ACIA1  6551  The RS232
interface  SID  6581  The CBM2s SID sound chip  *  Drive
modules  The emulated drive(s) have their own modules see
@{"Drive modules" Link "Drive modules"}  multitable 


@EndNode

@Node "Drive modules" "vice.guide/Drive modules"
@Prev "xcbm2 modules"
@Toc "Emulator modules"

Drive modules
..............

    The modules for the real disk drive emulation are included in the
emulator when the emulation is enabled during the writing of the
snapshot.    .1 .4 .5  Name  Type  Description  *CPU
6502  The Drive 0 CPU  *  *  *  multitable 


@EndNode

@Node "Module formats" "vice.guide/Module formats"
@Prev "Emulator modules"
@Toc "Snapshot format"

Module formats
---------------

    This section shows the basic module framework and the contents of
the different types of modules.  The single chip modules contain
the chip state, not the state of the emulator.  We tried to make the
format as implementation-independent as possible, to allow reuse of
snapshots in later versions of this emulator, or even in other
emulators. 

   * Module Terminology:: * Module framework:: * CPU 6502 module::
* CPU 6809 module:: * CIA 6526 module:: * VIA 6522 module:: * PIA
6520 module:: * TPI 6525 module:: * RIOT 6532 module:: * SID 6581
module:: * ACIA 6551 module:: * VIC-I module:: * VIC-II module::
* CRTC module:: * C64 memory module:: * C128 memory module:: *
VIC20 memory module:: * PET memory module:: * CBM-II memory
module:: * C500 data module::  menu 


@EndNode

@Node "Module Terminology" "vice.guide/Module Terminology"
@Next "Module framework"
@Prev "Module formats"
@Toc "Module formats"

Terminology
............

    In this section we use certain abbreviations to define the types
of the data saved in the snapshot. 
BYTE
     8 bit integer.

WORD
     16 bit integer.  Saved with low-byte first, high-byte last.

DWORD
     32 bit integer.  Saved with low-word first, then high-word.  Each
     word saved with its low-byte first.

ARRAY
     Array of BYTE values.  Length depends on the description.  The
tables for the single modules state the type, name and description of
the data saved in the modules.  The data is saved in the order it is
in the tables, so no offset is given. 


@EndNode

@Node "Module framework" "vice.guide/Module framework"
@Next "CPU 6502 module"
@Prev "Module Terminology"
@Toc "Module formats"

Module framework
.................

    The VICE snapshot file starts with the magic string and includes
the fileformat version number.    .1 .4 .5  Type  Name
Description  19 BYTE  MAGIC  "VICE Snapshot File\032", padded
with 0  BYTE  VMAJOR  fileformat major version number  BYTE
VMINOR  fileformat minor version number  16 BYTE  MACHINENAME
Name of emulated machine, like "PET", "CBM-II", "VIC20", "C64" or
"C128". zerobyte-padded.  multitable  The file header is followed
by a number of different snapshot modules.  Each module has a
header with the information given in the table below. The header
includes two version numbers, VMAJOR and VMINOR.  Modules with the
same VMAJOR should be able to be exchanged.  I.e. higher VMINOR
numbers only append to the data for lower VMINOR.  This additional
data is ignored by older restore routines.  The other way around
newer restore routines must accept the fewer info from lower VMINOR
dumps. Changes in VMAJOR might introduce any incompatibility you
like, but that's what VMAJOR is for after all :-)    .1 .4 .5
Type  Name  Description  16 BYTE  MODULENAME  The name of the
module in ASCII, padded with 0 to 16 byte.  BYTE  VMAJOR  major
version number  BYTE  VMINOR  minor version number  DWORD
SIZE  size of the module, including this header  multitable 


@EndNode

@Node "CPU 6502 module" "vice.guide/CPU 6502 module"
@Next "CPU 6809 module"
@Prev "Module framework"
@Toc "Module formats"

CPU 6502 module
................

    This module saves the core 6502 state.  You will find a clock
value there.  All other modules save their own clock values relative
to this value.  However, the drive modules save their clocks relative
to their appropriate CPUs of course.  Warning: This module is
still under construction and saves some information that is not sure
to be VICE-independent.  If in doubt, read the source.    .1 .4
.5  Type  Name  Description  DWORD  CLK  the current CPU
clock value.  All other clock values are relative to this.  BYTE
AC  Accumulator  BYTE  XR  X index register  BYTE  YR  Y
index register  BYTE  SP  Stack Pointer  WORD  PC  Programm
Counter  BYTE  ST  Status Registers  DWORD  LASTOPCODE  ?
DWORD  IRQCLK  absolute CLK when the IRQ line came active
DOWRD  NMICLK  absolute CLK when the NMI line came active  DWORD
?  ?  DWORD  ?  ?  multitable  


@EndNode

@Node "CPU 6809 module" "vice.guide/CPU 6809 module"
@Next "CIA 6526 module"
@Prev "CPU 6502 module"
@Toc "Module formats"

CPU 6809 module
................

    This module saves the core 6809 state.  You will find a clock
value there.  All other modules save their own clock values relative
to this value.  However, the drive modules save their clocks relative
to their appropriate CPUs of course.  Warning: This module is
still under construction and saves some information that is not sure
to be VICE-independent.  If in doubt, read the source.    .1 .4
.5  Type  Name  Description  DWORD  CLK  the current CPU
clock value.  All other clock values are relative to this.  WORD
X  The X register  WORD  Y  The Y register  WORD  U  The
U register  WORD  PC  The Program Counter register  BYTE  DP
The Direct Page register  BYTE  CC  The Condition Code register
BYTE  A  The A register  BYTE  B  The B register    
The following are for 6309 compatibility:  WORD  V  The V
register  BYTE  E  The E register  BYTE  F  The F register
multitable 


@EndNode

@Node "CIA 6526 module" "vice.guide/CIA 6526 module"
@Next "VIA 6522 module"
@Prev "CPU 6809 module"
@Toc "Module formats"

CIA module
...........

    The CIA 6526 is an I/O port chip with 2 8-bit I/O ports, a shift
register, two timers, a Time of Day clock and interrupts. 
Version numbers: Major 1, Minor 1.    .1 .4 .5  Type  Name
Description  BYTE  ORA  Output register A  BYTE  ORB
Output register B  BYTE  DDRA  Data direction register A  BYTE
DDRB  Data direction register B  WORD  TAC  Timer A counter
value  WORD  TBC  Timer B counter value  BYTE  TOD_TEN
Time of Day - current tenth of second  BYTE  TOD_SEC  Time of Day
- current seconds  BYTE  TOD_MIN  Time of Day - current minutes
BYTE  TOD_HR  Time of Day - current hours  BYTE  SDR
contents of shift register  BYTE  IER  mask of enabled interrupt
masks  BYTE  CRA  Control register A  BYTE  CRB  Control
register B  WORD  TAL  Timer A latch value  WORD  TBL
Timer B latch value  BYTE  IFR  mask of currently active
interrupts  BYTE  PBSTATE  Bit 6/7 reflect the PB6/7 toggle bit
state.  Bit 2/3 reflect the corresponding port bit state.  BYTE
SRHBITS  number of half-bits to still shift in/out SDR  BYTE
ALARM_TEN  Time of Day - alarm tenth of second  BYTE  ALARM_SEC
Time of Day - alarm seconds  BYTE  ALARM_MIN  Time of Day -
alarm minutes  BYTE  ALARM_HR  Time of Day - alarm hours  BYTE
READICR  current clock minus the clock when ICR was read last plus
128.  BYTE  TODLATCHED  Bit 0: 1= latched for reading, Bit 1:
2=stopped for writing  BYTE  TODL_TEN  Time of Day - latched
tenth of second  BYTE  TODL_SEC  Time of Day - latched seconds
BYTE  TODL_MIN  Time of Day - latched minutes  BYTE  TODL_HR
Time of Day - latched hours  DWORD  TOD_TICKS  clk ticks till
next tenth of second  -  -  The next items have been added in
V1.1  WORD  TASTATE  The state bits of the CIA timer A, according
to ciatimer.h  WORD  TBSTATE  The state bits of the CIA timer B,
according to ciatimer.h  multitable  The last two items have been
added in CIA snapshot version 1.1 due to the improved CIA emulation
in the newer VICE versions. Some state bits correspond to the CIA
state as described in the "A Software Model of the CIA 6526" document
by Wolfgang Lorenz, some are delayed versions. For more read the
source file `ciatimer.h'. 


@EndNode

@Node "VIA 6522 module" "vice.guide/VIA 6522 module"
@Next "PIA 6520 module"
@Prev "CIA 6526 module"
@Toc "Module formats"

VIA module
...........

    The VIA 6522 is the predecessor of the CIA and also an I/O port
chip with 2 8-bit I/O ports, a shift register, two timers and
interrupts.  Version numbers: Major 1, Minor 0.    .1 .4 .5
Type  Name  Description  BYTE  ORA  Output register A
BYTE  DDRA  Data direction register A  BYTE  ORB  Output
register B  BYTE  DDRB  Data direction register B  WORD  T1L
Timer 1 Latch value  WORD  T1C  Timer 1 counter value  BYTE
T2L  Timer 2 latch (8 bit as only lower byte is used)  WORD  T2C
Timer 2 counter value  BYTE  RUNFL  bit 7: timer 1 will generate
IRQ on underflow; bit 6: timer 2 will generate IRQ on underflow
BYTE  SR  Shift register value  BYTE  ACR  Auxiliary control
register  BYTE  PCR  Peripheral control register  BYTE  IFR
active interrupts  BYTE  IER  interrupt mask  BYTE  PB7
bit 7 = pb7 state  BYTE  SRHBITS  number of half-bits to shift
out on SR  BYTE  CABSTATE  bit 7: state of CA2 pin, bit 6: state
of CB2 pin  BYTE  ILA  Port A Input Latch (see ACR bit 0)
BYTE  ILB  Port B Input Latch (see ACR bit 1)  multitable 


@EndNode

@Node "PIA 6520 module" "vice.guide/PIA 6520 module"
@Next "TPI 6525 module"
@Prev "VIA 6522 module"
@Toc "Module formats"

PIA module
...........

    The PIA 6520 is a chip with two I/O ports (Parallel Interface
Adapter) and four additional handshake lines.  The chip is pretty the
same for Port A and B, only that Port A implements handshake on read
operation and port B on write operation.  Version numbers: Major
1, Minor 0.    .1 .4 .5  Type  Name  Description  UBYTE
ORA  Output register A  UBYTE  DDRA  Data Direction Register A
UBYTE  CTRLA  Control Register A  UBYTE  ORB  Output
register B  UBYTE  DDRB  Data Direction Register B  UBYTE
CTRLB  Control Register B  UBYTE  CABSTATE  Bit 7 = state of
CA2, Bit 6 = state of CB2  multitable 


@EndNode

@Node "TPI 6525 module" "vice.guide/TPI 6525 module"
@Next "RIOT 6532 module"
@Prev "PIA 6520 module"
@Toc "Module formats"

TPI module
...........

    The TPI 6525 is a chip with three I/O ports (Tri-Port-Interface).
One of the ports can double as an interrupt prioritizer.  Therefore
we also have to save the states of the interrupt stack etc. 
Version numbers: Major 1, Minor 0.    .1 .4 .5  Type  Name
Description  BYTE  PRA  Port A output register  BYTE  PRB
Port B output register  BYTE  PRC  Port C output register
(doubles as IRQ latch register)  BYTE  DDRA  Port A data
direction register  BYTE  DDRB  Port B data direction register
BYTE  DDRC  Port C data direction register (doubles as IRQ mask
register)  BYTE  CR  Control Register  BYTE  AIR  Active
interrupt register  BYTE  STACK  Interrupt stack - the interrupt
bits that are not (yet) served.  BYTE  CABSTATE  State of CA/CB
pins.  Bit 7 = state of CA, Bit 6 = state of CB  multitable 


@EndNode

@Node "RIOT 6532 module" "vice.guide/RIOT 6532 module"
@Next "SID 6581 module"
@Prev "TPI 6525 module"
@Toc "Module formats"

RIOT module
............

    The RIOT 6532 is a chip with two I/O ports, some RAM and a
Timer. The chip contains 128 byte RAM, but the RAM is not saved in
the RIOT snapshot, but in the memory section.  Warning: This
module is still under construction  Version numbers: Major 0, Minor
0.    .1 .4 .5  Type  Name  Description  BYTE  ORA
Port A output register  BYTE  DDRA  Port A data direction
register  BYTE  ORB  Port B output register  BYTE  DDRB
Port B data direction register  BYTE  EDGECTRL  Bit 0/1: A0/A1
address bits written to edgecontrol registers  BYTE  IRQFL  Bit
6/7: A6/A7 IRQ flag register. Bit 0: state of the IRQ line (0=inactive,
1=active)  BYTE  N  timer value  WORD  DIVIDER  Pre-scale
divider value (1, 8, 64, or 1024)  WORD  REST  cycles since the
last counter change  BYTE  IRQEN  Bit 0: 0= timer IRQ disabled,
1= timer IRQ enabled  multitable 


@EndNode

@Node "SID 6581 module" "vice.guide/SID 6581 module"
@Next "ACIA 6551 module"
@Prev "RIOT 6532 module"
@Toc "Module formats"

SID module
...........

    Warning: This module is still under construction. 


@EndNode

@Node "ACIA 6551 module" "vice.guide/ACIA 6551 module"
@Next "VIC-I module"
@Prev "SID 6581 module"
@Toc "Module formats"

ACIA module
............

    The ACIA 6551 is an RS232 interface chip.  VICE emulates RS232
connections via `/dev/ttyS*' (Unix) or `COM:' (DOS/WIN - not yet?).
When saving a snapshot, those connections are of course lost. The
state of the ACIA however is restored if possible.  I.e. if a
connection is already open when restoring the snapshot, this
connection is used instead.  If no connection is open, a carrier/DTR
drop is emulated.  Version numbers: Major 1, Minor 0.    .1 .4
.5  Type  Name  Description  BYTE  TDR  Transmit Data
Register  BYTE  RDR  Receiver Data Register  BYTE  SR
Status Register  BYTE  CMD  Command Register  BYTE  CTRL
Ctrl Register  BYTE  INTX  0 = no data to tx; 1 = Data is being
transmitted; 2 = Data is being transmitted while data in TDR waiting to
be put to internal transmit register  DWORD  TICKS  Clock ticks
till the next TDR empty interrupt  multitable 


@EndNode

@Node "VIC-I module" "vice.guide/VIC-I module"
@Next "VIC-II module"
@Prev "ACIA 6551 module"
@Toc "Module formats"

VIC-I module
.............

    Warning: This module is still under construction. 


@EndNode

@Node "VIC-II module" "vice.guide/VIC-II module"
@Next "CRTC module"
@Prev "VIC-I module"
@Toc "Module formats"

VIC-II module
..............

    Warning: This module is still under construction. 


@EndNode

@Node "CRTC module" "vice.guide/CRTC module"
@Next "C64 memory module"
@Prev "VIC-II module"
@Toc "Module formats"

CRTC module
............

    Warning: After VICE version 1.0 the CRTC emulation has improved
considerably. Especially it is now cycle exact. Therefore a lot more
variables must be saved. The snapshot module version jumped from 0.0
to 1.0. Newer versions of VICE can read the old snapshots, but older
versions (1.0 and below) cannot read the new snapshots.  Warning:
This module is still under construction.  Especially the RASTERY and
RASTERLINE values might be bogus.  Version numbers: Major 1, Minor
1.    .1 .4 .5  Type  Name  Description

   Hardware options  WORD  VADDR_MASK  Mask of the address bits
valid when accessing the video memory  WORD  VADDR_CHARSWITCH  If
one bit in the video address is used to switch the character generator,
it is masked here.  WORD  VADDR_CHAROFFSET  The offset in
characters in the character generator that CHARSWITCH switches.
WORD  VADDR_REVSWITCH  If one bit in the video address inverts the
screen, it is masked here.  WORD  CHARGEN_MASK  size of character
generator in byte - 1  WORD  CHARGEN_OFFSET  offset given by
external circuitry  BYTE  HW_CURSOR  external hardware cursor
circuitry enabled  BYTE  HW_COLS  number of displayed columns
during one character clock cycle  BYTE  HW_BLANK  set if the
hardware blank feature is available

   CRTC register  20 BYTE  REGISTERS  register DUMP of the CRTC
registers 0-19.

   CRTC internal registers  BYTE  REGNO  The current index in the
CRTC register file  BYTE  CHAR  The current cycle within the
current rasterline  BYTE  CHARLINE  The current character line
BYTE  YCOUNTER  The current rasterline in the character  BYTE
CRSRCNT  Framecounter for the blinking cursor  BYTE  CRSRSTATE
if set the hardware cursor is visible  BYTE  CRSRLINES  set if
ycounter is within the active cursor rasterlines for a char  WORD
CHARGEN_REL  relative base of currently used character generator in
ROM (in byte)  WORD  SCREEN_REL  screen address to load the
counter at the beginning of the next rasterline  WORD  VSYNC
number of rasterlines left within vsync; 0 = not in vsync  BYTE
VENABLE  vertical enable flipflop; 1= display, 0= blank.

   (VICE-dependent?) variables  WORD  SCREEN_WIDTH  width of the
current display window  WORD  SCREEN_HEIGHT  height of the
current display window  WORD  SCREEN_XOFFSET  x position where
the first character in a line starts in the window...  WORD
HJITTER  ...but only after adding this jitter  WORD
SCREEN_YOFFSET  x position where the first character in a line starts
in the window...  WORD  FRAMELINES  expected number of
rasterlines for the current frame  WORD  CURRENT_LINE  current
rasterline as seen from the CRTC

   This value has been added in module version V1.1  BYTE  FLAG
Bit 0: If 1 then bit in VADDR_REVSWITCH must be set for reverse; if 0
then bit must be cleared for reverse.  multitable  Here is the
reference for the previous CRTC snapshot module. It is outdated and
will not be read by this and later versions of VICE.  Version
numbers: Major 0, Minor 0.    .1 .4 .5  Type  Name
Description  BYTE  RASTERY  The number of clock cycles from
rasterlines start  WORD  RASTERLINE  The current rasterline
WORD  ADDRMASK  The address mask valid for the CRTC.  All memory
accesses are masked with this value  BYTE  HWFLAG  Bit 0: 1=
hardware cursor available.  Bit 1: 1= number of columns is doubled by
external hardware  20 BYTE  REGISTERS  register DUMP of the CRTC
registers 0-19.  BYTE  CRSRSTATE  Hardware cursor: Bits 0-3:
frame counter till next crsr line toggle. Bit 7: 1= cursor line active
multitable 


@EndNode

@Node "C64 memory module" "vice.guide/C64 memory module"
@Next "C128 memory module"
@Prev "CRTC module"
@Toc "Module formats"

C64 memory module
..................

    The C64 memory module actually consists of two modules.  The
"C64MEM" module is mandatory and contains the RAM dump.  The "C64ROM"
module is optional and contains a dump of the ROM images.  The
size of the C64 memory modules differs with each different memory
configuration. The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded. The attached cartridges are not
yet(!) saved and not yet restored upon load.  Version numbers:
Major 0, Minor 0  The C64MEM module    .1 .4 .5  Type
Name  Description  BYTE  CPUDATA  CPU port data byte  BYTE
CPUDIR  CPU port direction byte  BYTE  EXROM  state of the
EXROM line (?)  BYTE  GAME  state of the GAME line (?)  ARRAY
RAM  64k RAM dump  multitable  The C64ROM module    .1 .4
.5  Type  Name  Description  ARRAY  KERNAL  8k dump of the
kernal ROM  ARRAY  BASIC  8k dump of the basic ROM  ARRAY
CHARGEN  4k dump of the chargen ROM  multitable 


@EndNode

@Node "C128 memory module" "vice.guide/C128 memory module"
@Next "VIC20 memory module"
@Prev "C64 memory module"
@Toc "Module formats"

C128 memory module
...................

    The C128 memory module actually consists of two modules.  The
"C128MEM" module is mandatory and contains the RAM dump.  The
"C128ROM" module is optional and contains a dump of the ROM images.
 The size of the C128 memory modules differs with each different
memory configuration. The RAM configuration is saved in the snapshot,
and restored when the snapshot is loaded. The attached cartridges
are also restored upon load if they have been saved in the snapshot.
 Version numbers: Major 0, Minor 0  The C128MEM module    .1
.4 .5  Type  Name  Description  12 BYTE  MMU  dump of the
12 MMU registers  ARRAY  RAM  128k RAM dump banks 0 and 1
multitable  The C128ROM module    .1 .4 .5  Type  Name
Description  ARRAY  KERNAL  8k dump of the kernal ROM  ARRAY
BASIC  32k dump of the basic ROM  ARRAY  EDITOR  4k dump of the
editor ROM  ARRAY  4k CHARGEN  dump of the chargen ROM
multitable 


@EndNode

@Node "VIC20 memory module" "vice.guide/VIC20 memory module"
@Next "PET memory module"
@Prev "C128 memory module"
@Toc "Module formats"

VIC20 memory module
....................

    The VIC20 memory module actually consists of two modules.  The
"VIC20MEM" module is mandatory and contains the RAM dump.  The
"VIC20ROM" module is optional and contains a dump of the ROM images.
 The size of the VIC20 memory modules differs with each different
memory configuration. The RAM configuration is saved in the snapshot,
and restored when the snapshot is loaded. The attached cartridges
are also restored upon load if they have been saved in the snapshot.
 The VIC20MEM module  Version numbers: Major 1, Minor 0    .1
.4 .5  Type  Name  Description  BYTE  CONFIG  Configuration
register.  Bits 0,1,2,3,5 reflect if the corresponding memory block is
RAM (bit=1) or not (bit=0).  ARRAY  RAM0  1k RAM dump
$0000-$03ff  ARRAY  RAM1  4k RAM dump $1000-$1fff  ARRAY
COLORRAM  2k Color RAM, $9400-$9bff  ARRAY  BLK0  if CONFIG & 1
then: 3k RAM dump $0400-$0fff  ARRAY  BLK1  if CONFIG & 2 then:
8k RAM dump $2000-$3fff  ARRAY  BLK2  if CONFIG & 4 then: 8k RAM
dump $4000-$5fff  ARRAY  BLK3  if CONFIG & 8 then: 8k RAM dump
$6000-$7fff  ARRAY  BLK5  if CONFIG & 32 then: 8k RAM dump
$a000-$bfff  multitable  The VIC20ROM module  Version
numbers: Major 1, Minor 1    .1 .4 .5  Type  Name
Description  BYTE  CONFIG  Bit 0: 1= ROM block $2*** enabled.
Bit 1: 1= ROM block $3*** enabled. Bit 2: 1= ROM block $4*** enabled.
Bit 3: 1= ROM block $5*** enabled. Bit 4: 1= ROM block $6*** enabled.
Bit 5: 1= ROM block $7*** enabled. Bit 6: 1= ROM block $A*** enabled.
Bit 7: 1= ROM block $B*** enabled.  ARRAY  KERNAL  8k KERNAL ROM
image $e000-$ffff  ARRAY  BASIC  16k BASIC ROM image $c000-$dfff
ARRAY  CHARGEN  4k CHARGEN ROM image  ARRAY  BLK1A  4k ROM
image $2*** (if CONFIG & 1)  ARRAY  BLK1B  4k ROM image $3*** (if
CONFIG & 2)  ARRAY  BLK3A  4k ROM image $6*** (if CONFIG & 16)
ARRAY  BLK3B  4k ROM image $7*** (if CONFIG & 32)  ARRAY
BLK5A  4k ROM image $A*** (if CONFIG & 64)  ARRAY  BLK5B  4k
ROM image $B*** (if CONFIG & 128)  ARRAY  BLK2A  4k ROM image
$4*** (if CONFIG & 4; added in V1.1)  ARRAY  BLK2B  4k ROM image
$5*** (if CONFIG & 8; added in V1.1)  multitable 


@EndNode

@Node "PET memory module" "vice.guide/PET memory module"
@Next "CBM-II memory module"
@Prev "VIC20 memory module"
@Toc "Module formats"

PET memory module
..................

    The PET memory module actually consists of three modules.  The
"PETMEM" module is mandatory and contains the RAM dump.  The "PETROM"
module is optional and contains a dump of the ROM images. The
"PETDWW" module is also optional and contains the image of the hires
expansion board (if enabled).  The size of the PET memory modules
differs with each different memory configuration.  The RAM
configuration is saved in the snapshot, and restored when the
snapshot is loaded.  The PETMEM module  Version numbers: Major
1, Minor 3    .1 .4 .5  Type  Name  Description  BYTE
CONFIG  Configuration value. Bits 0-3: 0= 40 col PET without CRTC; 1=
40 col PET with CRTC; 2 = 80 col PET (with CRTC); 3= SuperPET; 4= 8096;
5= 8296. Bit 6: 1= RAM at $9***. Bit 7: 1= RAM at $A***.  BYTE
KEYBOARD  Keyboard type. 0= UK business; 1= Graphics; 2= German
business  BYTE  MEMSIZE  memory size of low 32k in k (possible
values 4, 8, 16, 32)  BYTE  CONF8X96  Value of the 8x96
configuration register  BYTE  SUPERPET  SuperPET config. Bit 0:
1= $9*** RAM enabled. Bit 1: 1= RAM write protected. Bit 2: 1= CTRL
register write protected. Bit 3: 0= DIAG pin active. Bits 4-7: RAM
block in use.  ARRAY  RAM  4-32k RAM (not 8296, size depends on
MEMSIZE)  ARRAY  VRAM  2/4k RAM (not 8296, size depends on
CONFIG)  ARRAY  EXTRAM  64k expansion RAM (SuperPET and 8096
only)  ARRAY  RAM  128k RAM (8296 only)  -  -  The
following item has been added in V1.1  BYTE  POSITIONAL  bit 0=0
= symbolic keyboard mapping, bit 0=1 = positional mapping.  -  -
The following item has been added in V1.2  BYTE  EOIBLANK  bit
0=0 = EOI does not blank screen, bit 0=1 = EOI blanks screen.  -
-  The following items have been added in V1.3  WORD  CPU_SWITCH
6502 / 6809 / PROG  BYTE  VAL, PREVODD, WANTODD  6702 dongle
state information  WORD[8]  SHIFT   multitable  The
POSITIONAL item has been added in PETMEM snapshot version 1.1. It is
ignored by earlier restore routines (V1.0) and the V1.1 restore
routines do not change the current setting when reading a V1.0
snapshot.  In V1.2 the new EOIBLANK variable has been added. This
implements the "blank screen on EOI" feature that was previously
linked to a wrong resource.  In V1.3 the state for SuperPET has
been added.  The PETROM module  Version numbers: Major 1, Minor
1    .1 .4 .5  Type  Name  Description  BYTE  CONFIG
Bit 0: 1= $9*** ROM included. Bit 1: 1= $A*** ROM included. Bit 2: 1=
$B*** ROM included. Bit 3: 1= $e900-$efff ROM included. Bit 4: 1=
SuperPET ROMs included.  ARRAY  KERNAL  4k KERNAL ROM image
$f000-$ffff  ARRAY  EDITOR  2k EDITOR ROM image $e000-$e7ff
ARRAY  CHARGEN  2k CHARGEN ROM image  ARRAY  ROM9  4k $9***
ROM image (if CONFIG & 1)  ARRAY  ROMA  4k $A*** ROM image (if
CONFIG & 2)  ARRAY  ROMB  4k $B*** ROM image (if CONFIG & 4)
ARRAY  ROMC  4k $C*** ROM image  ARRAY  ROMD  4k $D*** ROM
image  ARRAY  ROME9  7 blocks $e900-$efff ROM image (if CONFIG &
8)  -  -  The following items have been added in V1.1  ROM6809
ROM6809  24k $A000-$FFFF ROM   (if CONFIG & 16)  ARRAY
CHARGEN(2)  upper half of CHARGEN (if CONFIG & 16)  multitable 
The PETDWW module  For storing the state of the DWW hires expansion
board, there is a PETDWWPIA module, and a DWWMEM module.  The
former has the same format as the PIA1.    .1 .4 .5  Type
Name  Description  WORD  SIZE  The size of the memory dump that
follows, or 0 if DWW disabled.  ARRAY  MEM  The memory in the DWW
card, SIZE bytes.  multitable 


@EndNode

@Node "CBM-II memory module" "vice.guide/CBM-II memory module"
@Next "C500 data module"
@Prev "PET memory module"
@Toc "Module formats"

CBM-II memory module
.....................

    The CBM-II memory module actually consists of two modules.  The
"CBM2MEM" module is mandatory and contains the RAM dump.  The
"CBM2ROM" module is optional and contains a dump of the ROM images.
 The size of the CBM-II memory modules differs with each different
memory configuration.  The RAM configuration is saved in the
snapshot, and restored when the snapshot is loaded.  Version
numbers: Major 1, Minor 0  The CBM2MEM module    .1 .4 .5
Type  Name  Description  UBYTE  MEMSIZE  Memory size in 128k
blocks (1=128k, 2=256k, 4=512k, 8=1024k)  UBYTE  CONFIG  Bit 0 =
$f0800-$f0fff RAM, Bit 1 = $f1000-$f1fff RAM, Bit 2 = $f2000-$f3fff
RAM, Bit 3 = $f4000-$f5fff RAM, Bit 4 = $f6000-$f7fff RAM, Bit 5 =
$fc000-$fcfff RAM, Bit 6 = is a C500  UBYTE  HWCONFIG  Bit 0/1:
model line configuration  UBYTE  EXECBANK  CPUs execution bank
register  UBYTE  INDBANK  CPUs indirection bank register
ARRAY  SYSRAM  2k system RAM $f0000-$f07ff  ARRAY  VIDEO  2k
video RAM $fd000-$fd7ff  ARRAY  RAM  RAM dump, size according to
MEMSIZE  ARRAY  RAM08  if memsize < 1M and CONFIG & 1 : 2k RAM
$f0800-$f0fff  ARRAY  RAM1  if memsize < 1M and CONFIG & 2 : 4k
RAM $f1000-$f1fff  ARRAY  RAM2  if memsize < 1M and CONFIG & 4 :
8k RAM $f2000-$f3fff  ARRAY  RAM4  if memsize < 1M and CONFIG & 8
: 8k RAM $f4000-$f5fff  ARRAY  RAM6  if memsize < 1M and CONFIG &
16 : 8k RAM $f6000-$f7fff  ARRAY  RAMC  if memsize < 1M and
CONFIG & 32 : 4k RAM $fc000-$fcfff  multitable  The RAM* arrays
are only saved if the RAM itself is less than 1M. If the memory size
is 1M then those areas are taken from the bank 15 area of the normal
RAM.  The memory array starts at $10000 if the memory size is less
than 512k, or at $00000 if 512k or more. In case of a C510, then the
memory array also always starts at $00000.  The CBM2ROM module
   .1 .4 .5  Type  Name  Description  UBYTE  CONFIG  Bit
1: 1= $1*** ROM image included. Bit 2: 1= $2000-$3fff ROM image
included. Bit 3: 1= $4000-$5fff ROM image included. Bit 4: 1=
$6000-$7fff ROM image included. Bit 5: 1= chargen ROM is VIC-II
chargen, 0= CRTC chargen.  ARRAY  KERNAL  8 KERNAL ROM image
($e000-$efff)  ARRAY  BASIC  BASIC ROM image ($8000-$bfff)
ARRAY  CHARGEN  4k CHARGEN ROM image  ARRAY  ROM1  4k
cartridge ROM image for $1*** (if CONFIG & 2)  ARRAY  ROM2  8k
cartridge ROM image for $2000-$3fff (if CONFIG & 4)  ARRAY  ROM4
8k cartridge ROM image for $4000-$5fff (if CONFIG & 8)  ARRAY
ROM6  8k cartridge ROM image for $6000-$7fff (if CONFIG & 16)
multitable 


@EndNode

@Node "C500 data module" "vice.guide/C500 data module"
@Prev "CBM-II memory module"
@Toc "Module formats"

C500 data module
.................

    The C500 data module contains simple state information not
already saved in the other modules.  Version numbers: Major 0,
Minor 0  The C500DATA module    .1 .4 .5  Type  Name
Description  DWORD  IRQCLK  CPU clock ticks till next 50Hz IRQ
multitable 

Media images
*************

    

Media images resources
=======================

   
     

DoodleOversizeHandling
     Integer specifying  the way the oversized input should be handled,
     (0: scale down,  1: crop left top, 2: crop center top,  3: crop
     right top, 4: crop left center,  5: crop center, 6: crop right
     center, 7: crop left bottom, 8: crop center bottom,  9:  crop
     right bottom)

DoodleMultiColorHandling
     Integer specifying  the way the multicolor to hires should be
     handled, (0: b&w,  1: 2 colors, 2: 4 colors, 3: gray scale,  4:
     best cell colors)

DoodleTEDLumHandling
     Integer specifying the way the TED luminosity should be handled,
     (0: ignore, 1: dither)

DoodleCRTCTextColor
     Integer specifying the text color used when making screenshots
     from a CRTC window in doodle format. (0: white, 1: amber, 2:
     green) 

FFMPEGFormat
     String specifying the current FFMPEG output driver.

FFMPEGAudioBitrate
     Integer specifying the current FFMPEG audio bitrate.

FFMPEGVideoBitrate
     Integer specifying the current FFMPEG video bitrate.

FFMPEGAudioCodec
     Integer specifying the current FFMPEG audio codec.

FFMPEGVideoCodec
     Integer specifying the current FFMPEG video codec.

FFMPEGVideoHalveFramerate
     Boolean, if true record only every other frame.  

Media images command-line options
==================================

   
     

-doodleoversize <method>
     Select the way the oversized input should be handled, (0: scale
     down, 1: crop left top, 2: crop center top,  3: crop right top, 4:
     crop left center, 5: crop center, 6: crop right center, 7: crop
     left bottom, 8: crop center bottom, 9:  crop right bottom)

-doodlemc <method>
     Select the way the multicolor to hires should be handled, (0: b&w,
     1: 2 colors, 2: 4 colors, 3: gray scale,  4: best cell colors)

-doodletedlum <method>
     Select the way the TED luminosity should be handled, (0: ignore,
     1: dither)

-doodlecrtctextcolor <color>
     Select the CRTC text color (0: white, 1: amber, 2: green) 

-ffmpegaudiobitrate <value>
     Set bitrate for audio stream in media file

-ffmpegvideobitrate <value>
     Set bitrate for video stream in media file  

Event history
**************

     VICE supports recording an arbitrary session on the emulated
machine and playing back this session later. This is done by saving a
snapshot at the beginning of the recording session and then
remembering all the user interaction such as keyboard and joystick
input. We call this an 'event history'. The main purpose for having
an event history is to create game sessions, e.g. recording  how to
solve a game. An example walkthrough for the well known game "Fort
Apocalypse" is available.  This brief chapter will advise you how
to record and playback such a session. Although it is based on the
WinVICE x64 release and its user interface, histories may be
transferred to other machines and other ports that support event
history, e.g. the Unix port. 

Recommended Settings
=====================

    When using the event history feature it is possible that the
playback session differs from what was done at recording time. This
might arise due to a problem  in the initial snapshot or settings.
Here are some suggestions to minimize the chance of failures in the
session: a. Reset to default settings. b. Choose refresh rate 1/1.
c. Choose joystick and Video/Doublesize settings as desired or needed.
d. SID engine must be reSID (which is the default). e. Choose Drive
settings/Idle method: None Do not change any settings during
recording or playback! 

Recorded Events
================

    The following is a list of the user interaction that will be
recorded: - Joystick movement and button - Keyboard - Resetting
the machine (hard and soft) - Attaching or detaching disk/tape images
(see 8. Limitations) - Datasette controls 

Recording an Event History
===========================

    Recording an event history will create one or two files for a
snapshot and the list of the user events. First, create an empty
directory in which these files are to be saved and then select this
directory and the name of the  snapshot files via 'Snapshot//Select
History files/directory'.  Next, attach the disk or tape image with
the game you want to record and load and run the game.  Start
recording via 'Snapshot//Start/Stop Recording History'. Play the
game. All actions will be recorded. After the game is finished, stop
recording via 'Snapshot//Start/Stop Recording History'. The selected
directory should now contain the two snapshot files (default ist
start.vsf and end.vsf).  

Setting and Returning to Milestones
====================================

    It is difficult to finish a game in one sitting and noone wants
to record all their mistakes and lost lives. Use the milestone
feature in a recording session in the following way:  Set a
milestone when you have finished a level or completed a task
('Snapshot//Set recording milestone' or ALT-E). This will save the
event history and a snapshot of the machine to the file end.vsf but
recording will continue.  Return to the last milestone when you
have made a mistake or lost a life ('Snapshot//Return to milestone'
or ALT-U). This will reset the game and the event history to the last
milestone snapshot so that you can try again. 

Continuing an Event History
============================

    If you have stopped a recording session and want to continue it
later, you should create a backup of your start.vsf and end.vsf files
first to avoid overwriting them by accident.  Then change the
event history start mode: 'Snapshot//Recording start mode//Load
existing snapshot'. When you start recording now, you will continue
where the session was stopped last time.  Another way of
continuing an existing history is to start somewhere inside the
history (e.g. you have recorded 10 minutes of a game and later
recognize that you made a mistake after 6 minutes that makes it
impossible to finish the game). For this you have to select the start
mode 'Overwrite playback'. Now you can start the playback with
'Snapshot//Start/Stop Playback History' and when you reach the point
where you want to change the history you can directly switch to
recording via 'Snapshot//Start/Stop Recording History'. 

Playing Back an Event History
==============================

    To play back an event history, select the directory with the
history files start.vsf and end.vsf via 'Snapshot//Select History
directory' and start the playback with 'Snapshot//Start/Stop Playback
History'. Enjoy! During playback any user interaction is disabled.
The playback stops when the end of the session is reached or if 
'Snapshot//Select History directory' is selected again. 

Limitations and Suggestions
============================

    a. Snapshot files will be quite big (>1MB) if a disk image has
been attached.  If possible, use PRG or T64 images to reduce the size
of snapshot files. b. Snapshots may not be 100% accurate even with
all the recommended settings.  

Event history resources
========================

   
     

EventSnapshotDir
     String specifying the directory used for loading and saving
     snapshots.

EventStartSnapshot
     String specifying the filename for the start snapshot.
     ["start.vsf"]

EventEndSnapshot
     String specifying the filename for the end snapshot. ["end.vsf"]

EventStartMode
     Integer specifying how to start event recording. (0: save new
     snapshot, 1: load existing snapshot, 2: reset, 3: playback)

EventImageInclude
     Boolean specifying whether to include ROM and Disk images in the
     snapshots. [1]  

Event history command-line options
===================================

   
-playback
     Playback recorded events  


@EndNode

@Node "Monitor" "vice.guide/Monitor"
@Next "c1541"
@Prev "Snapshots"
@Toc "Top"

Monitor
********

    Every VICE emulator has a complete built-in monitor, which can be
used to examine, disassemble and assemble machine language programs,
as well as debug them through breakpoints.  It can be activated by
using the "Activate monitor" command (left button menu).  Notice that
you have to run the emulator from a terminal emulation program (such
as `rxvt' or `xterm') in order to use the monitor.  Warning: this
version of the monitor is still under construction, and some of the
features are not fully working yet. 

   * Terminology:: * Machine state commands:: * Memory commands::
* Assembly commands:: * Checkpoint commands:: * General commands::
* Disk commands:: * Command file commands:: * Label commands:: *
Miscellaneous commands::  menu 


@EndNode

@Node "Terminology" "vice.guide/Terminology"
@Next "Machine state commands"
@Prev "Monitor"
@Toc "Monitor"

Terminology
============

   
     

address_space
     This refers to the range of memory locations and a set of
     registers. This can be the addresses available to the computer's
     processor, the disk drive's processor or a specific memory
     configuration of one of the mentioned processors. 

bankname
     The CPU can only see 64k of memory at any one time, due to its 16
     bit address bus. The C64 and other computers have more than this
     amount, and this is handled by banking: a memory address can
     have different contents, depending on the active memory bank.
     A bankname names a specific bank in the current address_space. 

register
     One of the following: program counter (PC), stack pointer (SP),
     accumulator (A), X register (X), or Y register (Y). 

address
     A specific memory location in the range $0000 to $FFFF. 

address_range
     Two addresses.  If the second address is less than the first, the
     range is assumed to wraparound from $FFFF to $0000.  Both
     addresses must be in the same address space. 

address_opt_range
     An address or an address range. 

label
     `label' is the name of a label. it must start with a dot (".")
     in order for the monitor to recognize it as a label. 

prompt
     The prompt has the format [x:y].  If x is -, memory reads from
     the monitor do not have side effects.  Otherwise, x is S.  The
     second part of the prompt, y, shows the default address space.
     

checkpoint
     The monitor has the ability to setup triggers that perform an
     action when a specified situation occurs.  There are three types
     of checkpoints; breakpoints, tracepoints and watchpoints. 

breakpoint
     A breakpoint is triggered based on the program counter.  When it
     is triggered, the monitor is entered. 

tracepoint
     Like breakpoints, a tracepoint is triggered based on the program
     counter.  Instead of entering the monitor, the program counter is
     printed and execution continues. 

watchpoint
     Watchpoints are triggered by a read and/or write to an address.
     When a watchpoint is triggered, the monitor is entered. 

memmap
     The memmap keeps track of RAM/ROM/IO read/write/execute
     accesses. The feature must be enabled with "-enable-memmap"
     configure option, as it might decrease performance notably on
     slower hardware. The option also enables CPU history. 

<...>
     A data type. 

*
     Zero or more occurrences. 

[...]
     An optional argument.  


@EndNode

@Node "Machine state commands" "vice.guide/Machine state commands"
@Next "Memory commands"
@Prev "Terminology"
@Toc "Monitor"

Machine state commands
=======================

   
     

backtrace
bt
     Print JSR call chain (most recent call first). Stack offset
     relative to SP+1 is printed in parentheses. This is a best guess
     only. 

cpuhistory [<count>]
chis [<count>]
     Show <count> last executed commands. (disabled by default;
     configure with -enable-memmap to enable) 

dump "<filename>"
     Write a snapshot of the machine into the file specified. This
     snapshot is compatible with a snapshot written out by the UI.
     Note: No ROM images are included into the dump. 

goto <address>
g <address>
     Change the PC to address and continue execution. 

io [<address>]
     Display i/o registers. Invoking without an address shows a dump
     of the entire io range, if an address is given then details for
     the chip at the respective (base-)address are displayed (if
     available). 

next [<count>]
n [<count>]
     Advance to the next instruction.  Subroutines are treated as a
     single instruction. 

registers [<reg_name> = <number> [, <reg_name> = <number>]*]
r [<reg_name> = <number> [, <reg_name> = <number>]*]
     Assign respective registers.  With no parameters, display
     register values. 

reset [<type>]
     Reset the machine or drive. `type': 0 = soft, 1 = hard, 8-11 =
     drive. 

return
ret
     Continues execution  and returns to the monitor just after the
     next RTS or RTI is executed. 

step [<count>]
z [<count>]
     Single step through instructions.  An optional count allows
     stepping more than a single instruction at a time. 

stopwatch [reset]
     Print the CPU cycle counter of the current device. 'reset' sets
     the counter to 0. 

undump "<filename>"
     Read a snapshot of the machine from the file specified.   


@EndNode

@Node "Memory commands" "vice.guide/Memory commands"
@Next "Assembly commands"
@Prev "Machine state commands"
@Toc "Monitor"

Memory commands
================

    
     

bank [<bankname>]
     Without a bankname, display all available banks for the current
     address_space. With a bankname given, switch to the specified
     bank. If a bank is not completely filled (ROM banks for example)
     normally the `ram' bank is used where the bank has holes. The
     `cpu' bank uses the bank currently used by the CPU. 

compare <address_range> <address>
c <address_range> <address>
     Compare memory from the source specified by the address range to
     the destination specified by the address.  The regions may
     overlap.  Any values that miscompare are displayed using the
     default displaytype. 

device [c:|8:|9:]
     Set the default address space to either the computer `c:' or the
     specified drive `8:' or `9:' 

fill <address_range> <data_list>
f <address_range> <data_list>
     Fill memory in the specified address range with the data in
     <data_list>.  If the size of the address range is greater than
     the size of the data_list, the data_list is repeated. 

hunt <address_range> <data_list>
h <address_range> <data_list>
     Hunt memory in the specified address range for the data in
     <data_list>.  If the data is found, the starting address of the
     match is displayed.  The entire range is searched for all
     possible matches. The data list may have `xx' as a wildcard. 

i <address_opt_range>
     Display memory contents as PETSCII text. 

ii <address_opt_range>
     Display memory contents as screen code text 

mem [<data_type>] [<address_opt_range>]
m [<data_type>] [<address_opt_range>]
     Display the contents of memory.  If no datatype is given, the
     default is used.  If only one address is specified, the length
     of data displayed is based on the datatype.  If no addresses are
     given, the 'dot' address is used. 

memmapshow [<mask>] [<address_opt_range>]
mmsh [<mask>] [<address_opt_range>]
     Show the memmap. The mask can be specified to show only those
     locations with accesses of certain type(s). The mask is a number
     with the bits "ioRWXrwx", where RWX are for ROM and rwx for RAM.
     Optionally, an address range can be specified. (disabled by
     default; configure with -enable-memmap to enable) 

memmapzap
mmzap
     Clear the memmap. (disabled by default; configure with
     -enable-memmap to enable) 

memmapsave "<filename>" <format>
mmsave "<filename>" <format>
     Save the memmap as a picture. `format': 0 = BMP, 1 = PCX, 2 =
     PNG, 3 = GIF, 4 = IFF. (disabled by default; configure with
     -enable-memmap to enable) 

memchar [<data_type>] [<address_opt_range>]
mc [<data_type>] [<address_opt_range>]
     Display the contents of memory as character data.  If only one
     address is specified, only one character is displayed.  If no
     addresses are given, the "dot" address is used. 

memsprite [<data_type>] [<address_opt_range>]
ms [<data_type>] [<address_opt_range>]
     Display the contents of memory as sprite data.  If only one
     address is specified, only one sprite is displayed.  If no
     addresses are given, the "dot" address is used. 

move <address_range> <address>
t <address_range> <address>
     Move memory from the source specified by the address range to the
     destination specified by the address.  The regions may overlap.
     

screen
sc
     Displays the contents of the screen. 

sidefx [on|off|toggle]
sfx [on|off|toggle]
     Control how monitor generated reads affect memory locations that
     have read side-effects, like CIA interrupt registers for
     example. If the argument is 'on' then reads may cause
     side-effects.  If the argument is 'off' then reads don't cause
     side-effects.  If the argument is 'toggle' then the current mode
     is switched.  No argument displays the current state. 

> [<address>] <data_list>
     Write the specified data at `address'.  


@EndNode

@Node "Assembly commands" "vice.guide/Assembly commands"
@Next "Checkpoint commands"
@Prev "Memory commands"
@Toc "Monitor"

Assembly commands
==================

   
     

a <address> [ <instruction> [: <instruction>]* ]
     Assemble instructions to the specified address.  If only one
     instruction is specified, enter assembly mode (enter an empty line
     to exit assembly mode). 

disass [<address> [<address>]]
d [<address> [<address>]]
     Disassemble instructions.  If two addresses are specified, they
     are used as a start and end address.  If only one is specified,
     it is treated as the start address and a default number of
     instructions are disassembled.  If no addresses are specified, a
     default number of instructions are disassembled from the dot
     address.  


@EndNode

@Node "Checkpoint commands" "vice.guide/Checkpoint commands"
@Next "General commands"
@Prev "Assembly commands"
@Toc "Monitor"

Checkpoint commands
====================

    
     

break [load|store|exec] [address [address] [if <cond_expr>]]
     This command allows setting a breakpoint or listing the current
     breakpoints.  If no address is given, the currently valid
     checkpoints are printed.  If an address is given, a breakpoint
     is set for that address and the breakpoint number is printed.
     The "load|store|exec" parameter can be either "load", "store" or
     "exec" (or any combination of these) to determine on which
     operation the monitor breaks. If not specified, the monitor
     breaks on "exec". A conditional expression can also be specified
     for the breakpoint. For more information on conditions, see the
     CONDITION command. 

enable <checknum>
disable <checknum>
     Each checkpoint can be enabled or disabled.  This command allows
     changing between these states. 

command <checknum> "<command>"
     When checkpoint `checknum' is hit, the specified command is
     executed by the monitor.  Note that the `x' command is not yet
     supported as a command argument. 

condition <checknum> if <cond_expr>
cond <checknum> if <cond_expr>
     Each time the specified checkpoint is examined, the condition is
     evaluated.  If it evalutes to true, the checkpoint is activated.
     Otherwise, it is ignores.  If registers are specified in the
     expression, the values used are those at the time the checkpoint
     is examined, not when the condition is set.  Currently, the
     cond_expr is very limited. You can use registers (.A, .X, .Y,
     .PC, and .SP) and compare against other registers or absolute
     values. For example, the following are all valid conditions: .A
     == 0, .X == .Y, 8:.X == .X, .A != 5, .A < .X.  However, you
     cannot specify memory contents and compare that.  

delete <checknum>
del <checknum>
     Delete the specified checkpoint. 

ignore <checknum> [<count>]
     Ignore a checkpoint after a given number of crossings.  If no
     count is given, the default value is 1. 

trace [load|store|exec] [address [address] [if <cond_expr>]]
tr [load|store|exec] [address [address] [if <cond_expr>]]
     This command is similar to the `break' command except that it
     operates on tracepoints.  A tracepoint differs from a breakpoint
     by not stopping execution but simply printing the PC, giving the
     user an execution trace.  The second optional address can be
     used to specify the end of an range of addresses to be traced.
     If no addresses are given, a list of all the checkpoints is
     printed. The "load|store|exec" parameter can be either "load",
     "store" or "exec" (or any combination of these) to determine
     which operation the monitor traces. If not specified, the
     monitor traces all operations. A conditional expression can also
     be specified for the tracepoint. For more information on
     conditions, see the CONDITION command. 

until [<address>]
un [<address>]
     If no address is given, the currently valid breakpoints are
     printed. If an address is given, a temporary breakpoint is set
     for that address and the breakpoint number is printed.  Control
     is returned to the emulator by this command.  The breakpoint is
     deleted once it is hit. 

watch [load|store|exec] [address [address] [if <cond_expr>]]
w [load|store|exec] [address [address] [if <cond_expr>]]
     This command is similar to the `break' command except that it
     operates on watchpoints.  A watchpoint differs from a breakpoint
     by stopping on a read and/or write to an address or range of
     addresses. If no addresses are given, a list of all the
     checkpoints is printed. The "load|store|exec" parameter can be
     either "load", "store" or "exec" (or any combination of these)
     to determine on which operation the monitor breaks. If not
     specified, the monitor breaks on "load" and "store" operations.
     A conditional expression can also be specified for the
     watchpoint. For more information on conditions, see the
     CONDITION command.   


@EndNode

@Node "General commands" "vice.guide/General commands"
@Next "Disk commands"
@Prev "Checkpoint commands"
@Toc "Monitor"

General commands
=================

    
     

cd <directory>
     Change the working directory. 

device [c:|d:]
dev [c:|d:]
     Set the default memory device to either the computer (`c:') or
     the disk (`d:'). 

dir [<directory>]
ls [<directory>]
     Display the directory contents. 

pwd
     Show current working directory. 

radix [H|D|O|B]
rad [H|D|O|B]
     Set the default radix to hex, decimal, octal, or binary.  With no
     argument, the current radix is printed.   


@EndNode

@Node "Disk commands" "vice.guide/Disk commands"
@Next "Command file commands"
@Prev "General commands"
@Toc "Monitor"

Disk commands
==============

   
     

attach <filename> <device>
     Attach file to device. (device 32 = cart) 

block_read <track> <sector> [<address>]
br <track> <sector> [<address>]
     Read the block at the specified track and sector.  If an address
     is specified, the data is loaded into memory.  If no address is
     given, the data is displayed using the default datatype. 

block_write <track> <sector> <address>
bw <track> <sector> <address>
     Write a block of data at `address' to the specified track and
     sector of disk in drive 8. 

detach <device>
     Detach file from device. (device 32 = cart) 

@<disk command>
     Perform a disk command on the currently attached disk image on
     drive 8.  The specified disk command is sent to the drive's
     channel #15. 

load "<filename>" <device> [<address>]
l "<filename>" <device> [<address>]
     Load the specified file into memory.  If no address is given, the
     file is loaded to the address specified by the first two bytes
     read from the file.  If address is given, the file is loaded to
     the specified address and the first two bytes read from the file
     are skipped.  If device is 0, the file is read from the file
     system. 

list [<directory>]
     List disk contents. 

bload "<filename>" <device> <address>
bl "<filename>" <device> <address>
     Load the specified file into memory at the specified address. If
     device is 0, the file is read from the file system. 

save "<filename>" <device> <address1> <address2>
s "<filename>" <device> <address1> <address2>
     Save the memory from address1 to address2 to the specified file.
     Write two-byte load address. If device is 0, the file is written
     to the file system. 

bsave "<filename>" <device> <address1> <address2>
bs "<filename>" <device> <address1> <address2>
     Save the memory from address1 to address2 to the specified file.
     If device is 0, the file is written to the file system.   


@EndNode

@Node "Command file commands" "vice.guide/Command file commands"
@Next "Label commands"
@Prev "Disk commands"
@Toc "Monitor"

Command file commands
======================

    
     

playback "<filename>"
pb "<filename>"
     Monitor commands from the specified file are read and executed.
     This command stops at the end of file or when a STOP command is
     read. 

record "<filename>"
rec "<filename>"
     After this command, all commands entered are written to the
     specified file until the STOP command is entered. 

stop
     Stop recording commands.  See `record'.  


@EndNode

@Node "Label commands" "vice.guide/Label commands"
@Next "Miscellaneous commands"
@Prev "Command file commands"
@Toc "Monitor"

Label commands
===============

    
     

add_label <address> <label>
al <address> <label>
     Map a given address to a label.  This label can be used when
     entering assembly code and is shown during disassembly.
     Additionally, it can be used whenever an address must be
     specified.  <label> is the name of the label; it must start
     with a dot (".") in order for the monitor to recognize it as a
     label. 

delete_label [<memspace>] <label>
dl [<memspace>] <label>
     Remove the specified label from the label tables.  If no memory
     space is checked, all tables are checked. 

load_labels [<memspace>] "<filename>"
ll [<memspace>] "<filename>"
     Load a file containing a mapping of labels to addresses.  If no
     memory space is specified, the default readspace is used. 
     The file must contain commands the monitor understands, e.g.
     add_label. The compiler cc65 can create such label files. 
     Vice can also load label files created by the Acme assembler.
     Their syntax is e.g. "labelname = $1234 ; Maybe a comment". A
     dot will be added automatically to label names assigned in this
     way to fit to the Vice label syntax. Normally the semicolon
     seperates commands but after an assignment of this kind it may be
     used to start a comment to end of line, so unchanged Acme label
     files can be fed into Vice. 

save_labels [<memspace>] "<filename>"
sl [<memspace>] "<filename>"
     Save labels to a file.  If no memory space is specified, all of
     the labels are saved. 

show_labels [<memspace>]
shl [<memspace>]
     Display current label mappings.  If no memory space is specified,
     show all labels.   


@EndNode

@Node "Miscellaneous commands" "vice.guide/Miscellaneous commands"
@Prev "Label commands"
@Toc "Monitor"

Miscellaneous commands
=======================

    
     

cartfreeze
     Use cartridge freeze. 

cpu <type>
     Specify the type of CPU currently used (6502/z80). 

exit
x
     Leave the monitor and return to execution. 

export
exp
     Print out list of attached expansion port devices. 

help [<command>]
     If no argument is given, prints out a list of all available
     commands. If an argument is given, prints out specific help for
     that command. 

keybuf "<string>"
     Put the specified string into the keyboard buffer. Note that you
     can specify specific keycodes by using C-style escaped hexcodes
     ("\x0a"). 

print <expression>
p <expression>
     Evaluate the specified expression and output the result. 

resourceget "<resource>"
resget "<resource>"
     Displays the value of the `resource'. 

resourceset "<resource>" "<value>"
resset "<resource>" "<value>"
     Sets the value of the `resource'. 

load_resources "<file>"
resload "<file>"
     Load resources from `file'. 

save_resources "<file>"
ressave "<file>"
     Save resources to `file'. 

screenshot "<filename>" [<format>]
scrsh "<filename>" [<format>]
     Take a screenshot. `format': default = BMP, 1 = PCX, 2 = PNG, 3
     = GIF, 4 = IFF. 

tapectrl <command>
     Control the datasette. `command': 0 = stop, 1 = start, 2 =
     forward, 3 = rewind, 4 = record, 5 = reset, 6 = reset counter.
     

quit
     Exit the emulator immediately. 

~ <number>
     Display the specified number in decimal, hex, octal and binary.
       


@EndNode

@Node "c1541" "vice.guide/c1541"
@Next "File formats"
@Prev "Monitor"
@Toc "Top"

c1541
******

    VICE is provided with a complete stand-alone disk image
maintenance utility, called `c1541'.  You can either invoke it
from the command line or from within one of the VICE emulators, using
the "Run c1541" command which will open a new `xterm' window with a
running `c1541' in it.  The syntax is: 

   c1541 [IMAGE1 [IMAGE2]] [COMMAND1 COMMAND2 ... COMMANDN]  example
 `IMAGE1' and `IMAGE2' are disk image names that can be attached
before `c1541' starts.  `c1541' can handle up to two disk images at
the same time by using two virtual built-in drives, numbered `8' and
`9'; `IMAGE1' (if present) is always attached to drive `8', while
`IMAGE2' is attached to drive `9'.  `COMMAND's specified on the
command-line all begin with the minus sign (`-'); if present, `c1541'
executes them in the same order as they are on the command line and
returns a zero error code if they were successful.  If any of the
`COMMAND's fails, `c1541' stops and returns a nonzero error code. 
If no `COMMAND's are specified at all, `c1541' enters interactive
mode, where you can type commands manually.  Commands in interactive
mode are the same as commands in batch mode, but do not require a
leading `-'.  As with the monitor, file name completion and command
line editing with history are provided via GNU `readline'.  Use the
command `quit' or press `C-d' to exit. 

   * c1541 file specification:: * c1541 quoting:: * c1541 commands
and options:: * c1541 executing shell commands::  menu 


@EndNode

@Node "c1541 file specification" "vice.guide/c1541 file specification"
@Next "c1541 quoting"
@Prev "c1541"
@Toc "c1541"

Specifying files in c1541
==========================

    When accessing CBM DOS files (i.e. files that reside on disk
images), c1541 uses a special syntax that lets you access files on
both drive 8 and 9.  If you prepend the file name with `@8:' or
`@9:', you will specified that file is to be found or created on
drive 8 and 9, respectively.  For instance, 

   @8:somefile  example  will name file named `somefile' on unit
8, while 

   @9:somefile  example  will name file named `somefile' on unit
9. 


@EndNode

@Node "c1541 quoting" "vice.guide/c1541 quoting"
@Next "c1541 commands and options"
@Prev "c1541 file specification"
@Toc "c1541"

Using quotes and backslashes
=============================

    You can use quotes (`"') in a command to embed spaces into file
names.  For instance, 

   read some file  example  will read file `some' from the disk
image and write it into the file system as `file', while 

   read "some file"  example  will copy `some file' into the file
system, with the name `some file'.  The backslash character (`\')
has a special meaning too: it lets you literally insert the following
character no matter what it is.  For example, 

   read some\ file  example  will copy file `some file' into the
file system, while 

   read some\ file this\"file  example  will copy `some file'
into the file system with name `this"file' (with an embedded quote).
 


@EndNode

@Node "c1541 commands and options" "vice.guide/c1541 commands and options"
@Next "c1541 executing shell commands"
@Prev "c1541 quoting"
@Toc "c1541"

c1541 commands and options
===========================

    This is a list of the `c1541' commands.  They are shown in their
interactive form, without the leading `-'. Square brackets []
indicate an optional part, and "<COMMAND>" translates to a disk
command according to CBM DOS, like "i0" for example. 
     

 [<command>]
     Execute specified CBM DOS command and print the current status of
     the drive.  If no `command' is specified, just print the
     status. 

? [<command>]
     Explain specified command.  If no command is specified, list
     available ones. 

attach <diskimage> [<unit>]
     Attach `diskimage' to `unit' (default unit is 8). 

block <track> <sector> <disp> [<drive>]
     Show specified disk block in hex form. 

copy <source1> [<source2> ... <sourceN>] <destination>
     Copy `source1' ... `sourceN' into destination.  If N > 1,
     `destination' must be a simple drive specifier (`@n:'). 

delete <file1> [<file2> ... <fileN>]
     Delete the specified files. 

exit
     Exit (same as `quit'). 

extract
     Extract all the files to the file system. 

format <diskname,id> [<type> <imagename>] [<unit>]
     If `unit' is specified, format the disk in unit `unit'.  If
     `type' and `imagename' are specified, create a new image named
     `imagename', attach it to unit 8 and format it.  `type' is a
     disk image type, and must be either `x64', `d64' (both
     VC1541/2031), `g64' (VC1541/2031 but in GCR coding), `d71'
     (VC1571), `d81' (VC1581), `d80' (CBM8050) or `d82'
     (CBM8250/1001). Otherwise, format the disk in the current unit,
     if any. 

gcrformat <diskname,id> <imagename>
     Create and format a G64 disk image named `imagename'. 

help [<command>]
     Explain specified command.  If no command is specified, list
     available ones. 

info [<unit>]
     Display information about unit `unit' (if unspecified, use the
     current one). 

list [<pattern>]
     List files matching `pattern' (default is all files). 

quit
     Exit (same as `exit'). 

read <source> [<destination>]
     Read `source' from the disk image and copy it into `destination'
     in the file system.  If `destination' is not specified, copy it
     into a file with the same name as `source'.", 

rename <oldname> <newname>
     Rename `oldname' into `newname'.  The files must be on the same
     drive. 

tape <t64name> [<file1> ... <fileN>]
     Extract files from a T64 image. 

unit <number>
     Make unit `number' the current unit. 

unlynx <lynxname> [<unit>]
     Extract the specified Lynx image file into the specified unit
     (default is the current unit). 

validate [<unit>]
     Validate the disk in unit `unit'.  If `unit' is not specified,
     validate the disk in the current unit. 

write <source> [<destination>]
     Write `source' from the file system into `destination' on a disk
     image. 

zcreate <x64name> <zipname> [<label,id>]
     Create an X64 disk image out of a set of four Zipcoded files
     named `1!zipname', `2!zipname', `3!zipname' and `4!zipname'.
      


@EndNode

@Node "c1541 executing shell commands" "vice.guide/c1541 executing shell commands"
@Prev "c1541 commands and options"
@Toc "c1541"

Executing shell commands
=========================

    If you want to execute a shell command from withing `c1541',
just prepend it with an exclamation mark (`!').  For example, 

   !ls -la  example  will execute the command `ls -la', which
will show you all the files in the current directory. 

c1541 examples
===============

    
c1541 -attach test.d64 -write test.prg testfile
     Write `test.prg' to `test.d64' as `testfile'. 

cartconv
*********

    The cartconv program is a cartridge conversion utility, it can
convert between binary and .crt images and it can 'insert' binary
and/or .crt images into the EPROM type of cartridges. 

cartconv command line options
==============================

    The cartconv program has the following parameters: 
-i "input name"
     This parameter is mandatory, it should contain the name of the
     binary/.crt file you want to convert. For the EPROM type of
     cartridges this parameter can be used multiple times to insert
     images into the resulting file.

-o "output name"
     This parameter is mandatory, it should contain the name of the
     binary/.crt file you want to convert the input file to.

-t carttype
     This parameter is optional. It is only needed when converting to a
     .crt file. See below for the supported cartridge types.

-n "cart name"
     This parameter is optional and is used as the cartridge name when
     creating a .crt file.

-l loadaddress
     This parameter is optional and is used as the load-address when
     converting a .crt file to a .prg file, or when converting to a
     generic type .crt file.

-f "input name"
     This parameter is optional, and is meant to output information
     about the named file. It can't be used in conjuction with any of
     the other parameters.

-r
     This parameter is optional, it enables repair mode (accept broken
     input files)  The following cartridge types are supported: 
bin
     Binary .bin file (Default crt->bin)

normal
     Generic 8kB/12kB/16kB .crt file (Default bin->crt)

prg
     Binary C64 .prg file with load-address

ulti
     Ultimax mode 4kB/8kB/16kB .crt file

ap
     Atomic Power .crt file

ar2
     Action Replay MK2 .crt file

ar3
     Action Replay MK3 .crt file

ar4
     Action Replay MK4 .crt file

ar5
     Action Replay V5 .crt file

cap
     Capture .crt file

comal
     Comal 80 .crt file

dep256
     Dela EP256 .crt file, extra files can be inserted (1)(2)

dep64
     Dela EP64 .crt file, extra files can be inserted (1)

dep7x8
     Dela EP7x8 .crt file, extra files can be inserted (1)(2)(3)

din
     Dinamic .crt file

dsm
     Diashow-Maker .crt file

easy
     EasyFlash .crt file

epyx
     Epyx FastLoad .crt file

exos
     EXOS .crt file

expert
     Expert Cartridge .crt file

fc1
     The Final Cartridge .crt file

fc3
     The Final Cartridge III .crt file

fcp
     Final Cartridge Plus .crt file

ff
     Freeze Frame .crt file

fm
     Freeze Machine .crt file

fp
     Fun Play .crt file

gk
     Game Killer .crt file

gs
     C64 Games System .crt file

ide64
     IDE64 .crt file

ieee
     IEEE-488 Interface .crt file

kcs
     KCS Power Cartridge .crt file

mach5
     MACH 5 .crt file

md
     Magic Desk .crt file

mf
     Magic Formel .crt file

mikro
     Mikro Assembler .crt file

mmc64
     MMC64 .crt file

mmcr
     MMC Replay .crt file

mv
     Magic Voice .crt file

ocean
     Ocean .crt file

p64
     Prophet64 .crt file

rep256
     REX 256k EPROM Cart .crt file, extra files can be inserted
     (1)(2)(3)

ross
     ROSS .crt file

rr
     Retro Replay .crt file

ru
     REX Utility .crt file

s64
     Snapshot 64 .crt file

sb
     Structured BASIC .crt file

se5
     Super Explode V5.0 .crt file

sg
     Super Games .crt file

simon
     Simons' BASIC .crt file

ss4
     Super Snapshot V4 .crt file

ss5
     Super Snapshot V5 .crt file

star
     Stardos .crt file

wl
     Westermann Learning .crt file

ws
     Warp Speed .crt file

zaxxon
     Zaxxon .crt file 

   (1) insertion of 32kB EPROM files supported.  (2) insertion of 8kB
.crt/binary files supported.  (3) insertion of 16kB .crt/binary files
supported.  itemize 

cartconv examples
==================

   
cartconv -i foo.crt -o foo.bin
     Convert a .crt file to a binary file with no load-address.

cartconv -t prg -i foo.crt -o foo.prg
     Convert a .crt file to a .prg file with default load-address.

cartconv -t prg -l 49152 -i foo.crt -o foo.prg
     Convert a .crt file to a .prg file with 49152 as the
     load-address.

cartconv -t ocean -i foo.bin -o foo.crt
     Convert a binary file to an ocean type cartridge.

cartconv -t dep64 -i dep64.bin -i eprom.prg -o foo.crt
     Inserting a 32kB EPROM file into an dep64 type cartridge.

step 1 : use the dep64 binary file in VICE as a generic 8kB cartridge.
step 2 : generate an EPROM file.
step 3 : get the EPROM file to the host computer.
step 4 : insert the EPROM file into the final dep64 .crt file:
   cartconv -t dep256 -i dep256.bin -i somegame.crt -o foo.crt Insert
an 8kB .crt file into a dep256 type cartridge.  cartconv -t rep256 -i
rep256.bin -i foo1.crt -i foo2.crt -i foo3.crt -o foo.crt Insert
multiple 8kB .crt files into a rep256 type cartridge.  cartconv -f
foo.crt Get information about a .crt file.  table 

petcat
*******

    The petcat program is a text conversion utility, it can convert
between ASCII, PETSCII and tokenized BASIC. 

petcat command line options
============================

   
-help
     Output help text

-v
     Same as above

-c
     controls (interpret also control codes) (default if textmode)

-nc
     no controls (suppress control codes in printout) (default if
     non-textmode)

-ic
     interpret control codes case-insensitive

-h
     write header (default if output is stdout)

-nh
     no header (default if output is a file)

-skip <n>
     Skip <n> bytes in the beginning of input file. Ignored on P00.

-text
     Force text mode

-<version>
     use keywords for <version> instead of the v7.0 ones

-w<version>
     tokenize using keywords on specified Basic version.

-k<version>
     list all keywords for the specified Basic version

-k
     list all Basic versions available.

-l
     Specify load address for program (in hex, no loading chars!).

-o <name>
     Specify the output file name

-f
     Force overwritten the output file. The default depends on the
     BASIC version.  BASIC Versions:
1
     PET Basic V1.0

2
     Basic v2.0

superexp
     Basic v2.0 with Super Expander (VIC20)

turtle
     Basic v2.0 with Turtle Basic by Craig Bruce (VIC20)

mighty
     Basic v2.0 with Mighty Basic by Craig Bruce (VIC20)

a
     Basic v2.0 with AtBasic (C64)

simon
     Basic v2.0 with Simon's Basic extension (C64)

speech
     Basic v2.0 with Speech Basic v2.7 (C64)

F
     Basic v2.0 with Final Cartridge III (C64)

ultra
     Basic v2.0 with Ultrabasic-64 (C64)

graph
     Basic v2.0 with Graphics basic (C64)

WSB
     Basic v2.0 with WS basic (C64)

WSBF
     Basic v2.0 with WS basic final (C64)

Pegasus
     Basic v2.0 with Pegasus basic 4.0 (C64)

Xbasic
     Basic v2.0 with Xbasic (C64)

Drago
     Basic v2.0 with Drago basic 2.2 (C64)

REU
     Basic v2.0 with REU-basic (C64)

Lightning
     Basic v2.0 with Basic Lightning (C64)

magic
     Basic v2.0 with Magic Basic (C64)

easy
     Basic v2.0 with Easy Basic (VIC20)

blarg
     Basic v2.0 with Blarg (C64)

Game
     Basic v2.0 with Game Basic (C64)

BSX
     Basic v2.0 with Basex (C64)

superbas
     Basic v2.0 with Super Basic (C64)

exp20
     Basic 2.0 with Expanded Basic (VIC20)

exp64
     Basic 2.0 with Expanded Basic (C64)

sxc
     Basic 2.0 with Super Expander Chip (C64)

warsaw
     Basic 2.0 with Warsaw Basic (C64)

4v
     Basic 2.0 with Basic 4.0 extensions (VIC20)

4 -w4e
     PET Basic v4.0 program (PET/C64)

5
     Basic 2.0 with Basic 5.0 extensions (VIC20)

3
     Basic v3.5 program (C16)

70
     Basic v7.0 program (C128)

71
     Basic v7.1 program (C128)

10
     Basic v10.0 program (C64DX) 

petcat examples
================

   
petcat -2 -o outputfile.txt - inputfile.prg
     Convert inputfile.prg to a text file in outputfile.txt, using
     BASIC V2 only

petcat -wsimon -o outputfile.prg - inputfile.txt
     Convert inputfile.txt to a PRG file in outputfile.prg, using
     Simon's BASIC  


@EndNode

@Node "File formats" "vice.guide/File formats"
@Next "Acknowledgments"
@Prev "c1541"
@Toc "Top"

The emulator file formats
**************************

    This chapter gives a technical description of the various files
supported by the emulators. 

   * T64::                         The tape image format * G64::
                  The GCR-encoded disk image format * D64::
              The D64 disk image format * D71::
  The D71 disk image format * D80::                         The D80
disk image format * D81::                         The D81 disk image
format * D82::                         The D82 disk image format *
X64::                         The X64 disk image format * P00::
                 The P00 image format  menu 


@EndNode

@Node "T64" "vice.guide/T64"
@Next "G64"
@Prev "File formats"
@Toc "File formats"

The T64 tape image format
==========================

    (This section was taken from the C64S distribution.)  The
`T64' File Structure was developed by Miha Peternel for use in the
C64S emulator.  It is easy to use and allows future extensions. 

   * T64 file structure:: * T64 tape record:: * T64 file record::
menu  


@EndNode

@Node "T64 file structure" "vice.guide/T64 file structure"
@Next "T64 tape record"
@Prev "T64"
@Toc "T64"

T64 File structure
-------------------

      .3 .3 .4  Offset  Size  Description  0  64  tape
record  64  32*n  file records for n directory entries
64+32*n  varies  binary contents of the files  multitable 


@EndNode

@Node "T64 tape record" "vice.guide/T64 tape record"
@Next "T64 file record"
@Prev "T64 file structure"
@Toc "T64"

Tape Record
------------

      .3 .3 .4  Offset  Size  Description  0  32  DOS
tape description + EOF (for type)  32  2  tape version ($0200)
34  2  number of directory entries  36  2  number of used
entries (can be 0 in my loader)  38  2  free  40  24  user
description as displayed in tape menu  multitable 


@EndNode

@Node "T64 file record" "vice.guide/T64 file record"
@Prev "T64 tape record"
@Toc "T64"

File record
------------

      .3 .3 .4  Offset  Size  Description  0  1  entry
type (see below)  1  1  C64 file type  2  2  start address
4  2  end address  6  2  free  8  4  offset of file
contents start within T64 file  12  4  free  16  16  C64
file name  multitable  Valid entry types are:    .3 .7
Code  Explanation  `0'  free entry  `1'  normal tape file
`2'  tape file with header: header is saved just before file data
`3'  memory snapshot v0.9, uncompressed  `4'  tape block  `5'
digitized stream  `6' ... `255'  reserved  multitable 
Notes: 
     VICE only supports file type `1'.

     Types `3', `4' and `5' are subject to change (and are rarely
     used). 


@EndNode

@Node "G64" "vice.guide/G64"
@Next "D64"
@Prev "T64"
@Toc "File formats"

The G64 GCR-encoded disk image format
======================================

    (This section was contributed by Peter Schepers and slightly
edited by Ettore Perazzoli.)  This format was defined in 1998 as
a cooperative effort between several emulator people, mainly Per
Håkan Sundell, author of the CCS64 C64 emulator, Andreas Boose of the
VICE CBM emulator team and Joe Forster/STA, the author of Star
Commander.  It was the first real public attempt to create a format
for the emulator community which removed almost all of the drawbacks
of the other existing image formats, namely `D64'.  The intention
behind `G64' is not to replace the widely used `D64' format, as `D64'
works fine with the vast majority of disks in existence.  It is
intended for those small percentage of programs which demand to work
with the 1541 drive in a non-standard way, such as reading or writing
data in a custom format.  The best example is with speeder software
such as Action Cartridge in Warp Save mode or Vorpal which write
track/sector data in another format other than standard GCR.  The
other obvious example is copy-protected software which looks for some
specific data on a track, like the disk ID, which is not stored in a
standard `D64' image.  `G64' has a deceptively simply layout for
what it is capable of doing.  We have a signature, version byte, some
predefined size values, and a series of offsets to the track data and
speed zones.  It is what's contained in the track data areas and
speed zones which is really at the heart of this format.  Each
track entry in simply the raw stream of GCR data, just what a read
head would see when a diskette is rotating past it.  How the data gets
interpreted is up to the program trying to access the disk.  Because
the data is stored in such a low-level manner, just about anything
can be done.  Most of the time I would suspect the data in the track
would be standard sectors, with SYNC, GAP, header, data and
checksums.  The arrangement of the data when it is in a standard GCR
sector layout is beyond the scope of this document.  Since it is
a flexible format in both track count and track byte size, there is
no "standard" file size.  However, given a few constants like 42
tracks and halftracks, a track size of 7928 bytes and no speed offset
entries, the typical file size will a minimum of 333744 bytes. 
Below is a dump of the header, broken down into its various parts.
After that will be an explanation of the track offset and speed zone
offset areas, as they demand much more explanation. 

   Addr  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ---
---------------------------------------------- 0000: 47 43 52 2D 31
35 34 31 00 54 F8 1E .. .. .. ..  example    .2 .8  Offset
Description  $0000-0007  File signature (`GCR-1541')  $0008
`G64' version (presently only $00 defined)  $0009  Number of tracks
in image (usually $54, decimal 84)  $000A-000B  Size of each stored
track in bytes (usually 7928, or $1EF8) in LO/HI format.  multitable
 An obvious question here is "why are there 84 tracks defined when a
normal `D64' disk only has 35 tracks?"  Well, by definition, this
image includes all half-tracks, so there are actually 42 tracks and 42
half tracks.  The 1541 stepper motor can access up to 42 tracks and
the in-between half-tracks.  Even though using more than 35 tracks is
not typical, it was important to define this format from the start
with what the 1541 is capable of doing, and not just what it
typically does.  At first, the defined track size value of 7928
bytes may seem to be arbitrary, but it is not.  It is determined by
the fastest write speed possible (speed zone 0), coupled with the
average rotation speed of the disk (300 rpm).  After some math, the
answer that actually comes up is 7692 bytes.  Why the discrepency
between the actual size of 7692 and the defined size of 7928? Simply
put, not all drives rotate at 300 rpm. Some can be faster or slower,
so a upper safety margin of +3% was built added, in case some disks
rotate slower and can write more data.  After applying this safety
factor, and some rounding-up, 7928 bytes per track was arrived at.
 Also note that this upper limit of 7928 bytes per track really only
applies to 1541 and compatible disks.  If this format were applied to
another disk type like the SFD1001, this value would be higher. 
Below is a dump of the first section of a `G64' file, showing the
offsets to the data portion for each track and half-track entry.
Following that is a dump of the speed zone offsets. 

   Addr  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ---
---------------------------------------------- 0000: .. .. .. .. ..
.. .. .. .. .. .. .. AC 02 00 00 0010: 00 00 00 00 A6 21 00 00 00 00
00 00 A0 40 00 00 0020: 00 00 00 00 9A 5F 00 00 00 00 00 00 94 7E 00
00 0030: 00 00 00 00 8E 9D 00 00 00 00 00 00 88 BC 00 00 0040: 00
00 00 00 82 DB 00 00 00 00 00 00 7C FA 00 00 0050: 00 00 00 00 76 19
01 00 00 00 00 00 70 38 01 00 0060: 00 00 00 00 6A 57 01 00 00 00 00
00 64 76 01 00 0070: 00 00 00 00 5E 95 01 00 00 00 00 00 58 B4 01 00
0080: 00 00 00 00 52 D3 01 00 00 00 00 00 4C F2 01 00 0090: 00 00 00
00 46 11 02 00 00 00 00 00 40 30 02 00 00A0: 00 00 00 00 3A 4F 02 00
00 00 00 00 34 6E 02 00 00B0: 00 00 00 00 2E 8D 02 00 00 00 00 00 28
AC 02 00 00C0: 00 00 00 00 22 CB 02 00 00 00 00 00 1C EA 02 00
00D0: 00 00 00 00 16 09 03 00 00 00 00 00 10 28 03 00 00E0: 00 00 00
00 0A 47 03 00 00 00 00 00 04 66 03 00 00F0: 00 00 00 00 FE 84 03 00
00 00 00 00 F8 A3 03 00 0100: 00 00 00 00 F2 C2 03 00 00 00 00 00 EC
E1 03 00 0110: 00 00 00 00 E6 00 04 00 00 00 00 00 E0 1F 04 00
0120: 00 00 00 00 DA 3E 04 00 00 00 00 00 D4 5D 04 00 0130: 00 00 00
00 CE 7C 04 00 00 00 00 00 C8 9B 04 00 0140: 00 00 00 00 C2 BA 04 00
00 00 00 00 BC D9 04 00 0150: 00 00 00 00 B6 F8 04 00 00 00 00 00 ..
.. .. ..  example    .2 .8  Offset  Description
$000C-000F  Offset to stored track 1.0 ($000002AC, in LO/HI format,
see below for more)  $0010-0013  Offset to stored track 1.5
($00000000)  $0014-0017  Offset to stored track 2.0 ($000021A6)
...  $0154-0157  Offset to stored track 42.0 ($0004F8B6)
$0158-015B  Offset to stored track 42.5 ($00000000)  multitable 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 0150: .. .. .. .. ..
.. .. .. .. .. .. .. 03 00 00 00 0160: 00 00 00 00 03 00 00 00 00 00
00 00 03 00 00 00 0170: 00 00 00 00 03 00 00 00 00 00 00 00 03 00 00
00 0180: 00 00 00 00 03 00 00 00 00 00 00 00 03 00 00 00 0190: 00
00 00 00 03 00 00 00 00 00 00 00 03 00 00 00 01A0: 00 00 00 00 03 00
00 00 00 00 00 00 03 00 00 00 01B0: 00 00 00 00 03 00 00 00 00 00 00
00 03 00 00 00 01C0: 00 00 00 00 03 00 00 00 00 00 00 00 03 00 00 00
01D0: 00 00 00 00 03 00 00 00 00 00 00 00 03 00 00 00 01E0: 00 00 00
00 02 00 00 00 00 00 00 00 02 00 00 00 01F0: 00 00 00 00 02 00 00 00
00 00 00 00 02 00 00 00 0200: 00 00 00 00 02 00 00 00 00 00 00 00 02
00 00 00 0210: 00 00 00 00 02 00 00 00 00 00 00 00 01 00 00 00
0220: 00 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 0230: 00 00 00
00 01 00 00 00 00 00 00 00 01 00 00 00 0240: 00 00 00 00 01 00 00 00
00 00 00 00 00 00 00 00 0250: 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 0260: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0270: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0280: 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 0290: 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 02A0: 00 00 00 00 00 00 00 00 00 00 00 00 ..
.. .. ..  example    .2 .8  Offset  Description
$015C-015F  Speed zone entry for track 1 ($03, in LO/HI  format, see
below for more)  $0160-0163  Speed zone entry for track 1.5 ($03)
...  $02A4-02A7  Speed zone entry for track 42 ($00)
$02A8-02AB  Speed zone entry for track 42.5 ($00)  multitable 
Starting here at $02AC is the first track entry (from above, it is the
first entry for track 1.0)  The track offsets (from above) require
some explanation.  When one is set to all 0's, no track data exists
for this entry.  If there is a value, it is an absolute reference
into the file (starting from the beginning of the file).  From the
track 1.0 entry we see it is set for $000002AC.  Going to that file
offset, here is what we see... 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 02A0: .. .. .. .. ..
.. .. .. .. .. .. .. 0C 1E FF FF 02B0: FF FF FF 52 54 B5 29 4B 7A 5E
95 55 55 55 55 55 02C0: 55 55 55 55 55 55 FF FF FF FF FF 55 D4 A5 29
4A 02D0: 52 94 A5 29 4A 52 94 A5 29 4A 52 94 A5 29 4A 52  example
   .2 .8  Offset  Description  $02AC-02AD  Actual size of
stored track (7692 or $1E0C, in LO/HI format)  $02AE-02AE+$1E0C
Track data  multitable  Following the track data is filler bytes.
In this case, there are 368 bytes of unused space.  This space can
contain anything, but for the sake of those wishing to compress these
images for storage, they should all be set to the same value.  In the
sample I used, these are all set to $FF.  Below is a dump of the
end of the track 1.0 data area.  Note the actual track data ends at
address $20B9, with the rest of the block being unused, and set to
$FF. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 1FE0: 52 94 A5 29 4A
52 94 A5 29 4A 52 94 A5 29 4A 52 1FF0: 94 A5 29 4A 52 94 A5 29 4A 52
94 A5 29 4A 52 94 2000: A5 29 4A 52 94 A5 29 4A 52 94 A5 29 4A 52 94
A5 2010: 29 4A 52 94 A5 29 4A 52 94 A5 29 4A 52 94 A5 29 2020: 4A
52 94 A5 29 4A 52 94 A5 29 4A 52 94 A5 29 4A 2030: 55 55 55 55 55 55
FF FF FF FF FF FF FF FF FF FF 2040: FF FF FF FF FF FF FF FF FF FF FF
FF FF FF FF FF 2050: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
2060: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 2070: FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF 2080: FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF 2090: FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF 20A0: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
20B0: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 20C0: FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF 20D0: FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF 20E0: FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF 20F0: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
2100: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 2110: FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF 2120: FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF 2130: FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF 2140: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
2150: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 2160: FF FF FF
FF FF FF FF FF FF FF FF FF FF FF FF FF 2170: FF FF FF FF FF FF FF FF
FF FF FF FF FF FF FF FF 2180: FF FF FF FF FF FF FF FF FF FF FF FF FF
FF FF FF 2190: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
21A0: FF FF FF FF FF FF .. .. .. .. .. .. .. .. .. ..  example 
The speed offset entries can be a little more complex. The 1541 has
four speed zones defined, which means the drive can write data at
four distinct speeds.  On a normal 1541 disk, these zones are as
follows:    .5 .5  Track Range  Speed Zone  1-17  3
(highest writing speed)  18-24  2  25-30  1  31 and up  0
(lowest writing speed)  multitable  Note that you can, through
custom programming of the 1541, change the speed zone of any track to
something different (change the 3 to a 0) and write data differently.
From the dump of the speed offset entries above, we see that all the
entries are in the range of 0-3. If any entry is less than 4, this is
not considered a speed offset but defines the whole track to be
recorded at that one speed.  In the example I had, there were no
offsets defined, so no speed zone dump can be shown.  However, I can
define what should be there.  You will have a block of data, 1982
bytes long.  Each byte is encoded to represent the speed of 4 bytes
in the track offset area, and is broken down as follows: 

   Speed entry $FF:  in binary %11111111
|'|'|'|'                              | | | |
      | | | +- 4'th byte speed (binary 11, 3 dec)
         | | +-- 3'rd byte speed (binary 11, 3 dec)
           | +---- 2'nd byte speed (binary 11, 3 dec)
             +------ 1'st byte speed (binary 11, 3 dec)  example 
It was very smart thinking to allow for two speed zone settings, one
in the offset block and another defining the speed on a per-byte
basis.  If you are working with a normal disk, where each track is
one constant speed, then you don't need the extra blocks of
information hanging around the image, wasting space.  What may
not be obvious is the flexibility of this format to add tracks and
speed offset zones at will.  If a program decides to write a track
out with varying speeds, and no speed offset exist, a new block will
be created by appending it to the end of the image, and the offset
pointer for that track set to point to the new block.  If a track has
no offset yet, meaning it doesn't exist (like a half-track), and one
needs to be added, the same procedure applies.  The location of the
actual track or speed zone data is not important, meaning they do not
have to be in any particular order since they are all referenced by
the offsets at the beginning of the image. 

The P64 NRZI flux pulse disk image format
==========================================

     This section is taken from "P64 file format specification" by
Benjamin 'BeRo'  Rosseaux.  All values are in little endian order
!  

P64 Header Layout
------------------

   

   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+--------------------------------------------------------------+
0000: |'P'|'6'|'4'|'-'|'1'|'5'|'4'|'1'|    Version    |     Flags     |
 
+--------------+--------------+------------------------------+ 0010:
|     Size      | CRC32Checksum |
+------------------------------+  example           Version:
File format version, current is 0x00000000                    Size
Size of the following whole chunk content stream       
Flags:  Bit    0 = Write protect                    Bit 1-31 =
Reserved, all set to 0 when creating a file, 
     preserve existing value when updating        
CRC32CheckSum:  CRC32 checksum of the following whole chunk content
stream                 

P64 Chunk Header Layout
------------------------

   

   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+----------------------------------------------+ 0000: |Chunk
Signature|      Size     | CRC32Checksum |   
+----------------------------------------------+  example   Chunk
signature:  Signature of chunk                    Size:  Size of
the chunk data           CRC32CheckSum:  CRC32 checksum of the
chunk data                 

P64 Chunk 'HTPx' Layout
------------------------

                              | x = half track index byte |
                 +--------------------------+
          Track 18 = Half track 36 = Half track index byte decimal
value 36                                          Half track NRZI
transition flux pulse data chunk block                          

           

   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+--------------------------------------------------------------+
0000: |  Count pulses |     Size      | ..... Range-encoded data .... |
  
+--------------------------------------------------------------+
example      Count pulses:  Count of the NRZI transition flux
pulses in half track                     Size:  Size of the
range-encoded data             

'HTPx' Range encoded data format
---------------------------------

                 Hint: For a working C implememtation see p64.c and
p64.h  The range coder is a FPAQ0-style range coder combined with
12-bit 0-order  models, one model per byte with one bit per byte
processing. 


+-------------------------------------------------------------------------+
|   Sub stream     | Count of models |  Size per model  | Total value
bits |
+-----------------+----------------+-----------------+-----------------+
|     Position     |        4        |      65536       |        32
   |
+-----------------+----------------+-----------------+-----------------+
|     Strength     |        4        |      65536       |        32
   | 
+-----------------+----------------+-----------------+-----------------+
|   Position flag  |        1        |        2         |        1
   |
+-----------------+----------------+-----------------+-----------------+
|   Strenth flag   |        1        |        2         |        1
   | 
+-----------------+----------------+-----------------+-----------------+
+===Total models===|        10
|==================|==================|
+-------------------------------------------------------------------------+
example  All initial model state values are initialized with
zero.   All initial model probability values are initialized with
2048.   These model probability values will be updating in a
adaptive way on the fly and not precalculated before the encoding and
even not loaded before  the decoding, see pseudo code below. 
16000000 Hz / 5 rotations per second at 300 RPM = maximal 3200000 flux
pulses           So NRZI transition flux pulse positions are in the
0 .. 3199999 value range,  which is also a exact single rotation,
where each time unit is a cycle at  16 MHz with 300 RPM as a mapping
for the ideal case.        The NRZI transition flux pulse stength
are in the 0x00000000 .. 0xffffffff value range, where 0xffffffff
indices a strong flux pulse, that always  triggers, and 0x00000001
indices a weak flux pulse, that almost never  triggers, and
0x00000000 indices a flux pulse, that absolutly never  triggers.
               For 32-bit values, the model sub streams are
subdivided byte wide in a  little-endian manner, and each byte is
processed bitwise with model  probability shifting of 4 bits, just
as:  Pascal-Style pseudo code:

   procedure WriteDWord(Model, Value : longword);
      var ByteValue, ByteIndex, Context, Bit : longword;
            begin
                    for ByteIndex := 0 to 3 do begin
                            ByteValue := (Value shr (ByteIndex shl
3)) and $ff;                         Context := 1;
                                          for Bit := 7 downto 0 do
begin                                                Context :=
(Context shl 1) or RangeCoderEncodeBit(                   
        RangeCoderProbabilities[                               
               RangeCoderProbabilityOffsets[Model + ByteIndex] +     
                    (((RangeCoderProbabilityStates[Model + ByteIndex]
                         shl 8) or Context) and $ffff)], 4,
(ByteValue shr                           Bit) and 1);
                             end;
                              
RangeCoderProbabilityStates[Model+ByteIndex] := ByteValue;
   end;
      end;
             example  And for 1-bit flag values it is much
simpler, but also with model probability  shifting of 4 bits, just
as:  Pascal-Style pseudo code:

   procedure WriteBit(Model, Value : longword);
      begin
               RangeCoderProbabilityStates[Model] :=
                       RangeCoderEncodeBit(RangeCoderProbabilities[
                               RangeCoderProbabilityOffsets[Model] +
                             
RangeCoderProbabilityStates[Model]], 4, Value and 1);             
end;
    example  The position and strength values are delta-encoded.
If a value is equal to  the last previous value, then the value will
not encoded, instead, a flag for this will encoded. First the
position value will encoded, then the stength  value. If the last
position delta is 0, then it is a track stream end marker. 
Pascal-Style pseudo code:

   LastPosition := 0;
      PreviousDeltaPosition := 0
           
                  LastStrength := 0;
                       
                              for PulseIndex := 0 to PulseCount - 1
do begin                             
                                             DeltaPosition :=
Pulses[PulseIndex].Position - LastPosition;                if
PreviousDeltaPosition <> DeltaPosition then begin                     
   PreviousDeltaPosition := DeltaPosition;
       WriteBit(ModelPositionFlag, 1)
             WriteDWord(ModelPosition, DeltaPosition);
                 end else begin
                         WriteBit(ModelPositionFlag, 0);
                             end;
                                   LastPosition :=
Pulses[PulseIndex].Position;                              
                                                                  if
LastStrength <> Pulses[PulseIndex].Strength then begin                
   WriteBit(ModelStrengthFlag, 1)
       WriteDWord(ModelStrength, Pulses[PulseIndex].Strength -
LastStrength);      end else begin
                           WriteBit(ModelStrengthFlag, 0);
                                end;
                                        LastStrength :=
Pulses^[PulseIndex].Strength;                            
                                                               end;
                                                                    

   // End code
         WriteBit(ModelPositionFlag, 1);
               WriteDWord(ModelPosition, 0);
                      example   The decoding is simply just in
the another direction way.    Pseudo code for a FPAQ0-style
carryless range coder:  Pascal-Style pseudo code:

   procedure RangeCoderInit; // At encoding and decoding start
      begin
              RangeCode := 0;
                    RangeLow := 0;
                          RangeHigh := $ffffffff;
                              end;
                                   
                                          procedure RangeCoderStart;
// At decoding start                             var Counter :
longword;                                                       
begin
     for Counter := 1 to 4 do begin
            RangeCode := (RangeCode shl 8) or ReadByteFromInput;
                 end;
                     end;
                          
                                 procedure RangeCoderFlush; // At
encoding end                               var Counter : longword;
                                                  begin
                                                          for
Counter := 1 to 4 do begin                                           
   WriteByteToOutput(RangeHigh shr 24);
       RangeHigh := RangeHigh shl 8;
           end;
               end;
                     
                            procedure RangeCoderEncodeNormalize;
                                     begin
                                             while ((RangeLow xor
RangeHigh) and $ff000000) = 0 do begin              
WriteByteToOutput(RangeHigh shr 24);
    RangeLow := RangeLow shl 8;
         RangeHigh := (RangeHigh shl 8) or $ff;
                end;
                     end;
                           
                                  function RangeCoderEncodeBit(var
Probability : longword; Shift,            
 BitValue : longword) : longword;                begin
                                                         RangeMiddle
:= RangeLow + (((RangeHigh - RangeLow) shr 12) *             
                     Probability);                                  
 if BitValue <> 0 then begin
        inc(Probability, ($fff - Probability) shr Shift);
              RangeHigh := RangeMiddle;
                    end else begin
                            dec(Probability, Probability shr Shift);
                                  RangeLow := RangeMiddle + 1;
                                      end;
                                         
RangeCoderEncodeNormalize;
   result := BitValue;
       end;
            
                    procedure RangeCoderDecodeNormalize;
                           begin
                                   while ((RangeLow xor RangeHigh)
and $ff000000) = 0 do begin                   RangeLow := RangeLow
shl 8;                                                 RangeHigh :=
(RangeHigh shl 8) or $ff;                                 
RangeCode := (RangeCode shl 8) or ReadByteFromInput;
   end;
      end;
           
                   function RangeCoderDecodeBit(var Probability :
longword;                                                 Shift :
longword) : longword;                  begin
                                              RangeMiddle :=
RangeLow + (((RangeHigh - RangeLow) shr 12) *             
                 Probability);                                    if
RangeCode <= RangeMiddle then begin                                   
   inc(Probability, ($fff - Probability) shr Shift);
       RangeHigh := RangeMiddle;
             result := 1;
                 end else begin
                         dec(Probability, Probability shr Shift);
                               RangeLow := RangeMiddle + 1;
                                     result := 0;
                                         end;
                                            
RangeCoderDecodeNormalize;
 end;
        example  The probability may be never zero! But that
can't happen here with this  adaptive model in this P64 file format,
since the adaptive model uses a shift factor of 4 bits and initial
probabilities value of 2048, so the  probability has a value range
from 15 up to 4080 here. If you do want to use  the above range coder
routines for other stuff with other probability models,  then you
must to ensure that the probability output value is never zero, for 
example with  "probability |= (probability < 1); " in C.        

P64 Chunk 'DONE' Layout
------------------------

    This is the last empty chunk for to signalize that the correct
file end is reached.  


@EndNode

@Node "D64" "vice.guide/D64"
@Next "X64"
@Prev "G64"
@Toc "File formats"

The D64 disk image format
==========================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  First and foremost we have D64,
which is basically a sector-for-sector copy of a 1540/1541 disk.
There are several versions of these which I will cover shortly. The
standard D64 is a 174848 byte file comprised of 256 byte sectors
arranged in 35 tracks with a varying number of sectors per track for
a total of 683 sectors. Track counting starts at 1, not 0, and goes
up to 35. Sector counting starts at 0, not 1, for the first sector,
therefore a track with 21 sectors will go from 0 to 20.  The
original media (a 5.25" disk) has the tracks laid out in circles,
with track 1 on the very outside of the disk (closest to the sides) to
track 35 being on the inside of the disk (closest to the inner hub
ring). Commodore, in their infinite wisdom, varied the number of
sectors per track and data densities across the disk to optimize
available storage, resulting in the chart below. It shows the
sectors/track for a standard D64. Since the outside diameter of a
circle is the largest (versus closer to the center), the outside
tracks have the largest amount of storage.    .33 .33 .33  Track
Sectors/track  # Sectors  1-17  21  357  18-24  19  133
25-30  18  108  31-35  17  85  36-40(*)  17  85
multitable    .25 .25 .25 .25  Track  #Sect  #SectorsIn
D64 Offset  1  21  0  $00000  2  21  21  $01500  3
21  42  $02A00  4  21  63  $03F00  5  21  84
$05400  6  21  105  $06900  7  21  126  $07E00  8
21  147  $09300  9  21  168  $0A800  10  21  189
$0BD00  11  21  210  $0D200  12  21  231  $0E700  13
21  252  $0FC00  14  21  273  $11100  15  21  294
$12600  16  21  315  $13B00  17  21  336  $15000  18
19  357  $16500  19  19  376  $17800  20  19  395
$18B00  21  19  414  $19E00  22  19  433  $1B100  23
19  452  $1C400  24  19  471  $1D700  25  18  490
$1EA00  26  18  508  $1FC00  27  18  526  $20E00  28
18  544  $22000  29  18  562  $23200  30  18  580
$24400  31  17  598  $25600  32  17  615  $26700  33
17  632  $27800  34  17  649  $28900  35  17  666
$29A00  36(*)  17  683  $2AB00  37(*)  17  700  $2BC00
38(*)  17  717  $2CD00  39(*)  17  734  $2DE00  40(*)
17  751  $2EF00  multitable  (*) Tracks 36-40 apply to
40-track images only.  The directory track should be contained
totally on track 18. Sectors 1-18 contain the entries and sector 0
contains the BAM (Block Availability Map) and disk name/ID. Since the
directory is only 18 sectors large (19 less one for the BAM), and
each sector can contain only 8 entries (32 bytes per entry), the
maximum number of directory entries is 18 * 8 = 144. The first
directory sector is always 18/1, even though the t/s pointer at 18/0
(first two bytes) might point somewhere else. It then follows the
same chain structure as a normal file, using a sector interleave of
3. This makes the chain links go 18/1, 18/4, 18/7 etc.  Note that
you can extend the directory off of track 18, but only when reading
the disk or image. Attempting to write to a directory sector not on
track 18 will cause directory corruption. Each directory sector has
the following layout (18/1 partial dump): 

   00: 12 04 81 11 00 4E 41 4D 45 53 20 26 20 50 4F 53 <- notice the
T/S link  10: 49 54 A0 A0 A0 00 00 00 00 00 00 00 00 00 15 00 <- to
18/4 ($12/$04)  20: 00 00 84 11 02 41 44 44 49 54 49 4F 4E 41 4C 20
<- and how its not here  30: 49 4E 46 4F A0 11 0C FE 00 00 00 00 00
00 61 01 <- ($00/$00)  example  The first two bytes of the sector
($12/$04) indicate the location of the next track/sector of the
directory (18/4). If the track is set to $00, then it is the last
sector of the directory. It is possible, however unlikely, that the
directory may *not* be competely on track 18 (some disks do exist
like this). Just follow the chain anyhow.  When the directory is
done, the track value will be $00. The sector link should contain a
value of $FF, meaning the whole sector is allocated, but the actual
value doesn't matter. The drive will return all the available entries
anyways.  This is a breakdown of a standard directory sector: 
.2 .8  Bytes  Description  $00-$1F  First directory entry
$20-$3F  Second dir entry  $40-$5F  Third dir entry  $60-$7F
Fourth dir entry  $80-$9F  Fifth dir entry  $A0-$BF  Sixth dir
entry  $C0-$DF  Seventh dir entry  $E0-$FF  Eighth dir entry
multitable  This is a breakdown of a standard directory entry: 
 .2 .8  Bytes  Description  $00-$01  Track/Sector location of
next directory sector ($00 $00 if not the first entry in the sector)
$02  File type  $03-$04  Track/sector location of first sector of
file  $05-$14  16 character filename (in PETASCII, padded with
$A0)  $15-$16  Track/Sector location of first side-sector block
(REL file only)  $17  REL file record length (REL file only, max.
value 254)  $18-$1D  Unused (except with GEOS disks)  $1E-$1F
File size in sectors, low/high byte order ($1E+$1F*256). The approx.
filesize in bytes is <= #sectors * 254  multitable  The file type
field is used as follows:    .2 .8  Bits  Description  0-3
The actual file type  4  Unused  5  Used only during SAVE-
replacement  6  Locked flag (Set produces ">" locked files)  7
Closed flag (Not set produces "*", or "splat" files)  multitable 
The actual file type can be one of the following:    .2 .2 .6
Binary  Decimal  File type  0000  0  DEL  0001  1  SEQ
0010  2  PRG  0011  3  USR  0100  4  REL
multitable  Values 5-15 are illegal, but if used will produce very
strange results. The 1541 is inconsistent in how it treats these
bits. Some routines use all 4 bits, others ignore bit 3, resulting
in values from 0-7.  Files, on a standard 1541, are stored using
an interleave of 10. Assuming a starting track/sector of 17/0, the
chain would run 17/0, 17/10, 17/20, 17/8, 17/18, etc. 

Non-Standard & Long Directories
--------------------------------

    Most Commdore floppy disk drives use a single dedicated
directory track where all filenames are stored. This limits the
number of files stored on a disk based on the number of sectors on
the directory track. There are some disk images that contain more
files than would normally be allowed. This requires extending the
directory off the default directory track by changing the last
directory sector pointer to a new track, allocating the new sectors
in the BAM, and manually placing (or moving existing) file entries
there. The directory of an extended disk can be read and the files
that reside there can be loaded without problems on a real drive.
However, this is still a very dangerous practice as writing to the
extended portion of the directory will cause directory corruption in
the non-extended part. Many of the floppy drives core ROM routines
ignore the track value that the directory is on and assume the
default directory track for operations.  To explain: assume that
the directory has been extended from track 18 to track 19/6 and that
the directory is full except for a few slots on 19/6. When saving a
new file, the drive DOS will find an empty file slot at 19/6 offset
$40 and correctly write the filename and a few other things into this
slot. When the file is done being saved the final file information
will be written to 18/6 offset $40 instead of 19/6 causing some
directory corruption to the entry at 18/6. Also, the BAM entries for
the sectors occupied by the new file will not be saved and the new
file will be left as a SPLAT (*) file.  Attempts to validate the
disk will result in those files residing off the directory track to
not be allocated in the BAM, and could also send the drive into an
endless loop. The default directory track is assumed for all sector
reads when validating so if the directory goes to 19/6, then the
validate code will read 18/6 instead. If 18/6 is part of the normal
directory chain then the validate routine will loop endlessly. 

BAM layout
-----------

    The layout of the BAM area (sector 18/0) is a bit more
complicated... 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----------------------------------------------  00: 12 01 41 00 12 FF
F9 17 15 FF FF 1F 15 FF FF 1F  10: 15 FF FF 1F 12 FF F9 17 00 00 00
00 00 00 00 00  20: 00 00 00 00 0E FF 74 03 15 FF FF 1F 15 FF FF 1F
30: 0E 3F FC 11 07 E1 80 01 15 FF FF 1F 15 FF FF 1F  40: 15 FF FF 1F
15 FF FF 1F 0D C0 FF 07 13 FF FF 07  50: 13 FF FF 07 11 FF CF 07 13
FF FF 07 12 7F FF 07  60: 13 FF FF 07 0A 75 55 01 00 00 00 00 00 00
00 00  70: 00 00 00 00 00 00 00 00 01 08 00 00 03 02 48 00  80: 11
FF FF 01 11 FF FF 01 11 FF FF 01 11 FF FF 01  90: 53 48 41 52 45 57
41 52 45 20 31 20 20 A0 A0 A0  A0: A0 A0 56 54 A0 32 41 A0 A0 A0 A0
00 00 00 00 00  B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
C0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  D0: 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00  E0: 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00  F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00  example    .2 .8  Bytes  Description  $00-$01
Track/Sector location of the first directory sector (should be set to
18/1 but it doesn't matter, and don't trust what is there, always go to
18/1 for first directory entry)  $02  Disk DOS version type (see
note below) $41 ("A")  $03  Unused  $04-$8F  BAM entries for
each track, in groups of four bytes per track, starting on track 1 (see
below for more details)  $90-$9F  Disk Name (padded with $A0)
$A0-$A1  Filled with $A0  $A2-$A3  Disk ID  $A4  Usually $A0
$A5-$A6  DOS type, usually "2A"  $A7-$AA  Filled with $A0
$AB  Unused ($00)  $AC-$BF  For DOLPHIN DOS track 36-40 BAM
entries, otherwise unused ($00)  $C0-$D3  For SPEED DOS track 36-40
BAM entries, otherwise unused ($00)  $D4-$FF Unused ($00)
multitable  Note: The BAM entries for SPEED, DOLPHIN and ProLogic
DOS use the same layout as standard BAM entries. One of the
interesting things from the BAM sector is the byte at offset $02, the
DOS version byte. If it is set to anything other than $41 or $00,
then we have what is called "soft write protection". Any attempt to
write to the disk will return the "DOS Version" error code 73 ,"CBM
DOS V 2.6 1541". The 1541 is simply telling you that it thinks the
disk format version is incorrect. This message will normally come up
when you first turn on the 1541 and read the error channel. If you
write a $00 or a $41 into 1541 memory location $00FF (for device 0),
then you can circumvent this type of write-protection, and change the
DOS version back to what it should be.  The BAM entries require a
bit (no pun intended) more of a breakdown. Take the first entry at
bytes $04-$07 ($12 $FF $F9 $17). The first byte ($12) is the number
of free sectors on that track. Since we are looking at the track 1
entry, this means it has 18 (decimal) free sectors. The next three
bytes represent the bitmap of which sectors are used/free. Since it
is 3 bytes (8 bits/byte) we have 24 bits of storage. Remember that at
most, each track only has 21 sectors, so there are a few unused
bits.    .2 .4 .4  Bytes  Data  Description  $04-$07  $12
$FF $F9 $17  Track 1 BAM  $08-$0B  $15 $FF $FF $FF  Track 2
BAM  $0C-$0F  $15 $FF $FF $1F  Track 3 BAM  ...  ...  ...
$8C-$8F  $11 $FF $FF $01  Track 35 BAM  multitable  These
entries must be viewed in binary to make any sense. We will use the
first entry (track 1) at bytes 04-07: 

   FF=11111111, F9=11111001, 17=00010111  example  In order to
make any sense from the binary notation, flip the bits around. 

   111111 11112222  01234567 89012345 67890123
-------------------------  11111111 10011111 11101000  ^
        ^  sector 0           sector 20  example  Since we are
on the first track, we have 21 sectors, and only use up to the bit 20
position. If a bit is on (1), the sector is free. Therefore, track 1
has sectors 9, 10 and 19 used, all the rest are free. Any leftover
bits that refer to sectors that don't exist, like bits 21-23 in the
above example, are set to allocated.  Each filetype has its own
unique properties, but most follow one simple structure. The first
file sector is pointed to by the directory and follows a t/s chain,
until the track value reaches $00. When this happens, the value in
the sector link location indicates how much of the sector is used.
For example, the following chain indicates a file 6 sectors long,
and ends when we encounter the $00/$34 chain. At this point the last
sector occupies from bytes $02-$34.    .16 .16 .16 .16 .16 .16
1  2  3  4  5  6  ---  ---  ---  ---  ---  ---
17/0  17/10  17/20  17/1  17/11  0/52  (11/00)  (11/0A)
(11/14)  (11/01)  (11/0B)  (0/34)  multitable 

Variations on the D64 layout
-----------------------------

    These are some variations of the D64 layout:  1. Standard 35
track layout but with 683 error bytes added on to the end of the
file. Each byte of the error info corresponds to a single sector
stored in the D64, indicating if the sector on the original disk
contained an error. The first byte is for track 1/0, and the last
byte is for track 35/16.  2. A 40 track layout, following the
same layout as a 35 track disk, but with 5 extra tracks. These
contain 17 sectors each, like tracks 31-35. Some of the PC utilities
do allow you to create and work with these files. This can also have
error bytes attached like variant #1.  3. The Commodore 128
allowed for "auto-boot" disks. With this, t/s 1/0 holds a specific
byte sequence which the computer recognizes as boot code.  Below
is a small chart detailing the standard file sizes of D64 images, 35
or 40 tracks, with or without error bytes.    .5 .5  Disk type
Size  35 track, no errors  174848  35 track, 683 error bytes
175531  40 track, no errors  196608  40 track, 768 error bytes
197376  multitable  The following table (provided by Wolfgang
Moser) outlines the differences between the standard 1541 DOS and
the various "speeder" DOS's that exist. The 'header 7/8' category
is the 'fill bytes' as the end of the sector header of a real 1541
disk.    .5 .1 .1 .1 .2  Disk format  tracks  header 7/8
Dos type  Diskdos vs. type  Original CBM DOS v2.6  35  $0f $0f
"2A"  $41/'A'  *SpeedDOS+  40  $0f $0f  "2A"  $41/'A'
Professional DOS Initial  35  $0f $0f  "2A"  $41/'A'
Professional DOS Version 1/Prototype  40  $0f $0f  "2A"
$41/'A'  ProfDOS Release  40  $0f $0f  "4A"  $41/'A'
Dolphin-DOS 2.0/3.0  35  $0f $0f  "2A"  $41/'A'  Dolphin-DOS
2.0/3.0  40  $0d $0f  "2A"  $41/'A'  PrologicDOS 1541  35
$0f $0f  "2A"  $41/'A'  PrologicDOS 1541  40  $0f $0f
"2P"  $50/'P'  ProSpeed 1571 2.0  35  $0f $0f  "2A"
$41/'A'  ProSpeed 1571 2.0  40  $0f $0f  "2P"  $50/'P'
multitable  *Note: There are also clones of SpeedDOS that exist,
such as RoloDOS and DigiDOS. Both are just a change of the DOS
startup string.  The location of the extra BAM information in
sector 18/0, for 40 track images, will be different depending on what
standard the disks have been formatted with. SPEED DOS stores them
from $C0 to $D3, DOLPHIN DOS stores them from $AC to $BF and
PrologicDOS stored them right after the existing BAM entries from
$90-A3. PrologicDOS also moves the disk label and ID forward from the
standard location of $90 to $A4. 64COPY and Star Commander let you
select from several different types of extended disk formats you want
to create/work with.  All three of the speeder DOS's mentioned
above don't alter the standard sector interleave of 10 for files and
3 for directories. The reason is that they use a memory cache
installed in the drive which reads the entire track in one pass. This
alleviates the need for custom interleave values. They do seem to
alter the algorithm that finds the next available free sector so that
the interleave value can deviate from 10 under certain circumstances,
but I don't know why they would bother.  Below is a HEX dump of a
Speed DOS BAM sector. Note the location of the extra BAM info from
$C0-D3. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----------------------------------------------  0070: 12 FF FF 03 12
FF FF 03 12 FF FF 03 11 FF FF 01  0080: 11 FF FF 01 11 FF FF 01 11 FF
FF 01 11 FF FF 01  0090: A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0
A0  00A0: A0 A0 30 30 A0 32 41 A0 A0 A0 A0 00 00 00 00 00  00B0: 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  00C0: 11 FF FF 01 11 FF
FF 01 11 FF FF 01 11 FF FF 01  00D0: 11 FF FF 01 00 00 00 00 00 00 00
00 00 00 00 00  example  Below is a HEX dump of a Dolphin DOS BAM
sector. Note the location of the extra BAM info from $AC-BF. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----------------------------------------------  0070: 12 FF FF 03 12
FF FF 03 12 FF FF 03 11 FF FF 01  0080: 11 FF FF 01 11 FF FF 01 11 FF
FF 01 11 FF FF 01  0090: A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0
A0  00A0: A0 A0 30 30 A0 32 41 A0 A0 A0 A0 00 11 FF FF 01  00B0: 11
FF FF 01 11 FF FF 01 11 FF FF 01 11 FF FF 01  00C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00  00D0: 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00  example  Below is a HEX dump of a PrologicDOS BAM
sector. Note that the disk name and ID are now located at $A4
instead of starting at $90. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----------------------------------------------  0070: 12 FF FF 03 12
FF FF 03 12 FF FF 03 11 FF FF 01  0080: 11 FF FF 01 11 FF FF 01 11 FF
FF 01 11 FF FF 01  0090: 11 FF FF 01 11 FF FF 01 11 FF FF 01 11 FF FF
01  00A0: 11 FF FF 01 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0  00B0: A0
A0 A0 A0 A0 A0 30 30 A0 32 50 A0 A0 A0 A0 00  00C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00  00D0: 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00  example 

Error codes
------------

    Here is the meaning of the error bytes added onto the end of
any extended D64. The CODE is the same as that generated by the 1541
drive controller... it reports these numbers, not the error code we
usually see when an error occurs.  Some of what comes below is
taken from Immers/Neufeld book "Inside Commodore DOS". Note the
descriptions are not completely accurate as to what the drive DOS is
actually doing to seek/read/decode/write sectors, but serve as
simple examples only. The "type" field is where the error usually
occurs, whether it's searching for any SYNC mark, any header ID, any
valid header, or reading a sector.  These first errors are "seek"
errors, where the disk controller is simply reading headers and
looking at descriptor bytes, checksums, format ID's and reporting
what errors it sees. These errors do *not* necessarily apply to the
exact sector being looked for. This fact makes duplication of these
errors very unreliable.  Code    : $03 Error   : 21 Type    :
Seek Message : No SYNC sequence found.  Each sector data block
and header block are preceeded by SYNC marks. If *no* sync sequence
is found within 20 milliseconds (only ~1/10 of a disk rotation!) then
this error is generated. This error used to mean the entire track
is bad, but it does not have to be the case. Only a small area of the
track needs to be without a SYNC mark and this error will be
generated.  Converting this error to a D64 is very problematic
because it depends on where the physical head is on the disk when a
read attempt is made. If it is on valid header/sectors then it won't
occur. If it happens over an area without SYNC marks, it will
happen.  Code    : $02 Error   : 20 Type    : Seek Message :
Header descriptor byte not found (HEX $08, GCR $52)  Each sector is
preceeded by an 8-byte GCR header block, which starts with the value
$52 (GCR). If this value is not found after 90 attempts, this error
is generated.  Basically, what a track has is SYNC marks, and
possibly valid data blocks, but no valid header descriptors. 
Code    : $09 Error   : 27 Type    : Seek Message : Checksum
error in header block  The header block contains a checksum value,
calculated by XOR'ing the TRACK, SECTOR, ID1 and ID2 values. If this
checksum is wrong, this error is generated.  Code    : $0B Error
: 29 Type    : Seek Message : Disk sector ID mismatch  The
ID's from the header block of the currently read sector are compared
against the ones from the low-level header of 18/0. If there is a
mismatch, this error is generated.  Code    : $02 Error   : 20
Type    : Seek Message : Header block not found  This error can
be reported again when searching for the correct header block. An
image of the header is built and searched for, but not found after 90
read attempts. Note the difference from the first occurance. The
first one only searches for a valid ID, not the whole header. 
Note that error 20 occurs twice during this phase. The first time is
when a header ID is being searched for, the second is when the proper
header pattern for the sector being searched for is not found. 
From this point on, all the errors apply to the specific sector you
are looking for. If a read passed all the previous checks, then we
are at the sector being searched for.  Note that the entire sector
is read before these errors are detected. Therefore the data,
checksum and off bytes are available.  Code    : $04 Error   :
22 Type    : Read Message : Data descriptor byte not found (HEX
$07, GCR $55)  Each sector data block is preceeded by the value
$07, the "data block" descriptor. If this value is not there, this
error is generated. Each encoded sector has actually 260 bytes. First
is the descriptor byte, then follows the 256 bytes of data, a
checksum, and two "off" bytes.  Code    : $05 Error   : 23 Type
  : Read Message : Checksum error in data block  The checksum of
the data read of the disk is calculated, and compared against the one
stored at the end of the sector. If there's a discrepancy, this error
is generated.  Code    : $0F Error   : 74 Type    : Read
Message : Drive Not Ready (no disk in drive or no device 1)  These
errors only apply when writing to a disk. I don't see the usefulness
of having these as they cannot be present when only *reading* a
disk.  Code    : $06 Error   : 24 Type    : Write Message :
Write verify (on format)  Code    : $07 Error   : 25 Type    :
Write Message : Write verify error  Once the GCR-encoded sector
is written out, the drive waits for the sector to come around again
and verifies the whole 325-byte GCR block. Any errors encountered
will generate this error.  Code    : $08 Error   : 26 Type    :
Write Message : Write protect on  Self explanatory. Remove the
write-protect tab, and try again.  Code    : $0A Error   : 28
Type    : Write Message : Write error  In actual fact, this error
never occurs, but it is included for completeness.  This is not
an error at all, but it gets reported when the read of a sector is
ok.  Code    : $01 Error   : 00 Type    : N/A Message : No
error.  Self explanatory. No errors were detected in the reading
and decoding of the sector.  The advantage with using the 35 track
D64 format, regardless of error bytes, is that it can be converted
directly back to a 1541 disk by either using the proper cable and
software on the PC, or send it down to the C64 and writing it back to
a 1541. It is the best documented format since it is also native to
the C64, with many books explaining the disk layout and the internals
of the 1541. 


@EndNode

@Node "X64" "vice.guide/X64"
@Next "D71"
@Prev "D64"
@Toc "File formats"

The X64 disk image format
==========================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  This file type, created by
Teemu Rantanen, is used on the X64 emulator (a UNIX-based emulator)
which has been superceeded by VICE. Both VICE and X64 support the X64
file standard, with VICE also supporting the regular D64 and T64
files.  X64 is not a specific type of file, but rather encompasses
*all* known C64 disk types (hard disk, floppies, etc). An X64 is
created by prepending a 64-byte header to an existing image (1541,
1571, etc) and setting specific bytes which describe what type of
image follows. This header has undergone some revision, and this
description is based on the 1.02 version, which was the last known at
the time of writing.  The most common X64 file you will see is the
D64 variety, typically 174912 bytes long (174848 for the D64 and 64
bytes for the header, assuming no error bytes are appended). The
header layout (as used in 64COPY) is as follows: 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 0000: 43 15 41 64 01
02 01 23 00 00 00 00 00 00 00 00 0010: 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0040: XX
XX XX <- standard C64 image starts here....  example    .2 .8
Bytes  Description  $00-$03  This is the "Magic header" ($43 $15
$41 $64)  $04  Header version major ($01)  $05  Header version
minor ($01, now its up to $02)  $06  Device type represented
$07  Maximum tracks in image (only in version 1.02 or greater)
1540/41/70: 35 1571: 35 1581: 80 (Logical single-sided disk)  $08
Number of disk sides in image. This value must be $00 for all 1541 and
1581 formats. $00=No second side $01=Second side  $09  Error data
flag.  $0A-$1F  Unused, set to $00  $20-$3E  Disk image
description (in ASCII or ISO Latin/1)  $3F  Always set to $00
$40-  Standard C64 file begins here.  multitable  The device
types are:    .2 .8  Value  Drive type  $00  1540 See note
below...  $01  1541 (Default)  $02  1542  $03  1551  $04
1570  $05  1571  $06  1572  $08  1581  $10  2031 or
4031  $11  2040 or 3040  $12  2041  $18  4040  $20
8050  $21  8060  $22  8061  $30  SFD-1001  $31  8250
$32  8280  multitable  The first four bytes used for the device
type at position $06 ($00 to $03) are functionally the same, and are
compatible with older version of X64 files. Some old X64 files might
have $00 for the device type (instead of $01), but it makes no real
difference.  As most instances of X64 files will be strictly 1541
images, bytes $08-$3F are set to zero, and some versions of the X64
emulator don't use bytes $08-$3F. 


@EndNode

@Node "D71" "vice.guide/D71"
@Next "D81"
@Prev "X64"
@Toc "File formats"

The D71 disk image format
==========================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  Similar to the D64 (1541), the
1571 drive can operate in either single-sided (1541 compatible) mode
or double-sided (1571) mode. In this section I will be dealing with
the double-sided mode only. For the breakdown of the single-sided
mode, see the D64 section.  The D71 has 70 tracks, double that of
the 1541, with a DOS file size of 349696 bytes. If the error byte
block (1366 bytes) is attached, this makes the file size 351062
bytes. The track range and offsets into the D71 files are as
follows:    .5 .25 .25  Track  Sec/trk  # Sectors  1-17
(side 0)  21  357  18-24 (side 0)  19  133  25-30 (side 0)
18  108  31-35 (side 0)  17  85  36-52 (side 1)  21
357  53-59 (side 1)  19  133  60-65 (side 1)  18  108
66-70 (side 1)  17  85  multitable    .25 .25 .25 .25
Track  #Sect  #SectorsIn  D71 Offset  1  21  0  $00000
2  21  21  $01500  3  21  42  $02A00  4  21  63
$03F00  5  21  84  $05400  6  21  105  $06900  7
21  126  $07E00  8  21  147  $09300  9  21  168
$0A800  10  21  189  $0BD00  11  21  210  $0D200  12
21  231  $0E700  13  21  252  $0FC00  14  21  273
$11100  15  21  294  $12600  16  21  315  $13B00  17
21  336  $15000  18  19  357  $16500  19  19  376
$17800  20  19  395  $18B00  21  19  414  $19E00  22
19  433  $1B100  23  19  452  $1C400  24  19  471
$1D700  25  18  490  $1EA00  26  18  508  $1FC00  27
18  526  $20E00  28  18  544  $22000  29  18  562
$23200  30  18  580  $24400  31  17  598  $25600  32
17  615  $26700  33  17  632  $27800  34  17  649
$28900  35  17  666  $29A00  36  21  683  $2AB00  37
21  704  $2C000  38  21  725  $2D500  39  21  746
$2EA00  40  21  767  $2FF00  41  21  788  $31400  42
21  809  $32900  43  21  830  $33E00  44  21  851
$35300  45  21  872  $36800  46  21  893  $37D00  47
21  914  $39200  48  21  935  $3A700  49  21  956
$3BC00  50  21  977  $3D100  51  21  998  $3E600  52
21  1019  $3FB00  53  19  1040  $41000  54  19
1059  $42300  55  19  1078  $43600  56  19  1097
$44900  57  19  1116  $45C00  58  19  1135  $46F00
59  19  1154  $48200  60  18  1173  $49500  61  18
1191  $4A700  62  18  1209  $4B900  63  18  1227
$4CB00  64  18  1245  $4DD00  65  18  1263  $4EF00
66  17  1281  $50100  67  17  1298  $51200  68  17
1315  $52300  69  17  1332  $53400  70  17  1349
$54500  multitable  The directory structure is the same as a
D64/1541. All the same filetypes apply, the directory still only
holds 144 files per disk and should only exist on track 18.  The
first two bytes of the sector ($12/$04 or 18/4) indicate the location
of the next track/sector of the directory. If the track value is set
to $00, then it is the last sector of the directory. It is possible,
however unlikely, that the directory may *not* be competely on track
18 (some disks do exist like this). Just follow the chain anyhow. 
When the directory is done, the track value will be $00. The sector
link should contain a value of $FF, meaning the whole sector is
allocated, but the actual value doesn't matter. The drive will return
all the available entries anyways. This is a breakdown of a standard
directory sector and entry: 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 12 04 82 11 00 4A
45 54 20 53 45 54 20 57 49 4C 10: 4C 59 A0 A0 A0 00 00 00 00 00 00 00
00 00 2B 00 20: 00 00 82 0F 01 4A 53 57 20 31 A0 A0 A0 A0 A0 A0 30:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 BF 00 40: 00 00 82 06 03 53
4F 4E 20 4F 46 20 42 4C 41 47 50: 47 45 52 A0 A0 00 00 00 00 00 00 00
00 00 AE 00 60: 00 00 82 15 0D 50 4F 54 54 59 20 50 49 47 45 4F 70:
4E A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 A2 00 80: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 90: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 D0: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 E0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 F0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  example    .2
.8  Bytes  Description  $00-$1F  First directory entry
$20-$3F  Second dir entry  $40-$5F  Third dir entry  $60-$7F
Fourth dir entry  $80-$9F  Fifth dir entry  $A0-$BF  Sixth dir
entry  $C0-$DF  Seventh dir entry  $E0-$FF  Eighth dir entry
multitable  This is a breakdown of a standard directory entry: 
 .2 .8  Bytes  Description  $00-$01  Track/Sector location of
next directory sector ($00/$FF if its the last sector)  $02  File
type  $03-$04  Track/sector location of first sector of file
$05-$14  16 character filename (in PETASCII, padded with $A0)
$15-$16  Track/Sector location of first side-sector block (REL file
only)  $17  REL file record length (REL file only, max. value 254)
$18-$1D  Unused (except with GEOS disks)  $1E-$1F  File size in
sectors, low/high byte order ($1E+$1F*256). The approx. filesize in
bytes is <= #sectors * 254  multitable  The file type field is
used as follows:    .2 .8  Bits  Description  0-3  The
actual file type  4  Unused  5  Used only during SAVE-
replacement  6  Locked flag (Set produces ">" locked files)  7
Closed flag (Not set produces "*", or "splat" files)  multitable 
The actual file type can be one of the following:    .2 .2 .6
Binary  Decimal  File type  0000  0  DEL  0001  1  SEQ
0010  2  PRG  0011  3  USR  0100  4  REL
multitable  Values 5-15 are illegal, but if used will produce very
strange results. The 1571 is inconsistent in how it treats these
bits. Some routines use all 4 bits, others ignore bit 3, resulting
in values from 0-7.  When the 1571 is in is native ("1571") mode,
files are stored with a sector interleave of 6, rather than 10 which
the 1541 (and the 1571 in "1541" mode) uses. The directory still uses
an interleave of 3. 

Non-Standard & Long Directories
--------------------------------

    Most Commodore floppy disk drives use a single dedicated
directory track where all filenames are stored. This limits the
number of files stored on a disk based on the number of sectors on
the directory track. There are some disk images that contain more
files than would normally be allowed. This requires extending the
directory off the default directory track by changing the last
directory sector pointer to a new track, allocating the new sectors
in the BAM, and manually placing (or moving existing) file entries
there. The directory of an extended disk can be read and the files
that reside there can be loaded without problems on a real drive.
However, this is still a very dangerous practice as writing to the
extended portion of the directory will cause directory corruption in
the non- extended part. Many of the floppy drives core ROM routines
ignore the track value that the directory is on and assume the
default directory track for operations.  To explain: assume that
the directory has been extended from track 18 to track 19/6 and that
the directory is full except for a few slots on 19/6. When saving a
new file, the drive DOS will find an empty file slot at 19/6 offset
$40 and correctly write the filename and a few other things into this
slot. When the file is done being saved the final file information
will be written to 18/6 offset $40 instead of 19/6 causing some
directory corruption to the entry at 18/6. Also, the BAM entries for
the sectors occupied by the new file will not be saved and the new
file will be left as a SPLAT (*) file.  Attempts to validate the
disk will result in those files residing off the directory track to
not be allocated in the BAM, and could also send the drive into an
endless loop. The default directory track is assumed for all sector
reads when validating so if the directory goes to 19/6, then the
validate code will read 18/6 instead. If 18/6 is part of the normal
directory chain then the validate routine will loop endlessly. 

Bam layout The BAM is somewhat different as it now has to
----------------------------------------------------------

   take 35 new tracks into account. In order to do this, most of the
extra BAM information is stored on track 53/0, and the remaining
sectors on track 53 are marked in the BAM as allocated. This does
mean that except for one allocated sector on track 53, the rest of
the track is unused and wasted. (Track 53 is the equivalent to track
18, but on the flip side of the disk). Here is a dump of the first
BAM sector... 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 12 01 41 80 12 FF
F9 17 15 FF FF 1F 15 FF FF 1F 10: 15 FF FF 1F 15 FF FF 1F 15 FF FF 1F
15 FF FF 1F 20: 15 FF FF 1F 15 FF FF 1F 15 FF FF 1F 15 FF FF 1F 30:
15 FF FF 1F 15 FF FF 1F 15 FF FF 1F 15 FF FF 1F 40: 15 FF FF 1F 15 FF
FF 1F 11 FC FF 07 13 FF FF 07 50: 13 FF FF 07 13 FF FF 07 13 FF FF 07
13 FF FF 07 60: 13 FF FF 07 12 FF FF 03 12 FF FF 03 12 FF FF 03 70:
12 FF FF 03 12 FF FF 03 12 FF FF 03 11 FF FF 01 80: 11 FF FF 01 11 FF
FF 01 11 FF FF 01 11 FF FF 01 90: A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0 A0
A0 A0 A0 A0 A0: A0 A0 30 30 A0 32 41 A0 A0 A0 A0 00 00 00 00 00 B0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 D0: 00 00 00 00 00 00 00 00 00 00 00 00
00 15 15 15 E0: 15 15 15 15 15 15 15 15 15 15 15 15 15 15 00 13 F0:
13 13 13 13 13 12 12 12 12 12 12 11 11 11 11 11  example    .5
.5  Bytes  Description  $00-$01  Track/Sector location of the
first directory sector (should be set to 18/1 but it doesn't matter,
and don't trust what is there, always go to 18/1 for first directory
entry)  $02  Disk DOS version type (see note below) $41 ('A') =
1541  $03  Double-sided flag $00 - Single sided disk $80 - Double
sided disk  $04-8F  BAM entries for each track, in groups of four
bytes per track, starting on track 1.  $90-$9F  Disk Name (padded
with $A0)  $A0-$A1  Filled with $A0  $A2-$A3  Disk ID  $A4
Usually $A0  $A5-$A6  DOS type, usually "2A"  $A7-$AA  Filled
with $A0  $AB-$DC  Not used ($00's)  $DD-$FF  Free sector count
for tracks 36-70 (1 byte/track).  multitable  The "free sector"
entries for tracks 36-70 are likely included here in the first BAM
sector due to some memory restrictions in the 1571 drive. There is
only enough memory available for one BAM sector, but in order to
generate the "blocks free" value at the end of a directory listing,
the drive needs to know the extra track "free sector" values. It does
make working with the BAM a little more difficult, though.  These
are the values that would normally be with the 4-byte BAM entry, but
the rest of the entry is contained on 53/0.  Note: If the DOS
version byte is set to anything other than $41 or $00, then we have
what is called "soft write protection". Any attempt to write to the
disk will return the "DOS Version" error code 73. The 1571 is simply
telling you that it thinks the disk format version is incorrect. 
The BAM entries require some explanation. Take the first entry at
bytes $04-$07 ($12 $FF $F9 $17). The first byte ($12) is the number
of free sectors on that track. Since we are looking at the track 1
entry, this means it has 18 (decimal) free sectors.  The next three
bytes represent the bitmap of which sectors are used/free. Since it
is 3 bytes (8 bits/byte) we have 24 bits of storage. Remember that at
most, each track only has 21 sectors, so there are a few unused bits.
These entries must be viewed in binary to make any sense. We will use
the first entry (track 1) at bytes 04-07: 

   FF=11111111, F9=11111001, 17=00010111  example  In order to
make any sense from the binary notation, flip the bits around. 

   111111 11112222  01234567 89012345 67890123
-------------------------  11111111 10011111 11101000  ^
        ^  sector 0           sector 20  example  Since we are
on the first track, we have 21 sectors, and only use up to the bit 20
position. If a bit is on (1), the sector is free. Therefore, track 1
has sectors 9,10 and 19 used, all the rest are free.  In order to
complete the BAM, we must check 53/0. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: FF FF 1F FF FF 1F
FF FF 1F FF FF 1F FF FF 1F FF 10: FF 1F FF FF 1F FF FF 1F FF FF 1F FF
FF 1F FF FF 20: 1F FF FF 1F FF FF 1F FF FF 1F FF FF 1F FF FF 1F 30:
FF FF 1F 00 00 00 FF FF 07 FF FF 07 FF FF 07 FF 40: FF 07 FF FF 07 FF
FF 07 FF FF 03 FF FF 03 FF FF 50: 03 FF FF 03 FF FF 03 FF FF 03 FF FF
01 FF FF 01 60: FF FF 01 FF FF 01 FF FF 01 00 00 00 00 00 00 00 70:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 90: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 D0: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 E0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 F0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  example  Each
track from 36-70 has 3 byte entries, starting at address $00. 

   Byte: $00-$02: $FF $FF $1F - BAM map for track 36       $03-$05:
$FF $FF $1F - BAM map for track 37       ...       $33-$35: $00 $00
$00 - BAM map for track 53       ...       $66-$68: $FF $FF $01 -
BAM map for track 70       $69-$FF:             - Not used
example  You can break down the entries for tracks 36-70 the same
way as track 1, just combine the free sector bytes from 18/0 and the
BAM usage from 53 to get the full 4-byte entry.  Just like a D64,
you can attach error bytes to the file, for sector error information.
This block is 1366 bytes long, 1 byte for each of the 1366 sectors in
the image. With the error bytes, the file size is 351062 bytes. 


@EndNode

@Node "D81" "vice.guide/D81"
@Next "D80"
@Prev "D71"
@Toc "File formats"

The D81 disk image format
==========================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  Like D64 and D71, this is a
byte for byte copy of a physical 1581 disk. It consists of 80 tracks,
40 sectors each (0 to 39) for a size of 819200 bytes, or 3200
sectors. If the error byte block is attached, this makes the file
size 822400 bytes.  There are three sectors on the directory track
used for disk internals (header and BAM), leaving 37 sectors for
filename entries, thus allowing for 296 files (37 * 8) to be stored
at the root level of the disk.  The actual physical layout on the
disk is quite different from what the user sees, but this is
unimportant to the scope of this section. One important difference
from the D64 and D71 is all the sector interleaves are now 1 for both
files and directory storage (rather than 3 for directory and 10 for
file on a D64/D71). This is due to the built-in buffering in the
1581. When reading a sector, the whole track will be buffered in
memory, and any sectors being modified will be done in memory. Once
it has to be written, the whole track will be written out in one
step.  The track range and offsets into the D81 files are as
follows:    .25 .25 .25 .25  Track  #Sect  #SectorsIn  D81
Offset  1  40  0  $00000  2  40  40  $02800  3  40
80  $05000  4  40  120  $07800  5  40  160  $0A000
6  40  200  $0C800  7  40  240  $0F000  8  40
280  $11800  9  40  320  $14000  10  40  360  $16800
11  40  400  $19000  12  40  440  $1B800  13  40
480  $1E000  14  40  520  $20800  15  40  560
$23000  16  40  600  $25800  17  40  640  $28000  18
40  680  $2A800  19  40  720  $2D000  20  40  760
$2F800  21  40  800  $32000  22  40  840  $34800  23
40  880  $37000  24  40  920  $39800  25  40  960
$3C000  26  40  1000  $3E800  27  40  1040  $41000
28  40  1080  $43800  29  40  1120  $46000  30  40
1160  $48800  31  40  1200  $4B000  32  40  1240
$4D800  33  40  1280  $50000  34  40  1320  $52800
35  40  1360  $55000  36  40  1400  $57800  37  40
1440  $5A000  38  40  1480  $5C800  39  40  1520
$5F000  40  40  1560  $61800  41  40  1600  $64000
42  40  1640  $66800  43  40  1680  $69000  44  40
1720  $6B800  45  40  1760  $6E000  46  40  1800
$70800  47  40  1840  $73000  48  40  1880  $75800
49  40  1920  $78000  50  40  1960  $7A800  51  40
2000  $7D000  52  40  2040  $7F800  53  40  2080
$82000  54  40  2120  $84800  55  40  2160  $87000
56  40  2200  $89800  57  40  2240  $8C000  58  40
2280  $8E800  59  40  2320  $91000  60  40  2360
$93800  61  40  2400  $96000  62  40  2440  $98800
63  40  2480  $9B000  64  40  2520  $9D800  65  40
2560  $A0000  66  40  2600  $A2800  67  40  2640
$A5000  68  40  2680  $A7800  69  40  2720  $AA000
70  40  2760  $AC800  71  40  2800  $AF000  72  40
2840  $B1800  73  40  2880  $B4000  74  40  2920
$B6800  75  40  2960  $B9000  76  40  3000  $BB800
77  40  3040  $BE000  78  40  3080  $C0800  79  40
3120  $C3000  80  40  3160  $C5800  multitable  The
header sector is stored at 40/0, and contains the disk name, ID and
DOS version bytes, but the BAM is no longer contained here (like the
D64). 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 28 03 44 00 31 35
38 31 20 55 54 49 4C 49 54 59 10: 20 56 30 31 A0 A0 47 42 A0 33 44 A0
A0 00 00 00 20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 30:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 40: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 50: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 70:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 90: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 D0: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 E0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 F0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  example    .2
.8  Bytes  Description  $00-$01  Track/Sector location of the
first directory sector (should be set to 40/3 but it doesn't matter,
and don't trust what is there, always go to 40/3 for first directory
entry)  $02  Disk DOS version type (see note below) $44 ('D')=1581
$03  $00  $04-$13  16 character Disk Name (padded with $A0)
$14-$15  $A0  $16-$17  Disk ID  $18  $A0  $19  DOS
Version ("3")  $1A  Disk version ("D")  $1B-$1C  $A0
$1D-$FF  Unused (usually $00)  multitable  The following might
be set if the disk is a GEOS format (this info is based on the D64
layout, and might not prove to be true)    .2 .8  Bytes
Description  $AB-$AC  Border sector (GEOS only, else set to $00)
$AD-$BC  GEOS ID string ("geos FORMAT V1.x" GEOS only, else $00)
$BD-$FF  Unused (usually $00)  multitable  Note: If the DOS
version byte is changed to anything other than a $44 (or $00), then
we have what is called "soft write protection". Any attempt to write
to the disk will return the "DOS Version" error code 73. The drive is
simply telling you that it thinks the disk format version is
incompatible.  The directory track should be contained totally on
track 40. Sectors 3-39 contain the entries and sector 1 and 2 contain
the BAM (Block Availability Map). Sector 0 holds the disk name and
ID. The first directory sector is always 40/3, even though the t/s
pointer at 40/0 (first two bytes) might point somewhere else. It goes
linearly up the sector count, 3-4-5-6-etc. Each sector holds up to
eight entries.  The first two bytes of the sector ($28/$04)
indicate the location of the next track/sector of the directory
(40/4). If the track is set to $00, then it is the last sector of the
directory. It is possible, however unlikely, that the directory may
*not* be competely on track 40. Just follow the chain anyhow. 
When the directory is done (track=$00), the sector should contain an
$FF, meaning the whole sector is allocated. Theactual value doesn't
matter as all the entries will be returned anyways. Each directory
sector has the following layout: 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 28 04 81 2B 00 53
43 52 45 45 4E 20 20 33 A0 A0 10: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 02 00 20: 00 00 81 2B 01 53 43 52 45 45 4E 20 20 34 A0 A0 30:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 03 00 40: 00 00 81 2B 02 53
43 52 45 45 4E 20 20 35 A0 A0 50: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 07 00 60: 00 00 81 2B 08 53 43 52 45 45 4E 20 20 36 A0 A0 70:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 08 00 80: 00 00 81 2B 14 53
43 52 45 45 4E 20 20 37 A0 A0 90: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 07 00 A0: 00 00 81 24 00 53 43 52 45 45 4E 20 20 38 A0 A0 B0:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 0B 00 C0: 00 00 82 24 04 46
49 4C 45 34 32 39 33 36 39 30 D0: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 07 00 E0: 00 00 82 24 06 46 49 4C 45 32 35 37 38 38 31 35 F0:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 05 00  example     .2
.8  Bytes  Description  $00-$1F  First directory entry
$20-$3F  Second dir entry  $40-$5F  Third dir entry  $60-$7F
Fourth dir entry  $80-$9F  Fifth dir entry  $A0-$BF  Sixth dir
entry  $C0-$DF  Seventh dir entry  $E0-$FF  Eighth dir entry
multitable  This is a breakdown of a standard directory entry: 
 .2 .8  Bytes  Description  $00-$01  Track/Sector location of
next directory sector  $02  File type  $03-$04  Track/sector
location of first sector of file or partition  $05-$14  16
character filename (in PETASCII, padded with $A0)  $15-$16
Track/Sector location of first SUPER SIDE SECTOR block (REL file only)
$17  REL file record length (REL file only)  $18-$1B  Unused
(except with GEOS disks)  $1C-$1D  (Used during an SAVE or OPEN,
holds the new t/s link)  $1E-$1F  File or partition size in
sectors, low/high byte order ($1E+$1F*256). The approx. file size in
bytes is <= #sectors * 254  multitable  The file type field is
used as follows:    .2 .8  Bits  Description  0-3  The
actual file type  4  Unused  5  Used only during SAVE-
replacement  6  Locked flag (Set produces ">" locked files)  7
Closed flag (Not set produces "*", or "splat" files)  multitable 
The actual file type can be one of the following:    .2 .2 .6
Binary  Decimal  File type  0000  0  DEL  0001  1  SEQ
0010  2  PRG  0011  3  USR  0100  4  REL  0101  5
CBM (partition or sub-directory)  multitable  Values 6-15 are
illegal, but if used will produce very strange results. 

Non-Standard & Long Directories
--------------------------------

    Most Commdore floppy disk drives use a single dedicated
directory track where all filenames are stored. This limits the
number of files stored on a disk based on the number of sectors on
the directory track. There are some disk images that contain more
files than would normally be allowed. This requires extending the
directory off the default directory track by changing the last
directory sector pointer to a new track, allocating the new sectors
in the BAM, and manually placing (or moving existing) file entries
there. The directory of an extended disk can be read and the files
that reside there can be loaded without problems on a real drive.
However, this is still a very dangerous practice as writing to the
extended portion of the directory will cause directory corruption in
the non-extended part. Many of the floppy drives core ROM routines
ignore the track value that the directory is on and assume the
default directory track for operations. 

BAM layout
-----------

    The BAM is located on 40/1 (for side 0, tracks 1-40) and 40/2
(for side 1, tracks 41-80). Each entry takes up six bytes, one for
the "free sector" count and five for the allocation bitmap. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 28 02 44 BB 47 42
C0 00 00 00 00 00 00 00 00 00 10: 28 FF FF FF FF FF 28 FF FF FF FF FF
28 FF FF FF 20: FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF 30:
FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 40: 28 FF FF FF FF FF
28 FF FF FF FF FF 28 FF FF FF 50: FF FF 28 FF FF FF FF FF 28 FF FF FF
FF FF 28 FF 60: FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 70:
28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF 80: FF FF 28 FF FF FF
FF FF 28 FF FF FF FF FF 28 FF 90: FF FF FF FF 28 FF FF FF FF FF 28 FF
FF FF FF FF A0: 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF B0:
FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF C0: FF FF FF FF 28 FF
FF FF FF FF 28 FF FF FF FF FF D0: 28 FF FF FF FF FF 28 FF FF FF FF FF
28 FF FF FF E0: FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF F0:
FF FF FF FF 28 FF FF FF FF FF 24 F0 FF 2D FF FE  example 

   Bytes: $00-$01: Track/sector of next bam sector (40/2)     $02:
Version # ('D')     $03: One's complement of version# ($BB)
$04-$05: Disk ID bytes (same as 40/0 Disk ID)     $06: I/O byte
    bit 7 set - Verify on          bit 7 clear - Verify off
 bit 6 set - Check header CRC          bit 6 clear - Don't check
header CRC     $07: Auto-boot-loader flag $08-$0F: Reserved for
future (set to $00) $10-$15: BAM entry for track 1 (track 41, side
1) $16-$1B: BAM entry for track 2 (track 42, side 1)          ...
$46-$4B: BAM entry for track 10 (track 50, side 1)          ...
$82-$87: BAM entry for track 20 (track 60, side 1)          ...
$BE-$C3: BAM entry for track 30 (track 70, side 1)          ...
$FA-$FF: BAM entry for track 40 (track 80, side 1)  example  The
BAM entries require some explanation, so lets look at the track 40
entry at bytes $FA-FF ($24 $F0 $FF $2D $FF $FE). The first byte ($24,
or 36 decimal) is the number of free sectors on that track. The next
five bytes represent the bitmap of which sectors are used/free. Since
it is five bytes (8 bits/byte) we have 40 bits of storage. Since this
format has 40 sectors/track, the whole five bytes are used. 

   F0: .. .. .. .. .. .. .. .. .. .. 24 F0 FF 2D FF FE  example 
The last five bytes of any BAM entry must be viewed in binary to make
any sense. We will once again use track 40 as our reference: 

   F0=11110000, FF=11111111, 2D=00101101, FF=11111111, FE=11111110
example  In order to make any sense from the binary notation, flip
the bits around. 

   111111 11112222 22222233 33333333  Sector 01234567 89012345
67890123 45678901 23456789         ------------------------- -------
-------         00001111 11111111 10110100 11111111 01111111
example  Note that if a bit is on (1), the sector is free.
Therefore, track 40 has sectors 0-3, 17, 20, 22, 23 and 32 used, all
the rest are free.  The second BAM (for side 1) contains the
entries for tracks 41-80. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 00 FF 44 BB 47 42
C0 00 00 00 00 00 00 00 00 00 10: 28 FF FF FF FF FF 28 FF FF FF FF FF
28 FF FF FF 20: FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF 30:
FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 40: 28 FF FF FF FF FF
28 FF FF FF FF FF 28 FF FF FF 50: FF FF 28 FF FF FF FF FF 28 FF FF FF
FF FF 28 FF 60: FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 70:
28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF 80: FF FF 28 FF FF FF
FF FF 28 FF FF FF FF FF 28 FF 90: FF FF FF FF 28 FF FF FF FF FF 28 FF
FF FF FF FF A0: 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF B0:
FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF C0: FF FF FF FF 28 FF
FF FF FF FF 28 FF FF FF FF FF D0: 28 FF FF FF FF FF 28 FF FF FF FF FF
28 FF FF FF E0: FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF 28 FF F0:
FF FF FF FF 28 FF FF FF FF FF 28 FF FF FF FF FF  example  It is
laid out exactly as the side 0 BAM except for one difference. The
track/sector reference for the next sector should be set to $00/$FF,
indicating there is no next sector. 

REL files The REL filetype requires some extra explaining.
-----------------------------------------------------------

   It was designed to make access to data *anywhere* on the disk very
fast. Take a look at this directory entry... 

   00: 00 FF 84 27 00 41 44 44 49 54 49 4F 4E 41 4C 20  10: 49 4E 46
4F A0 27 02 FE 00 00 00 00 00 00 D2 0B  example  The third byte
($84) indicates this entry is a REL file and that the three normally
empty entries at offset $15, $16 and $17 are now used as they are
explained above. It's the track/sector chain that this entry points
to, called the SUPER SIDE SECTOR, which is of interest here (in this
case, 39/2). The SUPER SIDE SECTOR is very different from the D64
format. If you check the D64 entry for a REL file and do the
calculations, you will find that the maximum file size of the REL
file is 720 data sectors. With the new SUPER SIDE SECTOR, you can now
have 126 groups of these SIDE SECTORS chains, allowing for file
sizes up to (theoretically) 90720 sectors, or about 22.15 Megabytes.
 Here is a dump of the beginning of the SUPER SIDE SECTOR... 

   00: 27 01 FE 27 01 15 09 03 0F 38 16 4A 1C 00 00 00  10: 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00  20: 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  example 

   Bytes: $00-$01: Track/sector of first side sector in group 0
$02: Always $FE $03-$04: Track/sector of first side sector in group 0
(again)          ... $FD-$FE: Track/sector of first side sector in
group 125     $FF: Unused (likely $00)  example  The side
sector layout is the same as the D64/1571. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 12 0A 00 FE 15 09
12 0A 0F 0B 0C 0C 09 0D 06 0E 10: 15 07 15 08 15 0A 15 0B 15 0C 15 0D
15 0E 15 0F 20: 15 10 15 11 15 12 15 13 15 14 15 15 15 16 15 17 30:
15 18 15 19 15 1A 15 1B 15 1C 15 1D 15 1E 15 1F 40: 15 20 15 21 15 22
15 23 15 24 15 25 15 26 15 27 50: 14 00 14 01 14 02 14 03 14 04 14 05
14 06 14 07 60: 14 08 14 09 14 0A 14 0B 14 0C 14 0D 14 0E 14 0F 70:
14 10 14 11 14 12 14 13 14 14 14 15 14 16 14 17 80: 14 18 14 19 14 1A
14 1B 14 1C 14 1D 14 1E 14 1F 90: 14 20 14 21 14 22 14 23 14 24 14 25
14 26 14 27 A0: 13 00 13 01 13 02 13 03 13 04 13 05 13 06 13 07 B0:
13 08 13 09 13 0A 13 0B 13 0C 13 0D 13 0E 13 0F C0: 13 10 13 11 13 12
13 13 13 14 13 15 13 16 13 17 D0: 13 18 13 19 13 1A 13 1B 13 1C 13 1D
13 1E 13 1F E0: 13 20 13 21 13 22 13 23 13 24 13 25 13 26 13 27 F0:
12 00 12 01 12 02 12 03 12 04 12 05 12 06 12 07  example 

   Bytes:     $00: Track location of next side-sector ($00 if last
sector)     $01: Sector location of next side-sector     $02:
Side-sector block number (first sector is $00, the next is
$01, then $02, etc)     $03: REL file RECORD size (from directory
entry) $04-$0F: Track/sector locations of the six other side-sectors.
Note          the first entry is this very sector we have listed
here.          The next is the next t/s listed at the beginning of
the          sector. All of this information must be correct. If one
of          these chains is $00/$00, then we have no more side
sectors.          Also, all of these (up to six) side sectors must
have the          same values in this range. $10-$FF: T/S chains of
*each* sector of the data portion. When we          get a $00/$00, we
are at the end of the file.  example 

1581 Partitions and Sub-directories
------------------------------------

    At the beginning of this section it was stated that the 1581 can
hold 296 entries "at the root level". The 1581 also has the ability
to partition areas of the disk. Under the right conditions these can
become sub-directories, acting as a small diskette, complete with its
own directory and BAM. When you are inside of a sub-directory, no
other files except those in that directory are visible, or can be
affected.  To the 1581, this file will show up as a "CBM" filetype
in a directory. All this does is tell the disk that a file, starting
at X/Y track/sector and Z sectors large exists. Doing a validate will
not harm these files as they have a directory entry, and are fully
allocated in the BAM.  There are two main uses for partitions. One
is to simply allocate a section of the disk to be used for
direct-access reads/writes, and lock it away from being overwritten
after a VALIDATE. The second is as a sub-directory, basically a
small "disk within a disk".  In order to use a partition as a
sub-directory, it must adhere to the following four rules: 

   1. If must start on sector 0  2. It's size must be in multiples of
40 sectors  3. It must be a minimum of 120 sectors long (3 tracks)
4. If must not start on or cross track 40, which limits the
biggest directory to 1600 sectors (tracks 1-39).  example  This
is a dump of a sub-directory entry: 

   00: 00 FF 85 29 00 50 41 52 54 49 54 49 4F 4E 20 31  10: A0 A0 A0
A0 A0 00 00 00 00 00 00 00 00 00 40 06  example  It is a
partition starting on track 41/0, extends for 1600 sectors, and has
been formatted as a sub-directory. Note that when a partition is
created, the area being allocated is not touched in any way. If you
want it set up as a sub-directory, you must issue the FORMAT command
to the 1581 to create the central directory and BAM. Also note that
from the directory entry you can't tell whether it is a sub-directory
or not, just that it fits the sub-directory parameters.  The BAM
track for the sub-directory exists on the first track of the
partition, and has the same layout as the disk BAM on track 40. The
biggest difference is the "disk name" is what what given when the
partition was formatted rather than what the actual disk name is.
Also, except for the free sectors in the partition area, all other
sectors in the BAM will be allocated.  If the partition size
doesn't match the above rules for a sub-directory, it will simply
exist as a "protected" area of the disk, and can't be used as a
sub-directory. Either way, it still shows up as a "CBM" type in a
directory listing. Below is a dump of a 10-sector partition starting
on track 5/1, which does not qualify as a sub-directory... 

   00: 00 00 85 05 01 53 4D 41 4C 4C 50 41 52 54 20 32  10: A0 A0 A0
A0 A0 00 00 00 00 00 00 00 00 00 0A 00  example  The master BAM
shows the entry for this partition on track 5... 

   00: 28 02 44 BB 43 44 C0 00 00 00 00 00 00 00 00 00  10: 23 C1 FF
FF FF FF 28 FF FF FF FF FF 28 FF FF FF  20: FF FF 28 FF FF FF FF FF
1E 01 F8 FF FF FF 28 FF
^^^^^^^^^^^^^^^^^  example  The breakdown of the BAM shows the
allocation for this track, with sectors 1-10 allocated, as it should
be. 

   10000000 00011111 11111111 11111111 11111111  ^          ^
^         ^          ^  0          10         20        30
39  example  Partitions and sub-directories share one very
important trait. When created, the sub-directory entry simply has the
starting track/sector and the size of the partition in sectors.
Partitions are created linearly, meaning if one starts on 30/1 and is
of size 15 sectors, then the sector range from 1 through 15 on track
30 will be allocated. If a partition size crosses a track boundary,
the allocation will continue on the next track starting on sector 0,
and going up.  The section allocated will *not* have a track/sector
chain like a file would, but rather is dependant on the directory
entry to keep it from being overwritten. You can store whatever you
want to in the allocated area. 

AUTO-BOOT LOADER
-----------------

    If byte $07 in the BAM is set, then when the drive is reset
(and other circumstances) it will look for a USR file called
"COPYRIGHT CBM 86". This file will then be loaded into the drive RAM
and executed.  The format for this auto-loader file is fairly
basic. It starts with a two-byte load address, a size byte, program
data, and a checksum at the end. 

   Bytes:        $00-$01: Load address, low/high format
$02: Size of program (SZ) (smaller than 256 bytes) $03-($03+SZ-1):
Program data         $03+SZ: Checksum byte  example 


@EndNode

@Node "D80" "vice.guide/D80"
@Next "D82"
@Prev "D81"
@Toc "File formats"

The D80 disk image format
==========================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  This is a sector-for-sector
copy of an 8050 floppy disk. The file size for an 8050 image is
533248 bytes. It is comprised of 256-byte sectors arranged across 77
tracks, with a varying number of sectors per track for a total of
2083 sectors. Track counting starts at 1 (not 0) and sector
counting starts at 0 (not 1), therefore a track with 29 sectors will
go from 0 to 28.  The original media (a 5.25" disk) has the tracks
laid out in circles, with track 1 on the very outside of the disk
(closest to the sides) to track 77 being on the inside of the disk
(closest to the inner hub ring). Commodore, in their infinite wisdom,
varied the number of sectors per track and data densities across the
disk to optimize available storage, resulting in the chart below. It
shows the sectors/track for a D80. Since the outside diameter of a
circle is the largest (versus closer to the center), the outside
tracks have the largest amount of storage.    .33 .33 .33  Track
Range  Sectors/track  # Sectors  1-39  29  1131  40-53
27  378  54-64  25  275  65-77  23  299  multitable 
 .25 .25 .25 .25  Track  #Sect  #SectorsIn  D8x Offset  1
29  0  $00000  2  29  29  $01D00  3  29  58
$03A00  4  29  87  $05700  5  29  116  $07400  6
29  145  $09100  7  29  174  $0AE00  8  29  203
$0CB00  9  29  232  $0E800  10  29  261  $10500  11
29  290  $12200  12  29  319  $13F00  13  29  348
$15C00  14  29  377  $17900  15  29  406  $19600  16
29  435  $1B300  17  29  464  $1D000  18  29  493
$1ED00  19  29  522  $20A00  20  29  551  $22700  21
29  580  $24400  22  29  609  $26100  23  29  638
$27E00  24  29  667  $29B00  25  29  696  $2B800  26
29  725  $2D500  27  29  754  $2F200  28  29  783
$30F00  29  29  812  $32C00  30  29  841  $34900  31
29  870  $36600  32  29  899  $38300  33  29  928
$3A000  34  29  957  $3BD00  35  29  986  $3DA00  36
29  1015  $3F700  37  29  1044  $41400  38  29
1073  $43100  39  29  1102  $44E00  40  27  1131
$46B00  41  27  1158  $48600  42  27  1185  $4A100
43  27  1212  $4BC00  44  27  1239  $4D700  45  27
1266  $4F200  46  27  1293  $50D00  47  27  1320
$52800  48  27  1347  $54300  49  27  1374  $55E00
50  27  1401  $57900  51  27  1428  $59400  52  27
1455  $5AF00  53  27  1482  $5CA00  54  25  1509
$5E500  55  25  1534  $5FE00  56  25  1559  $61700
57  25  1584  $63000  58  25  1609  $64900  59  25
1634  $66200  60  25  1659  $67B00  61  25  1684
$69400  62  25  1709  $6AD00  63  25  1734  $6C600
64  25  1759  $6DF00  65  23  1784  $6F800  66  23
1807  $70F00  67  23  1830  $72600  68  23  1853
$73D00  69  23  1876  $75400  70  23  1899  $76B00
71  23  1922  $78200  72  23  1945  $79900  73  23
1968  $7B000  74  23  1991  $7C700  75  23  2014
$7DE00  76  23  2037  $7F500  77  23  2060  $80C00
multitable  The BAM (Block Availability Map) is on track 38. The
D80 is only 77 tracks and so the BAM is contained on 38/0 and 38/3.
The BAM interleave is 3.  The directory is on track 39, with 39/0
contains the header (DOS type, disk name, disk ID's) and sectors 1-28
contain the directory entries. Both files and the directory use an
interleave of 1. Since the directory is only 28 sectors large (29
less one for the header), and each sector can contain only 8 entries
(32 bytes per entry), the maximum number of directory entries is 28 *
8 = 224. The first directory sector is always 39/1. It then follows a
chain structure using a sector interleave of 1 making the links go
39/1, 39/2, 39/3 etc.  When reading a disk, you start with 39/0
(disk label/ID) which points to 38/0 (BAM0), 38/3 (BAM1), and finally
to 39/1 (first dir entry sector). When writing a file to a blank
disk, it will start at 38/1 because 38/0 is already allocated. 
Below is a dump of the header sector 39/0: 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 26 00 43 00 00 00
73 61 6D 70 6C 65 20 64 38 30 10: A0 A0 A0 A0 A0 A0 A0 A0 65 72 A0 32
43 A0 A0 A0 20: A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
... F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  example
   .3 .7  Bytes  Description  $00-$01  T/S pointer to first
BAM sector (38/0)  $02  $43 'C' is for DOS format version  $03
Reserved  $04-$05  Unused  $06-$16  Disk name, padded with 0xA0
("sample d80")  $17  0xA0  $18-$19  Disk ID bytes "er"  $1A
0xA0  $1B-$1C  DOS version bytes "2C"  $1D-$20  0xA0
$21-$FF  Unused  multitable  Below is a dump of the first
directory sector, 39/1 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 27 02 82 26 01 54
45 53 54 A0 A0 A0 A0 A0 A0 A0 10: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 01 00 20: 00 00 82 26 02 54 45 53 54 32 A0 A0 A0 A0 A0 A0 30:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 01 00 40: 00 00 82 26 04 54
45 53 54 33 A0 A0 A0 A0 A0 A0 50: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 05 00 60: 00 00 82 26 0B 54 45 53 54 34 A0 A0 A0 A0 A0 A0 70:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 09 00 80: 00 00 82 26 14 54
45 53 54 35 A0 A0 A0 A0 A0 A0 90: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 0C 00 A0: 00 00 82 28 00 54 45 53 54 36 A0 A0 A0 A0 A0 A0 B0:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 01 00 C0: 00 00 82 28 01 54
45 53 54 37 A0 A0 A0 A0 A0 A0 D0: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 01 00 E0: 00 00 82 28 02 54 45 53 54 38 A0 A0 A0 A0 A0 A0 F0:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 01 00  example  The
first two bytes of the directory sector ($27/$02) indicate the
location of the next track/sector of the directory (39/2). If the
track is set to $00, then it is the last sector of the directory. 
When the directory is done, the track value will be $00. The sector
link should contain a value of $FF, meaning the whole sector is
allocated, but the actual value doesn't matter. The drive will return
all the available entries anyways. This is a breakdown of a standard
directory sector:    .2 .8  Bytes  Description  $00-$1F
First directory entry  $20-$3F  Second dir entry  $40-$5F
Third dir entry  $60-$7F  Fourth dir entry  $80-$9F  Fifth dir
entry  $A0-$BF  Sixth dir entry  $C0-$DF  Seventh dir entry
$E0-$FF  Eighth dir entry  multitable  This is a breakdown of a
standard directory entry:    .2 .8  Bytes  Description
$00-$01  Track/Sector location of next directory sector ($00 $00 if
not the first entry in the sector)  $02  File type  $03-$04
Track/sector location of first sector of file  $05-$14  16
character filename (in PETASCII, padded with $A0)  $15-$16
Track/Sector location of first side-sector block (REL file only)
$17  REL file record length (REL file only, max. value 254)
$18-$1D  Unused  $1E-$1F  File size in sectors, low/high byte
order ($1E+$1F*256). The approx. filesize in bytes is <= #sectors *
254 0 multitable  The file type field is used as follows: 
.2 .8  Bits  Description  0-3  The actual file type  4
Unused  5  Used only during SAVE- replacement  6  Locked flag
(Set produces ">" locked files)  7  Closed flag (Not set produces
"*", or "splat" files)  multitable  The actual file type can be
one of the following:    .2 .2 .6  Binary  Decimal  File
type  0000  0  DEL  0001  1  SEQ  0010  2  PRG
0011  3  USR  0100  4  REL  multitable  Values 5-15 are
illegal, but if used will produce very strange results. 

Non-Standard & Long Directories
--------------------------------

    Most Commdore floppy disk drives use a single dedicated
directory track where all filenames are stored. This limits the
number of files stored on a disk based on the number of sectors on
the directory track. There are some disk images that contain more
files than would normally be allowed. This requires extending the
directory off the default directory track by changing the last
directory sector pointer to a new track, allocating the new sectors
in the BAM, and manually placing (or moving existing) file entries
there. The directory of an extended disk can be read and the files
that reside there can be loaded without problems on a real drive.
However, this is still a very dangerous practice as writing to the
extended portion of the directory will cause directory corruption in
the non-extended part. Many of the floppy drives core ROM routines
ignore the track value that the directory is on and assume the
default directory track for operations. 

BAM layout
-----------

    The BAM only occupies up to four sectors on track 38, so the
rest of the track is empty and is available for file storage. Below
is a dump of the first BAM block, 38/0. A D80 will only contain two
BAM sectors, 38/0 and 38/3. Each entry takes 5 bytes, 1 for the free
count on that track, and 4 for the BAM bits. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 26 03 43 00 01 33
1D FF FF FF 1F 1D FF FF FF 1F 10: 1D FF FF FF 1F 1D FF FF FF 1F 1D FF
FF FF 1F 1D 20: FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF 30:
FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF 40: FF 1F 1D FF FF FF
1F 1D FF FF FF 1F 1D FF FF FF 50: 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D
FF FF FF 1F 60: 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D 70:
FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF 80: FF FF 1F 1D FF FF
FF 1F 1D FF FF FF 1F 1D FF FF 90: FF 1F 1D FF FF FF 1F 1D FF FF FF 1F
1D FF FF FF A0: 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F B0:
1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1B C0: F6 FF FF 1F 1B FC
FF FF 1F 1B FF FF FF 07 1B FF D0: FF FF 07 1B FF FF FF 07 1B FF FF FF
07 1B FF FF E0: FF 07 1B FF FF FF 07 1B FF FF FF 07 1B FF FF FF F0:
07 1B FF FF FF 07 1B FF FF FF 07 1B FF FF FF 07  example    .3
.7  Bytes  Description  $00-$01  T/S pointer to second BAM
sector (38/3)  $02  DOS version byte (0x43='C')  $03  Reserved
$04  Lowest track covered by this BAM (0x01=1)  $05  Highest+1
track covered by this BAM (0x33=51)  $06-$0A  BAM for track 1. The
first byte shows the "blocks free" for this track, the remaining 4 show
the BAM for the track.  $0B-$0F  BAM for track 2  ...  ...
$FB-$FF  BAM for track 50  multitable  Being bit-based, the BAM
entries need some explanation. The first track entry in the above BAM
sector is at offset 06, "1D FF FF FF 1F". The first number is how
many blocks are free on this track ($1D=29) and the remainder is the
bit representation of the usage map for the track. These entries
must be viewed in binary to make any sense. First convert the values
to binary: 

   FF=11111111, FF=11111111, FF=11111111, 1F=00011111  example 
In order to make any sense from the binary notation, flip the bits
around. 

   111111 11112222 222222  01234567 89012345 67890123 456789...
------------------------- --------  11111111 11111111 11111111
11111000  ^                              ^  sector 0
  sector 28  example  Since we are on the first track, we have
29 sectors, and only use up to the bit 28 position. If a bit is on
(1), the sector is free. Therefore, track 1 is clean, all sectors are
free. Any leftover bits that refer to sectors that don't exist,
like bits 29-31 in the above example, are set to allocated.  Second
BAM block 38/3. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 27 01 43 00 33 4E
1B FF FF FF 07 1B FF FF FF 07 10: 1B FF FF FF 07 19 FF FF FF 01 19 FF
FF FF 01 19 20: FF FF FF 01 19 FF FF FF 01 19 FF FF FF 01 19 FF 30:
FF FF 01 19 FF FF FF 01 19 FF FF FF 01 19 FF FF 40: FF 01 19 FF FF FF
01 19 FF FF FF 01 17 FF FF 7F 50: 00 17 FF FF 7F 00 17 FF FF 7F 00 17
FF FF 7F 00 60: 17 FF FF 7F 00 17 FF FF 7F 00 17 FF FF 7F 00 17 70:
FF FF 7F 00 17 FF FF 7F 00 17 FF FF 7F 00 17 FF 80: FF 7F 00 17 FF FF
7F 00 17 FF FF 7F 00 00 00 00 90: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 D0: 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 E0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 F0:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  example    .3
.7  Bytes  Description  $00-$01  T/S pointer to second BAM
sector (39/1)  $02  DOS version byte (0x43='C')  $03  Reserved
$04  Lowest track covered by this BAM (0x33=51)  $05  Highest+1
track covered by this BAM (0x43=78)  $06-$0A  BAM for track 51. The
first byte shows the "blocks free" for this track, the remaining 4 show
the BAM for the track.  $0B-$0F  BAM for track 52  ...  ...
$88-$8C  BAM for track 77  $8D-$FF  Not used  multitable 


@EndNode

@Node "D82" "vice.guide/D82"
@Next "P00"
@Prev "D80"
@Toc "File formats"

The D82 disk image format
==========================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  This is a sector-for-sector
copy of an 8250 floppy disk. The file size for an 8250 image is
1066496 bytes. It is comprised of 256-byte sectors arranged across
154 tracks, with a varying number of sectors per track for a total of
4166 sectors. Track counting starts at 1 (not 0) and sector counting
starts at 0 (not 1), therefore a track with 29 sectors will go from 0
to 28.  The original media (a 5.25" disk) has the tracks laid out
in circles, with track 1 on the very outside of the disk (closest
to the sides) to track 77 being on the inside of the disk (closest to
the inner hub ring). Commodore, in their infinite wisdom, varied the
number of sectors per track and data densities across the disk to
optimize available storage, resulting in the chart below. It shows
the sectors/track for a D82. Since the outside diameter of a circle
is the largest (versus closer to the center), the outside tracks have
the largest amount of storage.     .33 .33 .33  Track Range
Sectors/track  # Sectors  1-39  29  1131  40-53  27
378  55-64  25  275  65-77  23  299  78-116  29
1131  117-130  27  378  131-141  25  275  142-154  23
299  multitable    .25 .25 .25 .25  Track  #Sect
#SectorsIn  D82 Offset  1  29  0  $000000  2  29  29
$001D00  3  29  58  $003A00  4  29  87  $005700  5
29  116  $007400  6  29  145  $009100  7  29  174
$00AE00  8  29  203  $00CB00  9  29  232  $00E800
10  29  261  $010500  11  29  290  $012200  12  29
319  $013F00  13  29  348  $015C00  14  29  377
$017900  15  29  406  $019600  16  29  435  $01B300
17  29  464  $01D000  18  29  493  $01ED00  19  29
522  $020A00  20  29  551  $022700  21  29  580
$024400  22  29  609  $026100  23  29  638  $027E00
24  29  667  $029B00  25  29  696  $02B800  26  29
725  $02D500  27  29  754  $02F200  28  29  783
$030F00  29  29  812  $032C00  30  29  841  $034900
31  29  870  $036600  32  29  899  $038300  33  29
928  $03A000  34  29  957  $03BD00  35  29  986
$03DA00  36  29  1015  $03F700  37  29  1044  $041400
38  29  1073  $043100  39  29  1102  $044E00  40
27  1131  $046B00  41  27  1158  $048600  42  27
1185  $04A100  43  27  1212  $04BC00  44  27  1239
$04D700  45  27  1266  $04F200  46  27  1293  $050D00
47  27  1320  $052800  48  27  1347  $054300  49
27  1374  $055E00  50  27  1401  $057900  51  27
1428  $059400  52  27  1455  $05AF00  53  27  1482
$05CA00  54  25  1509  $05E500  55  25  1534  $05FE00
56  25  1559  $061700  57  25  1584  $063000  58
25  1609  $064900  59  25  1634  $066200  60  25
1659  $067B00  61  25  1684  $069400  62  25  1709
$06AD00  63  25  1734  $06C600  64  25  1759  $06DF00
65  23  1784  $06F800  66  23  1807  $070F00  67
23  1830  $072600  68  23  1853  $073D00  69  23
1876  $075400  70  23  1899  $076B00  71  23  1922
$078200  72  23  1945  $079900  73  23  1968  $07B000
74  23  1991  $07C700  75  23  2014  $07DE00  76
23  2037  $07F500  77  23  2060  $080C00  78  29
2083  $082300  79  29  2112  $084000  80  29  2141
$085D00  81  29  2170  $087A00  82  29  2199  $089700
83  29  2228  $08B400  84  29  2257  $08D100  85
29  2286  $08EE00  86  29  2315  $090600  87  29
2344  $092800  88  29  2373  $094500  89  29  2402
$096200  90  29  2431  $097F00  91  29  2460  $099C00
92  29  2489  $09B900  93  29  2518  $09D600  94
29  2547  $09F300  95  29  2576  $0A1000  96  29
2605  $0A2D00  97  29  2634  $0A4A00  98  29  2663
$0A6700  99  29  2692  $0A8400  100  29  2721  $0AA100
101  29  2750  $0ABE00  102  29  2779  $0ADB00  103
29  2808  $0AF800  104  29  2837  $0B1500  105  29
2866  $0B3200  106  29  2895  $0B4F00  107  29  2924
$0B6C00  108  29  2953  $0B8900  109  29  2982
$0BA600  110  29  3011  $0BC300  111  29  3040
$0BE000  112  29  3069  $0BFD00  113  29  3098
$0C1A00  114  29  3137  $0C3700  115  29  3156
$0C5400  116  29  3185  $0C7100  117  27  3214
$0C8E00  118  27  3241  $0CA900  119  27  3268
$0CC400  120  27  3295  $0CDF00  121  27  3322
$0CFA00  122  27  3349  $0D1500  123  27  3376
$0D3000  124  27  3403  $0D4B00  125  27  3430
$0D6600  126  27  3457  $0D8100  127  27  3484
$0D9C00  128  27  3511  $0DB700  129  27  3538
$0DD200  130  27  3565  $0DED00  131  25  3592
$0E0800  132  25  3617  $0E2100  133  25  3642
$0E3A00  134  25  3667  $0E5300  135  25  3692
$0E6C00  136  25  3717  $0E8500  137  25  3742
$0E9E00  138  25  3767  $0EB700  139  25  3792
$0ED000  140  25  3817  $0EE900  141  25  3842
$0F0200  142  23  3867  $0F1B00  143  23  3890
$0F3200  144  23  3913  $0F4900  145  23  3936
$0F6000  146  23  3959  $0F7700  147  23  3982
$0F8E00  148  23  4005  $0FA500  149  23  4028
$0FBC00  150  23  4051  $0FD300  151  23  4074
$0FEA00  152  23  4097  $100100  153  23  4120
$101800  154  23  4143  $102F00  multitable  The BAM
(Block Availability Map) is on track 38. The D82 is 154 tracks and so
the BAM is contained on 38/0, 38/3, 38/6 and 38/9. The BAM interleave
is 3.  The directory is on track 39, with 39/0 contains the header
(DOS type, disk name, disk ID's) and sectors 1-28 contain the
directory entries. Both files and the directory use an interleave of
1. Since the directory is only 28 sectors large (29 less one for the
header), and each sector can contain only 8 entries (32 bytes per
entry), the maximum number of directory entries is 28 * 8 = 224. The
first directory sector is always 39/1. It then follows a chain
structure using a sector interleave of 1 making the links go 39/1,
39/2, 39/3 etc.  When reading a disk, you start with 39/0 (disk
label/ID) which points to 38/0 (BAM0), 38/3 (BAM1), 38/6 (BAM2), 38/9
(BAM3, and finally to 39/1 (first dir entry sector). When writing a
file to a blank disk, it will start at 38/1 because 38/0 is already
allocated.  Below is a dump of the header sector 39/0: 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 26 00 43 00 00 00
73 61 6D 70 6C 65 20 64 38 30 10: A0 A0 A0 A0 A0 A0 A0 A0 65 72 A0 32
43 A0 A0 A0 20: A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
... F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  example
   .3 .7  Bytes  Description  $00-$01  T/S pointer to first
BAM sector (38/0)  $02  $43 'C' is for DOS format version  $03
Reserved  $04-$05  Unused  $06-$16  Disk name, padded with 0xA0
("sample d82")  $17  0xA0  $18-$19  Disk ID bytes "er"  $1A
0xA0  $1B-$1C  DOS version bytes "2C"  $1D-$20  0xA0
$21-$FF  Unused  multitable  Below is a dump of the first
directory sector, 39/1 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 27 02 82 26 01 54
45 53 54 A0 A0 A0 A0 A0 A0 A0 10: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 01 00 20: 00 00 82 26 02 54 45 53 54 32 A0 A0 A0 A0 A0 A0 30:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 01 00 40: 00 00 82 26 04 54
45 53 54 33 A0 A0 A0 A0 A0 A0 50: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 05 00 60: 00 00 82 26 0B 54 45 53 54 34 A0 A0 A0 A0 A0 A0 70:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 09 00 80: 00 00 82 26 14 54
45 53 54 35 A0 A0 A0 A0 A0 A0 90: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 0C 00 A0: 00 00 82 28 00 54 45 53 54 36 A0 A0 A0 A0 A0 A0 B0:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 01 00 C0: 00 00 82 28 01 54
45 53 54 37 A0 A0 A0 A0 A0 A0 D0: A0 A0 A0 A0 A0 00 00 00 00 00 00 00
00 00 01 00 E0: 00 00 82 28 02 54 45 53 54 38 A0 A0 A0 A0 A0 A0 F0:
A0 A0 A0 A0 A0 00 00 00 00 00 00 00 00 00 01 00  example  The
first two bytes of the directory sector ($27/$02) indicate the
location of the next track/sector of the directory (39/2). If the
track is set to $00, then it is the last sector of the directory. 
When the directory is done, the track value will be $00. The sector
link should contain a value of $FF, meaning the whole sector is
allocated, but the actual value doesn't matter. The drive will return
all the available entries anyways. This is a breakdown of a standard
directory sector:    .2 .8  Bytes  Description  $00-$1F
First directory entry  $20-$3F  Second dir entry  $40-$5F
Third dir entry  $60-$7F  Fourth dir entry  $80-$9F  Fifth dir
entry  $A0-$BF  Sixth dir entry  $C0-$DF  Seventh dir entry
$E0-$FF  Eighth dir entry  multitable  This is a breakdown of a
standard directory entry:    .2 .8  Bytes  Description
$00-$01  Track/Sector location of next directory sector ($00 $00 if
not the first entry in the sector)  $02  File type  $03-$04
Track/sector location of first sector of file  $05-$14  16
character filename (in PETASCII, padded with $A0)  $15-$16
Track/Sector location of first side-sector block (REL file only)
$17  REL file record length (REL file only, max. value 254)
$18-$1D  Unused  $1E-$1F  File size in sectors, low/high byte
order ($1E+$1F*256). The approx. filesize in bytes is <= #sectors *
254 0 multitable  The file type field is used as follows: 
.2 .8  Bits  Description  0-3  The actual file type  4
Unused  5  Used only during SAVE- replacement  6  Locked flag
(Set produces ">" locked files)  7  Closed flag (Not set produces
"*", or "splat" files)  multitable  The actual file type can be
one of the following:    .2 .2 .6  Binary  Decimal  File
type  0000  0  DEL  0001  1  SEQ  0010  2  PRG
0011  3  USR  0100  4  REL  multitable  Values 5-15 are
illegal, but if used will produce very strange results. 

Non-Standard & Long Directories
--------------------------------

    Most Commdore floppy disk drives use a single dedicated
directory track where all filenames are stored. This limits the
number of files stored on a disk based on the number of sectors on
the directory track. There are some disk images that contain more
files than would normally be allowed. This requires extending the
directory off the default directory track by changing the last
directory sector pointer to a new track, allocating the new sectors
in the BAM, and manually placing (or moving existing) file entries
there. The directory of an extended disk can be read and the files
that reside there can be loaded without problems on a real drive.
However, this is still a very dangerous practice as writing to the
extended portion of the directory will cause directory corruption in
the non-extended part. Many of the floppy drives core ROM routines
ignore the track value that the directory is on and assume the
default directory track for operations. 

BAM layout
-----------

    The BAM only occupies up to four sectors on track 38, so the
rest of the track is empty and is available for file storage. Below
is a dump of the first BAM block, 38/0. A D82 will contain four BAM
sectors, 38/0, 38/3, 38/6 and 38/9. Each entry takes 5 bytes, 1 for
the free count on that track, and 4 for the BAM bits. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 26 03 43 00 01 33
1D FF FF FF 1F 1D FF FF FF 1F 10: 1D FF FF FF 1F 1D FF FF FF 1F 1D FF
FF FF 1F 1D 20: FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF 30:
FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF 40: FF 1F 1D FF FF FF
1F 1D FF FF FF 1F 1D FF FF FF 50: 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D
FF FF FF 1F 60: 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D 70:
FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF 80: FF FF 1F 1D FF FF
FF 1F 1D FF FF FF 1F 1D FF FF 90: FF 1F 1D FF FF FF 1F 1D FF FF FF 1F
1D FF FF FF A0: 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F B0:
1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1B C0: F6 FF FF 1F 1B FC
FF FF 1F 1B FF FF FF 07 1B FF D0: FF FF 07 1B FF FF FF 07 1B FF FF FF
07 1B FF FF E0: FF 07 1B FF FF FF 07 1B FF FF FF 07 1B FF FF FF F0:
07 1B FF FF FF 07 1B FF FF FF 07 1B FF FF FF 07  example    .3
.7  Bytes  Description  $00-$01  T/S pointer to second BAM
sector (38/3)  $02  DOS version byte (0x43='C')  $03  Reserved
$04  Lowest track covered by this BAM (0x01=1)  $05  Highest+1
track covered by this BAM (0x33=51)  $06-$0A  BAM for track 1. The
first byte shows the "blocks free" for this track, the remaining 4 show
the BAM for the track.  $0B-$0F  BAM for track 2  ...  ...
$FB-$FF  BAM for track 50  multitable  Being bit-based, the BAM
entries need some explanation. The first track entry in the above BAM
sector is at offset 06, "1D FF FF FF 1F". The first number is how
many blocks are free on this track ($1D=29) and the remainder is the
bit representation of the usage map for the track. These entries
must be viewed in binary to make any sense. First convert the values
to binary: 

   FF=11111111, FF=11111111, FF=11111111, 1F=00011111  example 
In order to make any sense from the binary notation, flip the bits
around. 

   111111 11112222 222222  01234567 89012345 67890123 456789...
------------------------- --------  11111111 11111111 11111111
11111000  ^                              ^  sector 0
 sector 28  example  Since we are on the first track, we have 29
sectors, and only use up to the bit 28 position. If a bit is on (1),
the sector is free. Therefore, track 1 is clean, all sectors are
free. Any leftover bits that refer to sectors that don't exist, like
bits 29-31 in the above example, are set to allocated.  Second
BAM block 38/3 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 26 06 43 00 33 65
1B FF FF FF 07 1B FF FF FF 07 10: 1B FF FF FF 07 19 FF FF FF 01 19 FF
FF FF 01 19 20: FF FF FF 01 19 FF FF FF 01 19 FF FF FF 01 19 FF 30:
FF FF 01 19 FF FF FF 01 19 FF FF FF 01 19 FF FF 40: FF 01 19 FF FF FF
01 19 FF FF FF 01 17 FF FF 7F 50: 00 17 FF FF 7F 00 17 FF FF 7F 00 17
FF FF 7F 00 60: 17 FF FF 7F 00 17 FF FF 7F 00 17 FF FF 7F 00 17 70:
FF FF 7F 00 17 FF FF 7F 00 17 FF FF 7F 00 17 FF 80: FF 7F 00 17 FF FF
7F 00 17 FF FF 7F 00 1D FF FF 90: FF 1F 1D FF FF FF 1F 1D FF FF FF 1F
1D FF FF FF A0: 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F B0:
1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D C0: FF FF FF 1F 1D FF
FF FF 1F 1D FF FF FF 1F 1D FF D0: FF FF 1F 1D FF FF FF 1F 1D FF FF FF
1F 1D FF FF E0: FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF F0:
1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F  example    .3
.7  Bytes  Description  $00-$01  T/S pointer to third BAM
sector (38/6)  $02  DOS version byte (0x43='C')  $03  Reserved
$04  Lowest track covered by this BAM (0x33=51)  $05  Highest+1
track covered by this BAM (0x65=101)  $06-$0A  BAM for track 51.
The first byte shows the "blocks free" for this track, the remaining 4
show the BAM for the track.  $0B-$0F  BAM for track 52  ...
...  $FB-$FF  BAM for track 100  multitable  Third BAM block
38/6 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 26 09 43 00 65 97
1D FF FF FF 1F 1D FF FF FF 1F 10: 1D FF FF FF 1F 1D FF FF FF 1F 1D FF
FF FF 1F 1D 20: FF FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF 30:
FF FF 1F 1D FF FF FF 1F 1D FF FF FF 1F 1D FF FF 40: FF 1F 1D FF FF FF
1F 1D FF FF FF 1F 1D FF FF FF 50: 1F 1D FF FF FF 1F 1B FF FF FF 07 1B
FF FF FF 07 60: 1B FF FF FF 07 1B FF FF FF 07 1B FF FF FF 07 1B 70:
FF FF FF 07 1B FF FF FF 07 1B FF FF FF 07 1B FF 80: FF FF 07 1B FF FF
FF 07 1B FF FF FF 07 1B FF FF 90: FF 07 1B FF FF FF 07 1B FF FF FF 07
19 FF FF FF A0: 01 19 FF FF FF 01 19 FF FF FF 01 19 FF FF FF 01 B0:
19 FF FF FF 01 19 FF FF FF 01 19 FF FF FF 01 19 C0: FF FF FF 01 19 FF
FF FF 01 19 FF FF FF 01 19 FF D0: FF FF 01 17 FF FF 7F 00 17 FF FF 7F
00 17 FF FF E0: 7F 00 17 FF FF 7F 00 17 FF FF 7F 00 17 FF FF 7F F0:
00 17 FF FF 7F 00 17 FF FF 7F 00 17 FF FF 7F 00  example    .3
.7  Bytes  Description  $00-$01  T/S pointer to fourth BAM
sector (38/9)  $02  DOS version byte (0x43='C')  $03  Reserved
$04  Lowest track covered by this BAM (0x65=101)  $05  Highest+1
track covered by this BAM (0x97=151)  $06-$0A  BAM for track 101.
The first byte shows the "blocks free" for this track, the remaining 4
show the BAM for the track.  $0B-$0F  BAM for track 102  ...
...  $FB-$FF  BAM for track 150  multitable  Fourth BAM block
38/9 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 00: 27 01 43 00 97 9B
17 FF FF 7F 00 17 FF FF 7F 00 10: 17 FF FF 7F 00 17 FF FF 7F 00 00 00
00 00 00 00 20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 30:
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 40: 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00  example    .3 .7  Bytes
Description  $00-$01  T/S pointer to first directory sector (39/1)
$02  DOS version byte (0x43='C')  $03  Reserved  $04  Lowest
track covered by this BAM (0x97=151)  $05  Highest+1 track covered
by this BAM (0x9B=155)  $06-$0A  BAM for track 151. The first byte
shows the "blocks free" for this track, the remaining 4 show the BAM
for the track.  $0B-$0F  BAM for track 152  ...  ...
$15-$19  BAM for track 154  $1A-$FF  Not used  multitable 


@EndNode

@Node "P00" "vice.guide/P00"
@Prev "D82"
@Toc "File formats"

The P00 image format
=====================

     (This section was contributed by Peter Schepers and slightly
edited by Marco van den Heuvel.)  These files were created for
use in the PC64 emulator, written by Wolfgang Lorenz. Each one has
the same layout with the filetype being stored in the DOS extension
(i.e. Pxx is a PRG, Sxx is a SEQ, Uxx is a USR and Rxx is a RELative
file), and the header is only 26 bytes long.  This is a dump of a
Pxx file (PRG)... 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
---------------------------------------------- 0000: 43 36 34 46 69
6C 65 00 43 52 49 53 49 53 20 4D 0010: 4F 55 4E 54 41 49 4E 00 00 00
example    .3 .7  Bytes  Description  $00-$06  ASCII
string "C64File"  $07  Always $00  $08-$17  Filename in
PETASCII, padded with $00 (not $A0, like a D64)  $18  Always $00
$19  REL file record size ($00 if not a REL file)  $1A-??
Program data  multitable  The 'xx' in the extension of the file
is usually 00, except when we have two DOS filenames which would be
the same, but the C64 filenames are different! If we have two C64
filenames which are the same, they *cannot* co-exist in the same
directory. If we have two files which do convert down to be the same
DOS filename, the extension is incremented until an unused one is
found (x01, x02, x03, up to x99). We can have up to 99 different C64
files with the same corresponding DOS names as that's all the
extension will hold (from P00 to P99).  Each PC64 file only has one
entry, there are no multi-file containers allowed. This could result
in a large number of these files in a directory, even for only a few
programs, as each C64 file will result in a PC64 file entry. The best
use for a PC64 file is a single-file program, one which does not
load anything else.  

The CRT cartridge image format
===============================

    This chapter is based on CRT.txt (rev1.14) compiled by Peter
Schepers, with additional contributions from Per Hakan Sundell,
Markus Brenner, Marco Van Den Heuvel, Groepaz.    Cartridge files
were introduced in the CCS64  emulator,  written  by  Per Hakan
Sundell, and use the ".CRT" file extension. This format  was  created
to handle the various ROM cartridges that exist, such as Action Replay,
the Power cartridge, and the Final Cartridge.    Normal game
cartridges can load  into  several  different  memory  ranges
($8000-9FFF,  $A000-BFFF  or  $E000-FFFF).  Newer   utility   and
freezer cartridges were less intrusive, hiding themselves until
called  upon,  and still others used bank-switching techniques to
allow much larger ROM's than normal. Because of these "stealthing"
and bank-switching methods, a special cartridge format  was
necessary,  to  let  the  emulator  know  where  the cartridge should
reside, the control line  states  to  enable  it  and  any special
hardware features it uses. 

Header contents
----------------

      Here is a dump of a sample 8K normal cartridge,  "Attack  Of
The  Mutant Camels"... 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F        ASCII
----------------------------------------------   ---------------
0000: 43 36 34 20 43 41 52 54 52 49 44 47 45 20 20 20
C64?CARTRIDGE??? 0010: 00 00 00 40 01 00 00 00 00 01 00 00 00 00 00
00   ??????????????? 0020: 41 54 54 41 43 4B 20 4F 46 20 54 48 45 20
4D 55   ATTACK?OF?THE?MU 0030: 54 41 4E 54 20 43 41 4D 45 4C 53 00 00
00 00 00   TANT?CAMELS????? 0040: 43 48 49 50 00 00 20 10 00 00 00 00
80 00 20 00   CHIP????????.??? 0050: D3 9B BC FE C3 C2 CD 38 30 EA EA
EA A9 01 85 13   .?....80....?? 0060: 4C B3 9B A9 08 85 5A 88 D0
FD C6 5A D0 F9 60 D0   L³.?Z...Z.?`.  example 

   Bytes:$0000-000F - 16-byte cartridge signature  "C64  CARTRIDGE"
(padded                      with space characters)
0010-0013 - File header length  ($00000040,  in  high/low  format,
                 calculated from offset $0000). The default  (also
the                      minimum) value is $40.  Some  cartridges
exist  which                      show a value of $00000020 which is
wrong.          0014-0015 - Cartridge version (high/low, presently
01.00)          0016-0017 - Cartridge hardware type ($0000,
high/low)                        0 - Normal cartridge
        1 - Action Replay                        2 - KCS Power
Cartridge                        3 - Final Cartridge III
           4 - Simons' BASIC                        5 - Ocean type
1*                        6 - Expert Cartridge
 7 - Fun Play, Power Play                        8 - Super Games
                    9 - Atomic Power                       10 - Epyx
Fastload                       11 - Westermann Learning
         12 - Rex Utility                       13 - Final Cartridge
I                       14 - Magic Formel                       15
- C64 Game System, System 3                       16 - Warp Speed
                   17 - Dinamic**                       18 - Zaxxon,
Super Zaxxon (SEGA)                       19 - Magic Desk, Domark,
HES Australia                       20 - Super Snapshot V5
            21 - Comal-80                       22 - Structured
BASIC                       23 - Ross                       24 -
Dela EP64                       25 - Dela EP7x8
 26 - Dela EP256                       27 - Rex EP256
        28 - Mikro Assembler                       29 - Final
Cartridge Plus                       30 - Action Replay 4
           31 - Stardos                       32 - EasyFlash
               33 - EasyFlash Xbank                       34 -
Capture                       35 - Action Replay 3
    36 - Retro Replay                       37 - MMC64
         38 - MMC Replay                       39 - IDE64
            40 - Super Snapshot V4                       41 -
IEEE-488                       42 - Game Killer
 43 - Prophet64                       44 - EXOS
  45 - Freeze Frame                       46 - Freeze Machine
                47 - Snapshot64                       48 - Super
Explode V5.0                       49 - Magic Voice
     50 - Action Replay 2                       51 - MACH 5
              52 - Diashow-Maker                       53 - Pagefox
             0018 - Cartridge port EXROM line status
     0 - inactive                       1 - active
0019 - Cartridge port GAME line status                       0 -
inactive                       1 - active          001A-001F -
Reserved for future use          0020-003F - 32-byte cartridge  name
"CCSMON"  (uppercase,  padded                      with null
characters)          0040-xxxx - Cartridge contents (called CHIP
PACKETS, as there  can                      be more than one  per
CRT  file).  See  below  for  a                      breakdown of the
CHIP format.  example    (*Note: Ocean type 1 includes Navy
Seals, Robocop 2 & 3,  Shadow  of  the     Beast, Toki, Terminator 2
and more)    (**Note: Dinamic includes Narco Police and more) 

CHIP Contents
--------------

       The following is the contents of the CHIP packet, from
position $0040  on in the CRT file. Note I have re-adjusted the
starting address to be  $0000, since we are now looking at a file
contained in the .CRT file, and all size references are from where it
starts. 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F        ASCII
----------------------------------------------   ---------------
0000: 43 48 49 50 00 00 20 10 00 00 00 00 80 00 20 00
CHIP????????.??? 0010: D3 9B BC FE C3 C2 CD 38 30 EA EA EA A9 01 85
13   .?....80....?? 0020: 4C B3 9B A9 08 85 5A 88 D0 FD C6 5A D0
F9 60 D0   L³.?Z...Z.?`. 0030: F2 60 A9 04 85 49 A9 00 85 48
A2 00 A5 48 9D 40   ?`.?I.?H.?¥H 0040: 03 A5 49 9D 60 03 A5 48
18 69 28 85 48 A5 49 69   ?¥I`?¥H?i(H¥Ii 0050: 00 85 49 E8 E0
18 D0 E4 60 A6 03 A4 02 BD 40 03   ?I???.?`??????  example 

   Bytes:$0000-0003 - Contained ROM signature "CHIP" (note there can be
more                      than one image in a .CRT file)
0004-0007 - Total packet length ($00002010,  ROM  image  size  and
                 header combined) (high/low format)
0008-0009 - Chip type                       0 - ROM
     1 - RAM, no ROM data                       2 - Flash ROM
   000A-000B - Bank number ($0000 - normal cartridge)
000C-000D - Starting load address (high/low format)
000E-000F - ROM image size in bytes  (high/low  format,  typically
                 $2000 or $4000)          0010-xxxx - ROM data
example    The following is a chart taken from the "Commodore
Programmers  Reference Guide". It details the state of various areas
of memory  depending  on  the state of the control lines.  
Legend: L - ROML (low) H - ROMH (high) G - GAME E - EXROM 

   Addr       LHGE   LHGE   LHGE   LHGE   LHGE   LHGE   LHGE   LHGE
LHGE Range            1111   101X   1000   011X   001X   1110
0100   1100   XX01          default                00X0
             Ultimax
------------------------------------------------------------------------
E000-FFFF Kernal  RAM    RAM   Kernal  RAM   Kernal Kernal Kernal
ROMH(*) D000-DFFF IO/CHR IO/CHR IO/RAM IO/CHR  RAM   IO/CHR IO/CHR
IO/CHR   I/O C000-CFFF  RAM    RAM    RAM    RAM    RAM    RAM    RAM
  RAM     - A000-BFFF BASIC   RAM    RAM    RAM    RAM   BASIC
ROMH   ROMH    - 8000-9FFF  RAM    RAM    RAM    RAM    RAM    ROML
RAM    ROML  ROML(*) 4000-7FFF  RAM    RAM    RAM    RAM    RAM
RAM    RAM    RAM     - 1000-3FFF  RAM    RAM    RAM    RAM    RAM
RAM    RAM    RAM     - 0000-0FFF  RAM    RAM    RAM    RAM    RAM
RAM    RAM    RAM    RAM  example  (*) Internal memory does not
respond to write accesses in these areas     From the above
chart, the following table can be built. It shows standard
cartridges, either 8K or 16K in size, and the memory ranges they load
into. 

   Type     Size   Game   EXRom  Low Bank  High Bank          in K
Line   Line    (ROML)    (ROMH)
------------------------------------------------ Normal    8k     hi
  lo     $8000      --- Normal    16k    lo     lo     $8000
$A000 Ultimax   8k     lo     hi     $E000      ---  example 
The ROMH and ROML lines are CPU-controlled status  lines,  used  to
bank in/out RAM, ROM or I/O, depending on what is needed at the
time.    Ultimax cartridges typically are situated  in  the
$E000-FFFF  (8K)  ROM address range. There are some cartridges  which
only  use  4K  of  the  8K allocation. If the cartridge is 16K in
size, then it will  reside  in  both $8000-9FFF and $E000-FFFF. 

Cartridge Specifics
--------------------

   

0 - Normal cartridge
.....................

      .3 .7  Size  8Kb  GAME  active (1)  EXROM  inactive
(0)  Load address  $8000-9FFF  multitable 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F        ASCII
----------------------------------------------   ---------------
0000: 43 36 34 20 43 41 52 54 52 49 44 47 45 20 20 20
C64?CARTRIDGE??? 0010: 00 00 00 40 01 00 00 00 00 01 00 00 00 00 00
00   ??????????????? 0020: 41 54 54 41 43 4B 20 4F 46 20 54 48 45 20
4D 55   ATTACK?OF?THE?MU 0030: 54 41 4E 54 20 43 41 4D 45 4C 53 00 00
00 00 00   TANT?CAMELS????? 0040: 43 48 49 50 00 00 20 10 00 00 00 00
80 00 20 00   CHIP????????.??? 0050: D3 9B BC FE C3 C2 CD 38 30 EA EA
EA A9 01 85 13   .?....80....??  example        The second
sample below is a dump of "Music Machine", a  4Kb  ULTIMAX     mode
cartridge. It  is  still  identified  as  a  "standard  cartridge"
according to the ID.      Normal cartridge    .3 .7  Size
4Kb (ULTIMAX mode)  GAME  inactive (0)  EXROM  active (1)
Load address  $F000-F7FF  multitable 

   00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F        ASCII
----------------------------------------------   ---------------
0000: 43 36 34 20 43 41 52 54 52 49 44 47 45 20 20 20
C64?CARTRIDGE??? 0010: 00 00 00 40 01 00 00 00 01 00 00 00 00 00 00
00   ??????????????? 0020: 4D 55 53 49 43 20 4D 41 43 48 49 4E 45 00
00 00   MUSIC?MACHINE??? 0030: 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00   ???????????????? 0040: 43 48 49 50 00 00 10 10 00 00 00 00
F0 00 10 00   CHIP???????????? 0050: 3C 66 C3 C3 66 3C FF FF 18 3C 66
7E 66 66 66 00   <f..f<???<f~fff?  example         The third
sample is a dump of "Adventure Creator",  a  16Kb  standard
cartridge.      Normal cartridge    .3 .7  Size  16Kb
GAME  inactive (0)  EXROM  inactive (0)  Load address
$8000-BFFF  multitable 

